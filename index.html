<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Horarios Laborales para Gran Hotel Miramar</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📅</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Times+New+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.1/dist/svg2pdf.umd.min.js" defer></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Tailwind gray-100 */
        }
        #logo-container svg {
            width: 200px;
            height: auto;
            margin-bottom: 0.75rem;
        }
        .table-container {
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0 0 0.375rem 0.375rem;
        }
        .sticky-col {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 10;
        }
        .draggable-row.bg-white > .sticky-col,
        .draggable-row > .sticky-col.employee-name-cell {
            background-color: #ffffff !important;
        }
        .draggable-row.bg-gray-50 > .sticky-col {
             background-color: #f9fafb !important; /* Tailwind bg-gray-50 */
        }

        .sticky-col-header {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 30;
            background-color: #f9fafb; /* gray-50 */
        }
        .sticky-header th {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            background-color: #f9fafb; /* gray-50 */
            z-index: 20;
        }
        .shift-cell {
            padding: 0.5rem 0.25rem;
            text-align: center;
            white-space: nowrap;
            font-size: 0.75rem;
            font-weight: 500;
            border-right: 1px solid #f3f4f6; /* gray-100 */
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .shift-cell:last-child {
            border-right: none;
        }
        .cell-selected {
            outline: 2px dashed #4f46e5; /* indigo-600 */
            outline-offset: -2px;
            background-color: #e0e7ff !important; /* indigo-100 */
        }

        .hidden-by-default {
            display: none !important;
        }

        .view-toggle-button {
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .view-toggle-button.active {
            background-color: #4f46e5;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(79,70,229,0.3), 0 2px 4px -1px rgba(79,70,229,0.2);
        }
        .view-toggle-button:not(.active) {
            background-color: #e5e7eb;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        .view-toggle-button:not(.active):hover {
            background-color: #d1d5db;
            border-color: #9ca3af;
        }
        .action-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        }
        .action-button:hover {
            opacity: 0.9;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .action-button:hover .fa-sync-alt { /* Animación existente para el botón de actualizar estadísticas */
            animation: fa-spin 1.5s linear infinite;
        }
        @keyframes fa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .notes-textarea {
            min-height: 150px;
            flex-grow: 1;
        }
        .day-header-date {
            display: block;
            font-weight: 600;
        }
        .day-header-weekday {
            display: block;
            font-size: 0.7rem;
            color: #6b7280;
            font-weight: 400;
        }
        .month-tabs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
        }
        .month-tab {
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
        }
        .month-tab:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
        }
        .month-tab.active {
            background-color: #4f46e5;
            color: white;
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(79, 70, 229, 0.2);
            font-size: 0.85rem;
        }
        .color-palette-popup {
            position: absolute;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            padding: 0.75rem;
            z-index: 50;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.375rem;
            width: auto;
            min-width: 260px;
        }
        .palette-color-swatch {
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.25rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s ease-in-out, border-color 0.1s;
        }
        .palette-color-swatch:hover {
            transform: scale(1.1);
            border-color: #4f46e5;
        }
        .legend-item-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }
        .legend-color-swatch {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
            border: 1px solid #9ca3af;
            cursor: pointer;
            transition: transform 0.1s;
            flex-shrink: 0;
        }
        .legend-color-swatch:hover {
            transform: scale(1.15);
        }
        .legend-time-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-left: 0.5rem;
        }
        .legend-time-inputs input[type="time"] {
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.25rem 0.375rem;
            font-size: 0.75rem;
            width: 75px;
        }
        .legend-item-flash .legend-color-swatch {
            animation: swatch-flash 0.7s ease-out;
        }
        .legend-item-flash .legend-time-inputs input {
            animation: input-flash 0.7s ease-out;
        }
        @keyframes swatch-flash {
            0%, 100% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.15); box-shadow: 0 0 10px rgba(79, 70, 229, 0.6); }
        }
        @keyframes input-flash {
            0%, 100% { border-color: #d1d5db; }
            50% { border-color: #4f46e5;  box-shadow: 0 0 5px rgba(79, 70, 229, 0.4);}
        }

        #history-section, #notes-section, #statistics-section, #legend-section {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 7px 20px -4px rgba(0,0,0,0.06), 0 4px 8px -3px rgba(0,0,0,0.04);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }
        .section-title i {
            margin-right: 0.75rem;
            color: #4f46e5;
        }
        #legend-section .section-title {
            flex-grow: 1;
        }
        #legend-section .flex-shrink-0 {
            margin-left: auto;
        }


        #change-history-list-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            background-color: #f9fafb;
            min-height: 150px;
            max-height: 250px;
        }
        #change-history-list li {
            padding: 0.375rem 0.25rem;
            font-size: 0.8rem;
            color: #4b5563;
            border-bottom: 1px solid #f3f4f6;
        }
        #change-history-list li:last-child {
            border-bottom: none;
        }
        #change-history-list li .history-time {
            font-weight: 500;
            color: #1f2937;
            margin-right: 0.375rem;
        }
        #multiselect-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #374151;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            z-index: 100;
            gap: 0.5rem;
        }
        #multiselect-toolbar:not(.hidden-by-default) {
            display: flex;
        }
        #multiselect-toolbar.hidden-by-default {
             display: none !important;
        }
        #multiselect-toolbar button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #multiselect-toolbar button:hover {
            background-color: #4338ca;
        }
        #multiselect-toolbar button.other-selection {
            background-color: #6b7280;
        }
        #multiselect-toolbar button.other-selection:hover {
            background-color: #4b5563;
        }
        /* ESTILOS PARA EL ICONO DE AYUDA Y SU MODAL - INICIO */
        #help-icon-container i {
            transition: transform 0.2s ease-in-out, color 0.2s ease-in-out;
        }

        #help-icon-container:hover i {
            transform: scale(1.2);
            color: #facc15; /* Tailwind yellow-500, un poco más brillante */
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.7); /* Efecto de brillo */
        }

        #current-month-year-display {
            padding-right: 4rem; /* Asegura espacio para el icono de ayuda */
        }
        #help-icon-container {
            top: 50%; /* Centra verticalmente respecto al h2 */
            right: 1rem; /* Espacio desde la derecha */
            transform: translateY(-50%); /* Ajuste fino para centrar verticalmente */
        }

        /* Estilos para la modal de Consejos */
        #tips-modal .modal-content {
			max-width: 42rem;
			background-color: #f9fafb;
			border-radius: 0.75rem;
			box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
			padding: 1.5rem; /* Ajustamos el padding si es necesario, p-6 de Tailwind es 1.5rem */
			width: 90%; /* Para que no ocupe todo el ancho en móviles pequeños */
			max-height: 85vh;       /* AÑADIDO: Altura máxima del contenido de la modal */
			overflow-y: auto;       /* AÑADIDO: Scroll vertical DENTRO del contenido de la modal */
			display: flex;          /* AÑADIDO: Para mejor control del layout interno */
			flex-direction: column; /* AÑADIDO: Para apilar cabecera, cuerpo y pie verticalmente */
			margin-bottom: 5vh;     /* AÑADIDO: Espacio inferior para que no quede pegado abajo */

        }

        #tips-modal h3 { /* Título principal de la modal */
            font-family: 'Inter', sans-serif;
        }

        #tips-modal h4 { /* Subtítulos de cada consejo */
            font-family: 'Inter', sans-serif;
            font-size: 1rem; /* 16px */
            margin-top: 0.75rem; /* Espacio antes de cada subtítulo */
        }

        #tips-modal ul {
            margin-left: 1rem; /* Indentación para las listas */
        }

        #tips-modal li {
            margin-bottom: 0.375rem; /* Espacio entre elementos de la lista */
        }

        #tips-modal code {
            background-color: #e0e7ff; /* indigo-100 */
            color: #3730a3; /* indigo-800 */
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.85em;
            font-family: 'Courier New', Courier, monospace;
        }
        /* ESTILOS PARA EL ICONO DE AYUDA Y SU MODAL - FIN */
        .employee-name-cell {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
        }
        .employee-name-display {
             cursor: grab;
             flex-grow: 1;
        }
        .employee-name-cell:hover .edit-icon, .employee-name-cell:hover .delete-employee-icon {
            opacity: 1;
        }
        .edit-icon, .delete-employee-icon {
            opacity: 0.3;
            margin-left: 8px;
            font-size: 0.9em;
            transition: opacity 0.2s;
            cursor: pointer;
        }
        .delete-employee-icon:hover {
            color: #ef4444;
        }
        .draggable-row.dragging {
            opacity: 0.4;
            background: #c7d2fe;
        }
        .drag-over-indicator {
            height: 3px;
            background-color: #4f46e5;
            margin: -1px 0;
        }
        .modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
			overflow-y: auto;
            padding-top: 5vh;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            width: 100%;
            max-width: 28rem;
        }
        .unsaved-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            margin-left: 0.5rem;
            vertical-align: middle;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .unsaved-dot.hidden-by-default {
            opacity: 0;
            transform: scale(0);
        }

        .add-employee-row-reformed {
            border-top: 1px dashed #d1d5db;
        }

        .add-employee-cell-reformed {
            padding: 0.75rem;
            text-align: left;
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background-color: #f9fafb;
            z-index: 10;
        }

        .add-employee-button-visual {
            display: inline-flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.55rem 0.9rem;
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
        }

        .add-employee-button-visual:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
            color: #1f2937;
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 4px 8px -1px rgba(0,0,0,0.07), 0 2px 4px -1px rgba(0,0,0,0.04);
        }

        .add-employee-button-visual:active {
            transform: translateY(0px) scale(0.99);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }

        .add-employee-button-visual i {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.85em;
        }

        .add-employee-button-visual:hover i {
            transform: rotate(135deg) scale(1.1);
            color: #4f46e5;
        }

        .add-employee-empty-cell-reformed {
            padding: 0.5rem 1rem;
            background-color: #f9fafb;
            border-right: 1px solid #f3f4f6;
            height: 54px;
        }
        .add-employee-empty-cell-reformed:last-child {
            border-right: none;
        }

        #comparative-stats-table-container {
            width: 100%;
            overflow-x: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            margin-top: 1rem;
            max-height: 70vh;
        }

        #comparative-stats-table {
            min-width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        #comparative-stats-table th,
        #comparative-stats-table td {
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-size: 0.8rem;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
        }
        @media (min-width: 768px) {
            #comparative-stats-table th,
            #comparative-stats-table td {
                padding: 0.75rem 1rem;
                font-size: 0.875rem;
            }
        }


        #comparative-stats-table th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 20;
        }
        #comparative-stats-table th.sortable {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        #comparative-stats-table th.sortable:hover {
            background-color: #f0f2f5;
        }
        #comparative-stats-table th.sortable .sort-icon {
            margin-left: 0.35rem;
            opacity: 0.5;
            transition: opacity 0.2s, transform 0.2s;
            display: inline-block;
        }
         #comparative-stats-table th.sortable:hover .sort-icon {
            opacity: 1;
            transform: scale(1.1);
        }
        #comparative-stats-table th.sortable .sort-icon.fa-sort-up,
        #comparative-stats-table th.sortable .sort-icon.fa-sort-down {
            opacity: 1;
            color: #4f46e5;
        }
        #comparative-stats-table tbody tr {
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        #comparative-stats-table tbody tr.stats-row-selected {
            background-color: #e0e7ff !important;
        }
        #comparative-stats-table tbody tr.stats-row-selected td.employee-name-col {
             background-color: #e0e7ff !important;
        }


        #comparative-stats-table tbody tr:nth-child(even) {
            background-color: #f9fafb;
        }
        #comparative-stats-table tbody tr:hover {
            background-color: #eff6ff;
        }

        #comparative-stats-table .employee-name-col {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: inherit;
            border-right: 1px solid #e5e7eb;
            min-width: 120px;
        }
        #comparative-stats-table tbody tr:hover .employee-name-col {
            background-color: #eff6ff !important;
        }
        #comparative-stats-table tbody tr:nth-child(even) .employee-name-col {
            background-color: #f9fafb !important;
        }
        #comparative-stats-table tbody tr:nth-child(odd) .employee-name-col {
            background-color: #ffffff !important;
        }

        #stats-placeholder {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-size: 0.875rem;
        }

        #employee-shift-distribution-detail-container {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05), 0 2px 4px -1px rgba(0,0,0,0.03);
        }
        #employee-shift-distribution-detail-container h4 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
            text-align: center;
        }
        #employee-shift-chart {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            height: 230px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
            gap: 0.75rem;
            margin-top: 35px;
        }
        .shift-chart-bar-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
            max-width: 80px;
        }
        .shift-chart-bar {
            width: 70%;
            min-width: 25px;
            max-width: 50px;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
            border-radius: 0.25rem 0.25rem 0 0;
            position: relative;
            transition: height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            overflow: visible;
            min-height: 5px;
        }
         .shift-chart-bar .bar-value {
            position: absolute;
            top: -22px; /* Ajustado para que esté claramente encima */
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: 600;
            padding: 1px 4px;
            background-color: rgba(243, 244, 246, 0.9);
            color: #374151;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            white-space: nowrap;
            z-index: 1;
        }
        .shift-chart-bar-label {
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #4b5563;
            font-weight: 500;
            text-align: center;
            white-space: nowrap;
        }

        .footer-name {
            transition: opacity 0.5s ease-in-out, color 0.5s ease-in-out;
            cursor: pointer;
        }
        .footer-name.hidden-name {
            opacity: 0;
            color: #4f46e5;
        }
        .footer-name.visible-name {
            opacity: 1;
            color: inherit;
        }

        /* === INICIO: ANIMACIONES PARA BOTONES === */
        @keyframes button-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        #save-local-button:hover {
            animation: button-shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes icon-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        #create-empty-csv-button:hover .fa-file-medical {
            animation: icon-pulse 0.6s ease-in-out;
        }

        @keyframes icon-jiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
        }
        #export-csv-button:hover .fa-file-csv {
            animation: icon-jiggle 0.4s ease-in-out;
        }

        @keyframes icon-download {
            0% { transform: translateY(0); }
            50% { transform: translateY(3px); }
            100% { transform: translateY(0); }
        }
        #download-weekly-svg-button:hover .fa-file-pdf,
        #download-image-button:hover .fa-file-pdf {
            animation: icon-download 0.5s ease-in-out;
        }

        /* Animación para el signo '+' en fa-calendar-plus */
        #export-month-calendar-button:hover .fa-calendar-plus::after {
            content: '+'; /* Esto es un truco, FontAwesome usa pseudo-elementos */
            display: inline-block;
            animation: plus-grow 0.3s ease-out forwards;
            transform-origin: center;
        }
        @keyframes plus-grow {
            0% { transform: scale(1); }
            100% { transform: scale(1.3); }
        }
         /* Para los iconos de vista mensual/anual */
        .view-toggle-button:not(.active):hover i {
            transform: scale(1.15);
            color: #3730a3; /* Un índigo más oscuro */
            transition: transform 0.2s, color 0.2s;
        }
        .view-toggle-button.active i {
             transform: scale(1.1); /* Un poco más grande cuando está activo */
        }

        /* === FIN: ANIMACIONES PARA BOTONES === */

    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto max-w-full">
        <header class="mb-10 text-center">
            <div id="logo-container" class="flex justify-center mb-3">
                </div>
            <h1 id="main-title-text" class="text-4xl md:text-5xl font-bold text-gray-800 tracking-tight inline-block"></i>Gestor de Horarios Laborales
            </h1>
        </header>

        <section id="controls-section" class="mb-8 p-6 bg-white rounded-xl shadow-xl">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 items-end">
                <div>
                    <label for="csv-file-input" class="block text-sm font-medium text-gray-700 mb-1">Importar Horario (CSV):</label>
                    <input type="file" id="csv-file-input" accept=".csv" class="w-full text-sm text-gray-500
                        file:mr-4 file:py-2.5 file:px-4 file:cursor-pointer
                        file:rounded-lg file:border-0
                        file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700
                        hover:file:bg-indigo-100 transition-colors
                    "/>
                    <button id="create-empty-csv-button" class="action-button w-full mt-2 bg-sky-600 text-white hover:bg-sky-700 focus:ring-2 focus:ring-sky-500 focus:ring-offset-2">
                        <i class="fas fa-file-medical mr-2"></i>Crear CSV Vacío
                    </button>
                </div>
                <div>
                    <label for="year-input" class="block text-sm font-medium text-gray-700 mb-1">Año del Horario:</label>
                    <input type="number" id="year-input" value="2026" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                 <div class="lg:col-start-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                    <button id="save-local-button" title="Guarda el horario actual, las notas y la configuración de colores en el almacenamiento local de tu navegador." class="action-button flex-1 bg-green-600 text-white hover:bg-green-700 focus:ring-2 focus:ring-green-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-save"></i>Guardar Local
                    </button>
                    <button id="export-csv-button" class="action-button flex-1 bg-blue-600 text-white hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-csv"></i>Exportar CSV
                    </button>
                </div>
            </div>

             <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-4 items-end mt-4">
                <div class="md:col-span-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                     <button id="export-month-calendar-button" class="action-button flex-1 bg-orange-500 text-white hover:bg-orange-600 focus:ring-2 focus:ring-orange-400 focus:ring-offset-2" disabled>
                        <i class="fas fa-calendar-plus mr-2"></i>Exportar Mes a Calendar
                    </button>
                    <button id="download-weekly-svg-button" class="action-button flex-1 bg-teal-600 text-white hover:bg-teal-700 focus:ring-2 focus:ring-teal-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Semanal PDF
                    </button>
                    <button id="download-image-button" class="action-button flex-1 bg-purple-600 text-white hover:bg-purple-700 focus:ring-2 focus:ring-purple-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Calendario PDF
                    </button>
                </div>
            </div>

            <div id="view-mode-buttons-container" class="mt-4 flex justify-center gap-3 border-t border-gray-200 pt-4 hidden-by-default">
                <button id="view-monthly-button" class="view-toggle-button active"><i class="fas fa-calendar-day mr-2"></i>Vista Mensual</button>
                <button id="view-annual-button" class="view-toggle-button"><i class="fas fa-calendar-alt mr-2"></i>Vista Anual</button>
            </div>
        </section>

        <section id="welcome-message" class="my-8 p-8 bg-indigo-50 text-indigo-700 rounded-xl shadow-lg text-center">
            <i class="fas fa-info-circle fa-2x mb-3"></i>
            <p class="text-lg">Bienvenido/a al Gestor de Horarios.</p>
            <p class="text-sm">Por favor, importa un archivo CSV o carga datos guardados localmente para comenzar.</p>
        </section>

        <main id="schedule-display-section" class="hidden-by-default">
             <div id="month-tabs-container" class="month-tabs-container">
                </div>

            <section id="schedule-table-section" class="bg-white rounded-xl shadow-xl overflow-hidden">
                <h2 id="current-month-year-display" class="text-2xl font-bold text-gray-800 p-5 border-b border-gray-200 bg-gray-50 rounded-t-xl relative">
                    <span id="current-month-year-text">Horario para [Mes Año]</span>
                    <span id="unsaved-indicator-table" class="unsaved-dot hidden-by-default" title="Hay cambios sin guardar"></span>
                    <span id="help-icon-container" class="absolute top-0 right-0 p-3 cursor-pointer" title="Mostrar Consejos Útiles">
                        <i class="fas fa-lightbulb text-gray-500 text-2xl"></i>
                    </span>
                </h2>
                <div class="table-container">
                    <table id="schedule-table" class="min-w-full divide-y divide-gray-200">
                        <thead id="schedule-table-head" class="bg-gray-50 sticky-header"></thead>
                        <tbody id="schedule-table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <div id="no-data-message" class="p-8 text-center text-gray-500 text-lg hidden-by-default">
                    <i class="fas fa-folder-open fa-2x mb-3 text-gray-400"></i><br>
                    No hay datos de horario para mostrar. Importa un archivo CSV o añade empleados.
                </div>
            </section>

            <div class="mt-10 grid grid-cols-1 lg:grid-cols-3 gap-8">
                <section id="statistics-section" class="lg:col-span-3">
                    <h3 class="section-title"><i class="fas fa-chart-bar"></i>Análisis Estadístico Comparativo</h3>
                    <div class="flex flex-wrap gap-x-6 gap-y-4 mb-6 items-end">
                        <div class="flex-grow md:flex-grow-0">
                            <label for="stats-period-filter-new" class="block text-sm font-medium text-gray-700 mb-1">Periodo de Análisis:</label>
                            <select id="stats-period-filter-new" class="w-full md:min-w-[200px] p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                                <option value="full_year">Año Completo Seleccionado</option>
                            </select>
                        </div>
                        <div class="flex items-end">
                            <button id="calculate-stats-button-new" class="w-full md:w-auto action-button bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500 text-sm py-2.5" disabled>
                                <i class="fas fa-sync-alt mr-1.5"></i>Actualizar Estadísticas
                            </button>
                        </div>
                    </div>

                    <div id="comparative-stats-table-container">
                    </div>
                     <div id="employee-shift-distribution-detail-container" class="mt-6 hidden-by-default">
                        <h4 id="employee-shift-detail-title" class="text-lg font-semibold text-gray-700 mb-3 text-center">Distribución de Turnos para: <span id="employee-name-for-detail-chart" class="text-indigo-600"></span></h4>
                        <div id="employee-shift-chart" class="bar-chart">
                        </div>
                    </div>
                    <div id="stats-placeholder" class="hidden-by-default">
                        <p>No hay datos de horario cargados o no hay empleados para mostrar estadísticas.</p>
                        <p class="mt-2">Importa un archivo CSV o añade empleados y luego haz clic en "Actualizar Estadísticas".</p>
                    </div>
                </section>

                 <section id="legend-section" class="lg:col-span-2 mt-0">
                    <div class="flex flex-wrap justify-between items-center mb-3 border-b border-gray-200 pb-3">
                        <h3 class="section-title flex-grow mb-0 border-b-0 pb-0 !mb-0"><i class="fas fa-palette mr-2 text-gray-400"></i>Leyenda, Colores y Horarios</h3>
                        <div class="flex-shrink-0">
                            <button id="apply-colors-button" class="action-button bg-indigo-500 text-white hover:bg-indigo-600 focus:ring-indigo-400 text-xs px-3 py-1.5 mr-2" disabled>
                                <i class="fas fa-check"></i>Aplicar
                            </button>
                            <button id="reset-colors-button" class="action-button bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-400 text-xs px-3 py-1.5" disabled>
                                <i class="fas fa-undo"></i>Restaurar
                            </button>
                        </div>
                    </div>
                    <div id="legend-items-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 text-sm">
                    </div>
                </section>


                <section id="history-section" class="lg:col-span-1 mt-0">
                    <div class="flex justify-between items-center mb-3 border-b border-gray-200 pb-3">
                        <h3 class="section-title !mb-0 !border-b-0 !pb-0 flex-grow">
                            <i class="fas fa-history"></i>Historial de Cambios
                        </h3>
                        <div class="flex-shrink-0">
                            <button id="undo-button" title="Deshacer (Ctrl+Z)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5 mr-2" disabled>
                                <i class="fas fa-undo"></i>
                            </button>
                            <button id="redo-button" title="Rehacer (Ctrl+Y)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5" disabled>
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                    </div>
                    <div id="change-history-list-container">
                        <ul id="change-history-list">
                            <li class="text-center text-gray-400">No hay cambios recientes.</li>
                        </ul>
                    </div>
                </section>

                <section id="notes-section" class="lg:col-span-3">
                    <h3 class="section-title"><i class="fas fa-pencil-alt"></i>Notas Generales</h3>
                    <textarea id="general-notes" class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 text-sm notes-textarea" placeholder="Añade comentarios o recordatorios aquí..."></textarea>
                </section>
            </div>
        </main>

        <footer class="mt-16 text-center text-sm text-gray-500">
            <p id="footer-text">Gestor de Horarios. Creado por <span id="creator-name" class="footer-name">Nefi Badillo</span> con <i id="footer-heart" class="fas fa-heart text-red-500 footer-name"></i>.</p>
        </footer>
    </div>

    <div id="toast-container" class="fixed bottom-6 right-6 space-y-3 z-50"></div>
    <div id="color-palette-popup-container"></div>
    <div id="multiselect-toolbar" class="hidden-by-default">
        </div>

    <div id="add-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">Añadir Nuevo Empleado</h3>
                <div>
                    <input type="text" id="modal-employee-name-input" placeholder="Nombre del empleado" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-add-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-add-employee" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Añadir</button>
                </div>
            </div>
        </div>
    </div>
    <div id="delete-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-red-600 mb-2">¡Atención!</h3>
                <p class="text-gray-700 mb-4">Estás a punto de eliminar al empleado <strong id="employee-name-to-delete" class="font-semibold"></strong> y todos sus datos de horario.</p>
                <p class="text-sm text-gray-500 mb-1">Esta acción es permanente.</p>
                <p id="delete-countdown-message" class="text-red-500 font-semibold mb-4"></p>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-delete-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-delete-employee" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2" disabled>Eliminar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="filename-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="filename-modal-title" class="text-xl font-bold text-gray-900 mb-2">Nombre del Archivo</h3>
            <p id="filename-modal-description" class="text-sm text-gray-600 mb-4"></p>
            <div>
                <input type="text" id="modal-filename-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="nombre_del_archivo">
                <p class="text-xs text-gray-500 mt-1">No incluyas la extensión (ej: .csv o .pdf).</p>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-filename" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-filename" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Aceptar</button>
            </div>
        </div>
    </div>

    <div id="export-calendar-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-900 mb-4">Exportar Mes a Calendar</h3>
            <div class="mb-4">
                <label for="modal-calendar-employee-select" class="block text-sm font-medium text-gray-700 mb-1">Selecciona Empleado:</label>
                <select id="modal-calendar-employee-select" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                    </select>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-export-calendar" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-export-calendar" class="action-button bg-orange-500 text-white hover:bg-orange-600 px-4 py-2">Exportar</button>
            </div>
        </div>
    </div>

    <div id="tips-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-lg bg-gray-50 p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-6 pb-3 border-b border-gray-300">
                <h3 class="text-2xl font-bold text-indigo-700"><i class="fas fa-lightbulb text-yellow-400 mr-3"></i>Consejos Útiles</h3>
                <button id="close-tips-modal" class="text-gray-500 hover:text-gray-800 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>

            <div class="space-y-4 text-gray-700 text-sm">
                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar/Deseleccionar Celdas (Clic):</h4>
                    <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Usa <code>Ctrl/Cmd + Clic</code>.</li>
                        <li><strong>Móvil:</strong> Realiza una pulsación larga sobre la celda.</li>
                        <li><strong>Seleccionar Rango (PC/Mac):</strong> Haz clic en la celda de inicio, luego mantén presionada la tecla <code>Shift</code> y haz clic en la celda final.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar Múltiples Celdas (Arrastrando):</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Haz clic en una celda y, sin soltar, arrastra el cursor para seleccionar un bloque. Si retrocedes sobre celdas ya seleccionadas en este arrastre, se deseleccionarán.</li>
                        <li><strong>Móvil:</strong> Toca una celda para seleccionarla. Luego, mantén pulsado sobre esa misma celda seleccionada* y arrastra el dedo para expandir la selección a celdas adyacentes. Si retrocedes, se deseleccionarán.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Reordenar Empleados:</h4>
                    <p class="pl-4">Arrastra y suelta el nombre del empleado en la tabla para cambiar su posición.</p>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Editar Texto en Celdas:</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>Nombres de Empleado:</strong> Doble clic (PC/Mac) o pulsación larga (Móvil) sobre el nombre.</li>
                        <li><strong>Turnos Personalizados:</strong> Doble clic (PC/Mac) o pulsación larga (Móvil) sobre una celda que ya contenga texto personalizado (no un turno estándar como M, T, N, L, V). No se permiten comas.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Barra de Acciones Rápida:</h4>
                    <p class="pl-4">Tras seleccionar una o más celdas, aparecerá una barra de acciones en la parte inferior de la pantalla. Úsala para asignar rápidamente turnos estándar (M, T, N, L, V) o para limpiar la celda (botón "Otro", que asigna un valor vacío, permitiendo luego escribir texto personalizado si se desea).</p>
                </div>
            </div>

            <div class="mt-8 text-right">
                <button id="ok-tips-modal" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-6 py-2 rounded-lg">
                    Entendido
                </button>
            </div>
        </div>
    </div>

    <div id="custom-event-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="custom-event-modal-title" class="text-xl font-bold text-gray-900 mb-4">Editar Evento</h3>
            <div>
                <input type="text" id="modal-custom-event-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="Introduce evento o texto">
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-custom-event" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-custom-event" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Guardar</button>
            </div>
        </div>
    </div>


    <script>
        // --- CONSTANTES Y CONFIGURACIÓN ---
        const SVG_FINAL_LOGO_MARKUP = `
            <svg width="200" height="75" viewBox="0 0 220 100" xmlns="http://www.w3.org/2000/svg">
                <style>
                    .logo-text-gh { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-weight: normal; fill: #252525; text-anchor: middle; dominant-baseline: central; }
                    .logo-text-m { font-family: 'Times New Roman', Times, serif; font-size: 26px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: central; }
                    .stars-group { fill: #B08D57; }
                </style>
                <defs>
                    <path id="star-shape" d="M10 0 L12.3511 6.1803 L19.5106 7.2949 L14.7295 12.3197 L15.2939 19.0211 L10 16 L4.7061 19.0211 L5.2705 12.3197 L0.4894 7.2949 L7.6489 6.1803 Z" />
                </defs>
                <text x="110" y="28" class="logo-text-gh">GRAN HOTEL</text>
                <text x="110" y="55" class="logo-text-m">MIRAMAR</text>
                <g class="stars-group" transform="translate(68.5, 72) scale(0.7)">
                    <use href="#star-shape" x="0" />
                    <use href="#star-shape" x="25" />
                    <use href="#star-shape" x="50" />
                    <use href="#star-shape" x="75" />
                    <use href="#star-shape" x="100" />
                </g>
            </svg>
        `;

        const MONTH_NAMES = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
        const SHORT_MONTH_NAMES = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const WEEK_DAY_NAMES = ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"];
        const SHORT_WEEK_DAY_NAMES = ["D", "L", "M", "X", "J", "V", "S"];
        const SHIFT_TYPES = ["M", "T", "N", "L", "V"];
        const SHIFT_TYPE_FULL_NAMES = {
            M: "Mañana", T: "Tarde", N: "Noche", L: "Libre", V: "Vacaciones"
        };
        const DEFAULT_SHIFT_TIMES = {
            M: { start: [7,0], end: [15,0], nextDayEnd: false },
            T: { start: [15,0], end: [23,0], nextDayEnd: false },
            N: { start: [23,0], end: [7,0], nextDayEnd: true }
        };
        let currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));

        const LOCAL_STORAGE_KEY_SCHEDULE = 'scheduleAppData_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_NOTES = 'scheduleAppNotes_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_VIEW = 'scheduleAppView_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_COLORS = 'scheduleAppColors_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_HISTORY = 'scheduleAppHistory_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_YEAR = 'scheduleAppYear_v3_26_svglogo_final_stats_reforma_v2.6_undo';
        const LOCAL_STORAGE_KEY_SHIFT_TIMES = 'scheduleAppShiftTimes_v3_26_svglogo_final_stats_reforma_v2.6_undo';

        const MAX_HISTORY_ITEMS = 30;
        const MAX_UNDO_STACK_SIZE = 30;

        let undoStack = [];
        let redoStack = [];

        const LONG_PRESS_DURATION = 500;
        const MAX_TOUCH_MOVE_THRESHOLD = 10; // Max pixels a touch can move and still be considered a tap/long-press
        let dragOverIndicator = null;
        let deleteCountdownInterval = null;
        let employeeToDeleteName = null;

        const DEFAULT_SHIFT_COLORS = {
            M: { bg: 'bg-green-200', text: 'text-green-700', hexBg: '#a7f3d0', hexText: '#047857' },
            T: { bg: 'bg-orange-200', text: 'text-orange-700', hexBg: '#fed7aa', hexText: '#c2410c' },
            N: { bg: 'bg-blue-200', text: 'text-blue-700', hexBg: '#bfdbfe', hexText: '#1d4ed8' },
            L: { bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            V: { bg: 'bg-yellow-200', text: 'text-yellow-700', hexBg: '#fef08a', hexText: '#a16207' },
            empty: { bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' }
        };

        const AVAILABLE_COLORS = [
            { name: 'Blanco', bg: 'bg-white', text: 'text-gray-400', hexBg: '#ffffff', hexText: '#9ca3af' },
            { name: 'Verde Pastel', bg: 'bg-green-200', text: 'text-green-700', hexBg: '#a7f3d0', hexText: '#047857' },
            { name: 'Naranja Pastel', bg: 'bg-orange-200', text: 'text-orange-700', hexBg: '#fed7aa', hexText: '#c2410c' },
            { name: 'Azul Pastel', bg: 'bg-blue-200', text: 'text-blue-700', hexBg: '#bfdbfe', hexText: '#1d4ed8' },
            { name: 'Gris Pastel', bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            { name: 'Amarillo Pastel', bg: 'bg-yellow-200', text: 'text-yellow-700', hexBg: '#fef08a', hexText: '#a16207' },
            { name: 'Rojo Pastel', bg: 'bg-red-200', text: 'text-red-700', hexBg: '#fecaca', hexText: '#b91c1c' },
            { name: 'Morado Pastel (Def. Otro)', bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' },
            { name: 'Cian Pastel', bg: 'bg-cyan-200', text: 'text-cyan-700', hexBg: '#a5f3fc', hexText: '#0e7490' },
            { name: 'Rosa Pastel', bg: 'bg-pink-200', text: 'text-pink-700', hexBg: '#fbcfe8', hexText: '#be185d' },
            { name: 'Lima Pastel', bg: 'bg-lime-200', text: 'text-lime-700', hexBg: '#d9f99d', hexText: '#65a30d' },
            { name: 'Esmeralda Pastel', bg: 'bg-emerald-200', text: 'text-emerald-700', hexBg: '#a7f3d0', hexText: '#065f46' },
            { name: 'Turquesa Pastel', bg: 'bg-teal-200', text: 'text-teal-700', hexBg: '#99f6e4', hexText: '#0d9488' },
            { name: 'Fucsia Pastel', bg: 'bg-fuchsia-200', text: 'text-fuchsia-700', hexBg: '#f5d0fe', hexText: '#a21caf' },
            { name: 'Rosado Pastel', bg: 'bg-rose-200', text: 'text-rose-700', hexBg: '#fecdd3', hexText: '#be123c' },
            { name: 'Celeste Pastel', bg: 'bg-sky-200', text: 'text-sky-700', hexBg: '#bae6fd', hexText: '#0369a1' },
            { name: 'Índigo Pastel', bg: 'bg-indigo-200', text: 'text-indigo-700', hexBg: '#c7d2fe', hexText: '#4338ca' },
            { name: 'Menta', bg: 'bg-green-100', text: 'text-green-600', hexBg: '#dcfce7', hexText: '#166534' },
            { name: 'Melocotón', bg: 'bg-orange-100', text: 'text-orange-600', hexBg: '#ffedd5', hexText: '#c2410c' },
            { name: 'Azul Cielo', bg: 'bg-blue-100', text: 'text-blue-600', hexBg: '#dbeafe', hexText: '#2563eb' },
            { name: 'Gris Muy Claro', bg: 'bg-gray-100', text: 'text-gray-600', hexBg: '#f3f4f6', hexText: '#4b5563' },
            { name: 'Crema', bg: 'bg-yellow-100', text: 'text-yellow-600', hexBg: '#fef9c3', hexText: '#ca8a04' },
            { name: 'Salmón', bg: 'bg-red-100', text: 'text-red-600', hexBg: '#fee2e2', hexText: '#dc2626' },
            { name: 'Lavanda', bg: 'bg-purple-100', text: 'text-purple-600', hexBg: '#f3e8ff', hexText: '#7e22ce' },
            { name: 'Aguamarina', bg: 'bg-cyan-100', text: 'text-cyan-600', hexBg: '#cffafe', hexText: '#0891b2' },
            { name: 'Rosa Bebé', bg: 'bg-pink-100', text: 'text-pink-600', hexBg: '#fce7f3', hexText: '#db2777' },
            { name: 'Jade Claro', bg: 'bg-emerald-100', text: 'text-emerald-600', hexBg: '#d1fae5', hexText: '#059669' },
            { name: 'Menta Azulado', bg: 'bg-teal-100', text: 'text-teal-600', hexBg: '#ccfbf1', hexText: '#0d9488' },
            { name: 'Magenta Claro', bg: 'bg-fuchsia-100', text: 'text-fuchsia-600', hexBg: '#fae8ff', hexText: '#a21caf' },
            { name: 'Coral Claro', bg: 'bg-rose-100', text: 'text-rose-600', hexBg: '#ffe4e6', hexText: '#e11d48' },
            { name: 'Azul Hielo', bg: 'bg-sky-100', text: 'text-sky-600', hexBg: '#e0f2fe', hexText: '#0284c7' },
            { name: 'Índigo Muy Claro', bg: 'bg-indigo-100', text: 'text-indigo-600', hexBg: '#e0e7ff', hexText: '#4f46e5' },
            { name: 'Verde Suave', bg: 'bg-green-300', text: 'text-green-800', hexBg: '#86efac', hexText: '#047857' },
            { name: 'Naranja Suave', bg: 'bg-orange-300', text: 'text-orange-800', hexBg: '#fdba74', hexText: '#9a3412' },
            { name: 'Azul Suave', bg: 'bg-blue-300', text: 'text-blue-800', hexBg: '#93c5fd', hexText: '#1e40af' },
            { name: 'Amarillo Suave', bg: 'bg-yellow-300', text: 'text-yellow-800', hexBg: '#fde047', hexText: '#854d0e' },
            { name: 'Rojo Intenso', bg: 'bg-red-500', text: 'text-white', hexBg: '#ef4444', hexText: '#ffffff' },
            { name: 'Naranja Intenso', bg: 'bg-orange-500', text: 'text-white', hexBg: '#f97316', hexText: '#ffffff' },
            { name: 'Ámbar Intenso', bg: 'bg-amber-500', text: 'text-black', hexBg: '#f59e0b', hexText: '#000000' },
            { name: 'Lima Intenso', bg: 'bg-lime-500', text: 'text-white', hexBg: '#84cc16', hexText: '#ffffff' },
            { name: 'Verde Intenso', bg: 'bg-green-600', text: 'text-white', hexBg: '#16a34a', hexText: '#ffffff' },
            { name: 'Esmeralda Intenso', bg: 'bg-emerald-500', text: 'text-white', hexBg: '#10b981', hexText: '#ffffff' },
            { name: 'Turquesa Intenso', bg: 'bg-teal-500', text: 'text-white', hexBg: '#14b8a6', hexText: '#ffffff' },
            { name: 'Cian Intenso', bg: 'bg-cyan-500', text: 'text-white', hexBg: '#06b6d4', hexText: '#ffffff' },
            { name: 'Celeste Intenso', bg: 'bg-sky-600', text: 'text-white', hexBg: '#0284c7', hexText: '#ffffff' },
            { name: 'Azul Intenso', bg: 'bg-blue-600', text: 'text-white', hexBg: '#2563eb', hexText: '#ffffff' },
            { name: 'Índigo Intenso', bg: 'bg-indigo-600', text: 'text-white', hexBg: '#4f46e5', hexText: '#ffffff' },
            { name: 'Violeta Intenso', bg: 'bg-violet-600', text: 'text-white', hexBg: '#7c3aed', hexText: '#ffffff' },
            { name: 'Púrpura Intenso', bg: 'bg-purple-600', text: 'text-white', hexBg: '#9333ea', hexText: '#ffffff' },
            { name: 'Fucsia Intenso', bg: 'bg-fuchsia-600', text: 'text-white', hexBg: '#d946ef', hexText: '#ffffff' },
            { name: 'Rosa Intenso', bg: 'bg-pink-600', text: 'text-white', hexBg: '#db2777', hexText: '#ffffff' },
            { name: 'Rosado Intenso', bg: 'bg-rose-600', text: 'text-white', hexBg: '#e11d48', hexText: '#ffffff' },
            { name: 'Gris Medio', bg: 'bg-gray-400', text: 'text-black', hexBg: '#9ca3af', hexText: '#000000' },
            { name: 'Gris Oscuro', bg: 'bg-gray-600', text: 'text-white', hexBg: '#4b5563', hexText: '#ffffff' },
            { name: 'Amarillo Oro', bg: 'bg-yellow-500', text: 'text-black', hexBg: '#eab308', hexText: '#000000' },
            { name: 'Verde Bosque', bg: 'bg-green-700', text: 'text-white', hexBg: '#047857', hexText: '#ffffff' },
            { name: 'Azul Marino', bg: 'bg-blue-800', text: 'text-white', hexBg: '#1e40af', hexText: '#ffffff' },
            { name: 'Morado Real', bg: 'bg-purple-700', text: 'text-white', hexBg: '#6b21a8', hexText: '#ffffff' },
            { name: 'Rojo Carmesí', bg: 'bg-red-700', text: 'text-white', hexBg: '#b91c1c', hexText: '#ffffff' },
            { name: 'Naranja Fuerte', bg: 'bg-orange-600', text: 'text-white', hexBg: '#ea580c', hexText: '#ffffff' },
            { name: 'Cian Oscuro', bg: 'bg-cyan-700', text: 'text-white', hexBg: '#0891b2', hexText: '#ffffff' },
            { name: 'Índigo Oscuro', bg: 'bg-indigo-700', text: 'text-white', hexBg: '#4338ca', hexText: '#ffffff' },
            { name: 'Rosa Mexicano', bg: 'bg-pink-500', text: 'text-white', hexBg: '#ec4899', hexText: '#ffffff' },
            { name: 'Verde Lima Fuerte', bg: 'bg-lime-600', text: 'text-white', hexBg: '#65a30d', hexText: '#ffffff' },
        ];

        let currentShiftColors = { ...DEFAULT_SHIFT_COLORS };
        let activeColorPalette = null;

        let scheduleData = {};
        let employeeNamesOrdered = [];
        let currentViewMode = 'monthly';
        let currentSelectedMonth = new Date().getMonth() + 1;
        let yearOfSchedule = new Date().getFullYear();
        let hasUnsavedChanges = false;
        let changeHistory = [];

        let cellsBeingEditedViaEventModal = [];
        let isSingleCellEditViaModal = false;

        let selectedCells = []; // Stores {tdElement, employee, month, day, rowIndex, colIndex}
        let lastSelectedCellInfo = null; // For Shift+Click logic

        // Variables for drag selection (mouse and touch)
        let isDraggingToSelect = false;
        let dragSelectionStartCellInfo = null; // Cell where drag started
        let lastCellOverForDragSelectInfo = null; // Optimization for mousemove/touchmove
        let cellsAffectedByCurrentDrag = new Set(); // Stores tdElements affected by the CURRENT drag gesture

        // Variables for touch interaction
        let touchstartTime = 0;
        let touchstartTarget = null; // The TD element where touchstart occurred
        let longPressTimer = null;
        let touchstartX = 0, touchstartY = 0; // Initial touch coordinates
        let wasLongPress = false; // Flag to distinguish long press from tap/drag

        let draggedRow = null; // For employee row reordering
        let currentFilenameConfirmCallback = null;
        let currentFilenameExtension = '';
        let footerHeartClicks = 0;
        let comparativeStatsSortConfig = { column: null, direction: 'asc' };
        let lastSelectedEmployeeStatsRow = null;
        let notesDebounceTimer;

        const domCache = {};

        // --- UNDO/REDO FUNCTIONS ---
        function getAppStateSnapshot() {
            return {
                scheduleData: JSON.parse(JSON.stringify(scheduleData)),
                employeeNamesOrdered: JSON.parse(JSON.stringify(employeeNamesOrdered)),
                currentShiftColors: JSON.parse(JSON.stringify(currentShiftColors)),
                currentUserShiftTimes: JSON.parse(JSON.stringify(currentUserShiftTimes)),
                generalNotes: domCache.generalNotesTextarea.value,
                yearOfSchedule: yearOfSchedule,
                currentSelectedMonth: currentSelectedMonth,
                currentViewMode: currentViewMode
            };
        }

        function restoreAppState(snapshot) {
            scheduleData = snapshot.scheduleData;
            employeeNamesOrdered = snapshot.employeeNamesOrdered;
            currentShiftColors = snapshot.currentShiftColors;
            currentUserShiftTimes = snapshot.currentUserShiftTimes;
            domCache.generalNotesTextarea.value = snapshot.generalNotes;
            yearOfSchedule = snapshot.yearOfSchedule;
            domCache.yearInput.value = yearOfSchedule;
            currentSelectedMonth = snapshot.currentSelectedMonth;
            currentViewMode = snapshot.currentViewMode;

            updateLegend();
            handleViewChange(); // This will re-render the table
            if (isDataLoadedForStats()) {
                calculateAndRenderComparativeStats();
            } else {
                updateStatsDisplayForNoData();
            }
            populateMonthTabs();
            updateViewModeUI();
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState();
        }

        function saveStateForUndo(descriptionForHistory) {
            if (undoStack.length >= MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            undoStack.push(getAppStateSnapshot());
            redoStack = []; // Clear redo stack on new action
            addChangeToHistory(descriptionForHistory);
            hasUnsavedChanges = true;
            updateUnsavedChangesIndicator();
            if (domCache.saveLocalButton) domCache.saveLocalButton.disabled = !isDataLoadedForSave();
            updateUndoRedoButtonsState();
        }

        function undoChange() {
            if (undoStack.length === 0) return;
            redoStack.push(getAppStateSnapshot()); // Save current state for redo
            if (redoStack.length > MAX_UNDO_STACK_SIZE) {
                redoStack.shift();
            }
            const previousState = undoStack.pop();
            restoreAppState(previousState);
            showToast('Acción deshecha.', 'info');
            addChangeToHistory("Acción deshecha."); // Log undo action
            updateUndoRedoButtonsState();
        }

        function redoChange() {
            if (redoStack.length === 0) return;
            undoStack.push(getAppStateSnapshot()); // Save current state for undo
            if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            const nextState = redoStack.pop();
            restoreAppState(nextState);
            showToast('Acción rehecha.', 'info');
            addChangeToHistory("Acción rehecha."); // Log redo action
            updateUndoRedoButtonsState();
        }

        function updateUndoRedoButtonsState() {
            if (domCache.undoButton) {
                domCache.undoButton.disabled = undoStack.length === 0;
            }
            if (domCache.redoButton) {
                domCache.redoButton.disabled = redoStack.length === 0;
            }
        }

        // --- UTILITY FUNCTIONS ---
        function createElement(tag, options = {}, children = []) {
            const element = document.createElement(tag);
            if (options.className) element.className = options.className;
            if (options.id) element.id = options.id;
            if (options.textContent) element.textContent = options.textContent;
            if (options.innerHTML) element.innerHTML = options.innerHTML;
            if (options.title) element.title = options.title;
            if (options.dataset) {
                for (const key in options.dataset) {
                    element.dataset[key] = options.dataset[key];
                }
            }
            if (options.style) {
                for (const prop in options.style) {
                    element.style[prop] = options.style[prop];
                }
            }
            if (options.attributes) {
                for (const attr in options.attributes) {
                    element.setAttribute(attr, options.attributes[attr]);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    element.appendChild(child);
                }
            });
            return element;
        }

        function updateUnsavedChangesIndicator() {
            if (domCache.unsavedIndicatorTable) {
                domCache.unsavedIndicatorTable.classList.toggle('hidden-by-default', !hasUnsavedChanges);
            }
        }

        function lightenDarkenColor(col, amt) {
            let usePound = false;
            if (col[0] == "#") {
                col = col.slice(1);
                usePound = true;
            }
            let num = parseInt(col, 16);
            if (isNaN(num)) return usePound ? "#FFFFFF" : "FFFFFF"; // Fallback
            let r = (num >> 16) + amt;
            if (r > 255) r = 255; else if (r < 0) r = 0;
            let b = ((num >> 8) & 0x00FF) + amt;
            if (b > 255) b = 255; else if (b < 0) b = 0;
            let g = (num & 0x0000FF) + amt;
            if (g > 255) g = 255; else if (g < 0) g = 0;
            let hex = (g | (b << 8) | (r << 16)).toString(16);
            while(hex.length < 6) hex = '0' + hex; // Pad with leading zeros
            return (usePound ? "#" : "") + hex;
        }


        // --- DOM CACHING ---
        function cacheDOMElements() {
            domCache.mainTitleText = document.getElementById('main-title-text');
            domCache.logoContainer = document.getElementById('logo-container');
            domCache.unsavedIndicatorTable = document.getElementById('unsaved-indicator-table');
            domCache.toastContainer = document.getElementById('toast-container');
            domCache.footerTextElement = document.getElementById('footer-text');
            domCache.creatorNameElement = document.getElementById('creator-name');
            domCache.footerHeartElement = document.getElementById('footer-heart');
            domCache.csvFileInput = document.getElementById('csv-file-input');
            domCache.yearInput = document.getElementById('year-input');
            domCache.saveLocalButton = document.getElementById('save-local-button');
            domCache.exportCsvButton = document.getElementById('export-csv-button');
            domCache.createEmptyCsvButton = document.getElementById('create-empty-csv-button');
            domCache.downloadImageButton = document.getElementById('download-image-button');
            domCache.downloadWeeklySvgButton = document.getElementById('download-weekly-svg-button');
            domCache.exportMonthCalendarButton = document.getElementById('export-month-calendar-button');
            domCache.viewMonthlyButton = document.getElementById('view-monthly-button');
            domCache.viewAnnualButton = document.getElementById('view-annual-button');
            domCache.viewModeButtonsContainer = document.getElementById('view-mode-buttons-container');
            domCache.welcomeMessage = document.getElementById('welcome-message');
            domCache.scheduleDisplaySection = document.getElementById('schedule-display-section');
            domCache.monthTabsContainer = document.getElementById('month-tabs-container');
            domCache.scheduleTableSection = document.getElementById('schedule-table-section');
            domCache.currentMonthYearDisplay = document.getElementById('current-month-year-display');
            domCache.currentMonthYearText = document.getElementById('current-month-year-text');
            domCache.scheduleTableHead = document.getElementById('schedule-table-head');
            domCache.scheduleTableBody = document.getElementById('schedule-table-body');
            domCache.noDataMessage = document.getElementById('no-data-message');
            domCache.multiselectToolbar = document.getElementById('multiselect-toolbar');
            domCache.legendItemsContainer = document.getElementById('legend-items-container');
            domCache.applyColorsButton = document.getElementById('apply-colors-button');
            domCache.resetColorsButton = document.getElementById('reset-colors-button');
            domCache.colorPalettePopupContainer = document.getElementById('color-palette-popup-container');
            domCache.statsPeriodFilterNew = document.getElementById('stats-period-filter-new');
            domCache.calculateStatsButtonNew = document.getElementById('calculate-stats-button-new');
            domCache.comparativeStatsTableContainer = document.getElementById('comparative-stats-table-container');
            domCache.statsPlaceholder = document.getElementById('stats-placeholder');
            domCache.employeeShiftDistributionDetailContainer = document.getElementById('employee-shift-distribution-detail-container');
            domCache.employeeShiftDetailTitle = document.getElementById('employee-shift-detail-title');
            domCache.employeeNameForDetailChart = document.getElementById('employee-name-for-detail-chart');
            domCache.employeeShiftChart = document.getElementById('employee-shift-chart');
            domCache.changeHistoryList = document.getElementById('change-history-list');
            domCache.generalNotesTextarea = document.getElementById('general-notes');
            domCache.addEmployeeModal = document.getElementById('add-employee-modal');
            domCache.modalEmployeeNameInput = document.getElementById('modal-employee-name-input');
            domCache.modalConfirmAddEmployee = document.getElementById('modal-confirm-add-employee');
            domCache.modalCancelAddEmployee = document.getElementById('modal-cancel-add-employee');
            domCache.deleteEmployeeModal = document.getElementById('delete-employee-modal');
            domCache.employeeNameToDeleteSpan = document.getElementById('employee-name-to-delete');
            domCache.deleteCountdownMessageSpan = document.getElementById('delete-countdown-message');
            domCache.modalConfirmDeleteEmployee = document.getElementById('modal-confirm-delete-employee');
            domCache.modalCancelDeleteEmployee = document.getElementById('modal-cancel-delete-employee');
            domCache.filenameModal = document.getElementById('filename-modal');
            domCache.filenameModalTitle = document.getElementById('filename-modal-title');
            domCache.filenameModalDescription = document.getElementById('filename-modal-description');
            domCache.modalFilenameInput = document.getElementById('modal-filename-input');
            domCache.modalConfirmFilename = document.getElementById('modal-confirm-filename');
            domCache.modalCancelFilename = document.getElementById('modal-cancel-filename');
            domCache.exportCalendarModal = document.getElementById('export-calendar-modal');
            domCache.modalCalendarEmployeeSelect = document.getElementById('modal-calendar-employee-select');
            domCache.modalConfirmExportCalendar = document.getElementById('modal-confirm-export-calendar');
            domCache.modalCancelExportCalendar = document.getElementById('modal-cancel-export-calendar');
            domCache.helpIconContainer = document.getElementById('help-icon-container');
            domCache.tipsModal = document.getElementById('tips-modal');
            domCache.closeTipsModalButton = document.getElementById('close-tips-modal');
            domCache.okTipsModalButton = document.getElementById('ok-tips-modal');
            domCache.customEventModal = document.getElementById('custom-event-modal');
            domCache.customEventModalTitle = document.getElementById('custom-event-modal-title');
            domCache.modalCustomEventInput = document.getElementById('modal-custom-event-input');
            domCache.modalConfirmCustomEvent = document.getElementById('modal-confirm-custom-event');
            domCache.modalCancelCustomEvent = document.getElementById('modal-cancel-custom-event');
            domCache.undoButton = document.getElementById('undo-button');
            domCache.redoButton = document.getElementById('redo-button');
        }

        // --- EVENT HANDLERS ---
        // --- MOUSE SELECTION LOGIC ---
        function handleCellMouseDown(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;
            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            isDraggingToSelect = true;
            dragSelectionStartCellInfo = cellInfo;
            lastCellOverForDragSelectInfo = cellInfo;
            cellsAffectedByCurrentDrag = new Set();

            processCellClick(cellInfo, event.shiftKey, (event.ctrlKey || event.metaKey), false);

            // After initial click processing, mark all currently selected cells as affected by this drag
            selectedCells.forEach(sc => {
                cellsAffectedByCurrentDrag.add(sc.tdElement);
            });
            updateMultiselectToolbar();
        }

        function handleDocumentMouseMove(event) {
            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return;

            const currentTarget = event.target;
            const currentTd = currentTarget.closest('td.shift-cell');
            if (!currentTd) return; // Only proceed if over a valid shift cell

            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo) return;

            if (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement) {
                return; // Optimization: no change if still over the same cell
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            applyPaintDeselectLogic(dragSelectionStartCellInfo, currentCellInfo);
            updateMultiselectToolbar();
        }

        function handleDocumentMouseUp(event) {
            if (isDraggingToSelect) {
                isDraggingToSelect = false;
                // dragSelectionStartCellInfo, lastCellOverForDragSelectInfo, and cellsAffectedByCurrentDrag
                // will be reset on the next mousedown.
            }
        }

        // --- TOUCH SELECTION LOGIC ---
        function handleCellTouchStart(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;

            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            touchstartTarget = targetTd;
            touchstartTime = new Date().getTime();
            touchstartX = event.touches[0].clientX;
            touchstartY = event.touches[0].clientY;
            wasLongPress = false;

            isDraggingToSelect = true; // Assume drag might start
            dragSelectionStartCellInfo = cellInfo;
            lastCellOverForDragSelectInfo = cellInfo;
            cellsAffectedByCurrentDrag = new Set();

            // For touch, a simple tap (without moving much) will be handled in touchend.
            // If it's a long press, that's handled by the timer.
            // If it's a drag, mousemove (well, touchmove) will handle it.

            // Process initial selection state (e.g. if it was already selected, it's part of this drag)
            // Unlike mouse, Ctrl/Shift aren't typical. A tap on an unselected cell selects it.
            // A tap on a selected cell (if not dragging) might deselect it or do nothing, depending on desired UX.
            // For now, let's assume a tap is like a simple click.
            // The `processCellClick` function needs to be robust enough or we need a touch-specific one.
            // Let's defer the actual selection change to touchend if it's a tap,
            // or to touchmove if it's a drag.
            // However, we still need to populate cellsAffectedByCurrentDrag if it's already selected.
            if (selectedCells.some(sc => sc.tdElement === cellInfo.tdElement)) {
                 cellsAffectedByCurrentDrag.add(cellInfo.tdElement);
            }


            if (longPressTimer) clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if (isDraggingToSelect && (Math.abs(event.touches[0].clientX - touchstartX) > MAX_TOUCH_MOVE_THRESHOLD || Math.abs(event.touches[0].clientY - touchstartY) > MAX_TOUCH_MOVE_THRESHOLD) ) {
                     // If significant movement occurred, it's a drag, not a long press
                    longPressTimer = null;
                    return;
                }
                wasLongPress = true;
                const currentCellInfoOnTimeout = getCellInfoFromElement(touchstartTarget);
                if (currentCellInfoOnTimeout) {
                    const currentValue = scheduleData[currentCellInfoOnTimeout.employee]?.[currentCellInfoOnTimeout.month]?.[currentCellInfoOnTimeout.day] || "";
                    if (!SHIFT_TYPES.includes(currentValue)) {
                         event.preventDefault(); // Prevent context menu on long press if editing
                         editCellOnLongPress(currentCellInfoOnTimeout);
                    } else {
                        // If it's a standard shift, a long press could be a way to select/deselect
                        // similar to Ctrl+Click on desktop.
                        processCellClick(currentCellInfoOnTimeout, false, true, true); // Simulate Ctrl+Click for long press
                        updateMultiselectToolbar();
                    }
                }
                longPressTimer = null;
            }, LONG_PRESS_DURATION);
        }

        function handleDocumentTouchMove(event) {
            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return;

            // Check if touch has moved significantly to confirm drag
            const deltaX = Math.abs(event.touches[0].clientX - touchstartX);
            const deltaY = Math.abs(event.touches[0].clientY - touchstartY);

            if (deltaX > MAX_TOUCH_MOVE_THRESHOLD || deltaY > MAX_TOUCH_MOVE_THRESHOLD) {
                if (longPressTimer) { // If drag starts, cancel long press
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                event.preventDefault(); // Prevent scrolling while dragging to select
            } else {
                // If not moved enough, don't treat as drag selection yet
                return;
            }


            const currentTarget = document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY);
            const currentTd = currentTarget ? currentTarget.closest('td.shift-cell') : null;

            if (!currentTd) return;
            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo) return;

            if (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement) {
                return; // Optimization
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            // On first significant move, ensure the start cell is selected and marked as affected
            if (!cellsAffectedByCurrentDrag.has(dragSelectionStartCellInfo.tdElement) && !selectedCells.some(sc => sc.tdElement === dragSelectionStartCellInfo.tdElement)) {
                selectedCells.push(dragSelectionStartCellInfo);
                dragSelectionStartCellInfo.tdElement.classList.add('cell-selected');
                cellsAffectedByCurrentDrag.add(dragSelectionStartCellInfo.tdElement);
            }


            applyPaintDeselectLogic(dragSelectionStartCellInfo, currentCellInfo);
            updateMultiselectToolbar();
        }

        function handleDocumentTouchEnd(event) {
            const wasActuallyDragging = isDraggingToSelect &&
                                      (Math.abs(event.changedTouches[0].clientX - touchstartX) > MAX_TOUCH_MOVE_THRESHOLD ||
                                       Math.abs(event.changedTouches[0].clientY - touchstartY) > MAX_TOUCH_MOVE_THRESHOLD);

            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (!wasActuallyDragging && !wasLongPress && touchstartTarget) {
                const cellInfo = getCellInfoFromElement(touchstartTarget);
                if (cellInfo) {
                    // This is a TAP
                    processCellClick(cellInfo, false, false, true); // isTap = true
                    updateMultiselectToolbar();
                }
            }

            isDraggingToSelect = false;
            touchstartTarget = null;
            // dragSelectionStartCellInfo, lastCellOverForDragSelectInfo, and cellsAffectedByCurrentDrag
            // will be reset on the next touchstart.
        }

        // --- SHARED PAINT/DESELECT LOGIC for MOUSE and TOUCH ---
        function applyPaintDeselectLogic(startCell, currentCell) {
            const minRow = Math.min(startCell.rowIndex, currentCell.rowIndex);
            const maxRow = Math.max(startCell.rowIndex, currentCell.rowIndex);
            const minCol = Math.min(startCell.colIndex, currentCell.colIndex);
            const maxCol = Math.max(startCell.colIndex, currentCell.colIndex);

            const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');

            allCellsInTable.forEach(cellElement => {
                const cellIterInfo = getCellInfoFromElement(cellElement);
                if (!cellIterInfo) return;

                const isInCurrentRect = cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol;

                let isSelectedInGlobalList = selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement);

                if (isInCurrentRect) {
                    if (!isSelectedInGlobalList) {
                        selectedCells.push(cellIterInfo);
                        cellElement.classList.add('cell-selected');
                        cellsAffectedByCurrentDrag.add(cellElement); // Mark as affected by this drag
                    }
                } else { // Cell is OUTSIDE the current drag rectangle
                    if (isSelectedInGlobalList && cellsAffectedByCurrentDrag.has(cellElement)) {
                        // If it was selected AND its state was set by THIS drag, deselect it
                        const index = selectedCells.findIndex(sc => sc.tdElement === cellIterInfo.tdElement);
                        if (index > -1) {
                            selectedCells.splice(index, 1);
                        }
                        cellElement.classList.remove('cell-selected');
                        // No need to remove from cellsAffectedByCurrentDrag, it's reset on next mousedown/touchstart
                    }
                }
            });
        }


        function setupEventListeners() {
            domCache.csvFileInput.addEventListener('change', handleFileUpload);
            domCache.yearInput.addEventListener('change', handleYearChange);
            domCache.saveLocalButton.addEventListener('click', saveScheduleToLocalStorage);
            domCache.exportCsvButton.addEventListener('click', prepareExportScheduleToCSV);
            domCache.createEmptyCsvButton.addEventListener('click', createEmptyCSVTemplate);
            domCache.downloadImageButton.addEventListener('click', () => prepareDownloadSvgOrPdf('monthlyAnnual'));
            domCache.downloadWeeklySvgButton.addEventListener('click', () => prepareDownloadSvgOrPdf('weekly'));
            domCache.exportMonthCalendarButton.addEventListener('click', showExportToCalendarModal);
            domCache.viewMonthlyButton.addEventListener('click', () => switchViewMode('monthly'));
            domCache.viewAnnualButton.addEventListener('click', () => switchViewMode('annual'));

            // Table interaction
            domCache.scheduleTableBody.addEventListener('dblclick', handleTableDblClick);
            domCache.scheduleTableBody.addEventListener('dragstart', handleDragStart);
            domCache.scheduleTableBody.addEventListener('dragover', handleDragOver);
            domCache.scheduleTableBody.addEventListener('dragleave', handleDragLeave);
            domCache.scheduleTableBody.addEventListener('drop', handleDrop);
            domCache.scheduleTableBody.addEventListener('dragend', handleDragEnd);

            // Mouse selection events
            domCache.scheduleTableBody.addEventListener('mousedown', handleCellMouseDown);
            document.addEventListener('mousemove', handleDocumentMouseMove);
            document.addEventListener('mouseup', handleDocumentMouseUp);

            // Touch selection events
            domCache.scheduleTableBody.addEventListener('touchstart', handleCellTouchStart, { passive: false });
            document.addEventListener('touchmove', handleDocumentTouchMove, { passive: false });
            document.addEventListener('touchend', handleDocumentTouchEnd);


            domCache.scheduleTableBody.addEventListener('contextmenu', (event) => {
                // Prevent context menu if a long press was for editing
                if (event.target.closest('td.shift-cell') && wasLongPress) {
                    const cellInfo = getCellInfoFromElement(event.target.closest('td.shift-cell'));
                    if(cellInfo) {
                        const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                        if (!SHIFT_TYPES.includes(currentValue)) { // If it was custom text edit
                            event.preventDefault();
                        }
                    }
                }
            });

            // Legend and colors
            domCache.applyColorsButton.addEventListener('click', applyAndSaveColorsAndTimes);
            domCache.resetColorsButton.addEventListener('click', resetColorsAndTimes);

            // Notes
            domCache.generalNotesTextarea.addEventListener('input', () => {
                hasUnsavedChanges = true;
                updateUnsavedChangesIndicator();
                if (Object.keys(scheduleData).length > 0 || domCache.generalNotesTextarea.value.trim()) {
                    domCache.saveLocalButton.disabled = false;
                }
                clearTimeout(notesDebounceTimer);
                notesDebounceTimer = setTimeout(() => {
                    const lastUndoState = undoStack.length > 0 ? undoStack[undoStack.length - 1] : null;
                    if (!lastUndoState || lastUndoState.generalNotes !== domCache.generalNotesTextarea.value) {
                         saveStateForUndo("Notas generales modificadas.");
                    }
                }, 1500);
            });

            // Stats
            domCache.calculateStatsButtonNew.addEventListener('click', calculateAndRenderComparativeStats);
            domCache.statsPeriodFilterNew.addEventListener('change', () => {
                 domCache.calculateStatsButtonNew.disabled = !isDataLoadedForStats();
            });

            // Modals
            domCache.modalConfirmAddEmployee.addEventListener('click', handleAddEmployeeFromModal);
            domCache.modalCancelAddEmployee.addEventListener('click', () => hideModal(domCache.addEmployeeModal));
            domCache.addEmployeeModal.addEventListener('click', (event) => {
                if (event.target === domCache.addEmployeeModal) hideModal(domCache.addEmployeeModal);
            });

            domCache.modalConfirmDeleteEmployee.addEventListener('click', confirmEmployeeDeletion);
            domCache.modalCancelDeleteEmployee.addEventListener('click', () => hideModal(domCache.deleteEmployeeModal, () => {
                if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
            }));
            domCache.deleteEmployeeModal.addEventListener('click', (event) => {
                if (event.target === domCache.deleteEmployeeModal) hideModal(domCache.deleteEmployeeModal, () => {
                    if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
                });
            });

            domCache.modalConfirmFilename.addEventListener('click', handleFilenameConfirm);
            domCache.modalCancelFilename.addEventListener('click', () => hideModal(domCache.filenameModal, () => {
                currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
            }));
            domCache.filenameModal.addEventListener('click', (event) => {
                if (event.target === domCache.filenameModal) hideModal(domCache.filenameModal, () => {
                    currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
                });
            });

            domCache.modalConfirmExportCalendar.addEventListener('click', () => {
                const selectedEmployee = domCache.modalCalendarEmployeeSelect.value;
                if (selectedEmployee) exportToCalendar(selectedEmployee);
                else showToast('Por favor, selecciona un empleado para exportar.', 'error');
                hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';});
            });
            domCache.modalCancelExportCalendar.addEventListener('click', () => hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';}));
            domCache.exportCalendarModal.addEventListener('click', (event) => {
                if (event.target === domCache.exportCalendarModal) hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';});
            });

            // Footer heart
            if (domCache.footerHeartElement) {
                domCache.footerHeartElement.addEventListener('click', handleFooterHeartClick);
            }

            // Unsaved changes prompt
            window.addEventListener('beforeunload', (event) => {
                if (hasUnsavedChanges) { event.preventDefault(); event.returnValue = ''; }
            });

            // Click outside to clear selection or close palette
            document.addEventListener('mousedown', (event) => { // Use mousedown for palette to close before click on swatch
                if (activeColorPalette && !activeColorPalette.contains(event.target) &&
                    !event.target.closest('.legend-color-swatch')) {
                    closeColorPalette();
                }
                const isClickOnTableBody = event.target.closest('#schedule-table-body');
                const isClickOnToolbar = event.target.closest('#multiselect-toolbar');
                const isClickOnModalContent = event.target.closest('.modal-content'); // Check for modal content specifically
                const isClickOnLegendItem = event.target.closest('.legend-item-container');
                const isClickOnControls = event.target.closest('#controls-section');

                if (!isClickOnTableBody && !isClickOnToolbar && !isClickOnModalContent && !isClickOnLegendItem && !isClickOnControls && selectedCells.length > 0) {
                    clearSelection();
                }
            });


            // Undo/Redo buttons
            if (domCache.undoButton) {
                domCache.undoButton.addEventListener('click', undoChange);
            }
            if (domCache.redoButton) {
                domCache.redoButton.addEventListener('click', redoChange);
            }

            // Keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey || event.metaKey) {
                    if (event.key === 'z' || event.key === 'Z') {
                        event.preventDefault();
                        if (domCache.undoButton && !domCache.undoButton.disabled) undoChange();
                    } else if (event.key === 'y' || event.key === 'Y') {
                        event.preventDefault();
                        if (domCache.redoButton && !domCache.redoButton.disabled) redoChange();
                    }
                } else if (event.key === 'Escape') {
                    if (selectedCells.length > 0) clearSelection();
                    if (domCache.addEmployeeModal && !domCache.addEmployeeModal.classList.contains('hidden-by-default')) hideModal(domCache.addEmployeeModal);
                    if (domCache.deleteEmployeeModal && !domCache.deleteEmployeeModal.classList.contains('hidden-by-default')) hideModal(domCache.deleteEmployeeModal, () => { if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null; });
                    if (domCache.filenameModal && !domCache.filenameModal.classList.contains('hidden-by-default')) hideModal(domCache.filenameModal, () => { currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = ''; });
                    if (domCache.exportCalendarModal && !domCache.exportCalendarModal.classList.contains('hidden-by-default')) hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = ''; });
                    if (domCache.tipsModal && !domCache.tipsModal.classList.contains('hidden-by-default')) hideModal(domCache.tipsModal);
                    if (domCache.customEventModal && !domCache.customEventModal.classList.contains('hidden-by-default')) hideCustomEventModal();
                }
            });

            // Tips modal
            if (domCache.helpIconContainer) {
                domCache.helpIconContainer.addEventListener('click', () => {
                    showModal(domCache.tipsModal);
                });
            }
            if (domCache.closeTipsModalButton) {
                domCache.closeTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.okTipsModalButton) {
                domCache.okTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.tipsModal) {
                domCache.tipsModal.addEventListener('click', (event) => {
                    if (event.target === domCache.tipsModal) { // Click on backdrop
                        hideModal(domCache.tipsModal);
                    }
                });
            }

            // Custom event modal
            if (domCache.modalConfirmCustomEvent) {
                domCache.modalConfirmCustomEvent.addEventListener('click', handleConfirmCustomEvent);
            }
            if (domCache.modalCancelCustomEvent) {
                domCache.modalCancelCustomEvent.addEventListener('click', hideCustomEventModal);
            }
            if (domCache.customEventModal) {
                domCache.customEventModal.addEventListener('click', (event) => {
                    if (event.target === domCache.customEventModal) { // Click on backdrop
                        hideCustomEventModal();
                    }
                });
            }
        }

        // --- INITIALIZATION ---
        function populateStatsPeriodFilter() {
            domCache.statsPeriodFilterNew.innerHTML = ''; // Clear existing options
            domCache.statsPeriodFilterNew.appendChild(createElement('option', {textContent: 'Año Completo Seleccionado', attributes: {value: 'full_year'}}));
            MONTH_NAMES.forEach((monthName, index) => {
                domCache.statsPeriodFilterNew.appendChild(createElement('option', {textContent: monthName, attributes: {value: (index + 1).toString() }}));
            });
        }


        document.addEventListener('DOMContentLoaded', () => {
            cacheDOMElements();
            if (domCache.logoContainer) {
                domCache.logoContainer.innerHTML = SVG_FINAL_LOGO_MARKUP;
            }
            setupEventListeners();
            populateStatsPeriodFilter();
            loadYearFromLocalStorage();
            loadCustomColors();
            loadCustomShiftTimes();
            updateLegend();
            loadChangeHistory(); // Load before rendering
            renderChangeHistory(); // Then render
            setupMultiselectToolbar();
            updateMultiselectToolbar(); // Initial state

            const dataLoaded = loadDataFromLocalStorage(); // This will also handle undo/redo stack reset
            if (dataLoaded) {
                handleViewChange(); // Render table based on loaded view
                calculateAndRenderComparativeStats();
            } else {
                enableControls(false); // Disable controls if no data
                renderAddEmployeeButtonInTable(); // Show add employee button even if no data
                updateStatsDisplayForNoData();
            }
            updateViewModeUI(); // Set correct active button for view mode
            updateCalendarExportButtonsState();
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState(); // Set initial state of undo/redo buttons
        });

        // --- MODAL FUNCTIONS ---
        function showModal(modalElement, elementToFocus = null) {
            if (!modalElement) return;
            modalElement.classList.remove('hidden-by-default');
            if (elementToFocus) {
                elementToFocus.focus();
                if (typeof elementToFocus.select === 'function') elementToFocus.select();
            }
        }

        function hideModal(modalElement, cleanupFunction = null) {
            if (!modalElement) return;
            modalElement.classList.add('hidden-by-default');
            if (typeof cleanupFunction === 'function') cleanupFunction();
        }

        function showCustomEventModal(title, initialText = "") {
            if (!domCache.customEventModal || !domCache.customEventModalTitle || !domCache.modalCustomEventInput) {
                console.error("Error: Elementos de la modal de evento personalizado no encontrados en domCache.");
                return;
            }
            domCache.customEventModalTitle.textContent = title;
            domCache.modalCustomEventInput.value = initialText;
            showModal(domCache.customEventModal, domCache.modalCustomEventInput);
        }

        function hideCustomEventModal() {
            if (!domCache.customEventModal) {
                console.error("Error: Modal de evento personalizado no encontrada en domCache.");
                return;
            }
            hideModal(domCache.customEventModal);
            cellsBeingEditedViaEventModal = []; // Clear the cells being edited
            isSingleCellEditViaModal = false;
            if (domCache.modalCustomEventInput) {
                domCache.modalCustomEventInput.value = ""; // Clear input
            }
        }

        function handleConfirmCustomEvent() {
            if (!domCache.modalCustomEventInput) {
                console.error("Error: Input de la modal de evento personalizado no encontrado.");
                return;
            }
            const newText = domCache.modalCustomEventInput.value.trim();

            // VALIDACIÓN DE COMA
            if (newText.includes(',')) {
                showToast('El texto del evento no puede contener comas (,).', 'error');
                if (domCache.modalCustomEventInput) {
                    domCache.modalCustomEventInput.focus(); // Re-focus for correction
                }
                return; // Stop processing
            }

            let changesMadeCount = 0;
            let undoDescription = `Modificación de ${cellsBeingEditedViaEventModal.length} celda(s) a '${newText === "" ? "Vacío" : newText}'.`;

            if (cellsBeingEditedViaEventModal.length === 1) {
                const cellToEdit = cellsBeingEditedViaEventModal[0];
                const originalVal = cellToEdit.originalValue; // Use the stored original value
                undoDescription = `Evento de ${cellToEdit.employee} (${cellToEdit.day}/${SHORT_MONTH_NAMES[cellToEdit.month-1]}) cambiado de '${originalVal || "Vacío"}' a '${newText || "Vacío"}'.`;
            }
            // Only save state for undo if there's an actual change
            if (cellsBeingEditedViaEventModal.some(cell => cell.originalValue !== newText)) {
                saveStateForUndo(undoDescription);
            }

            cellsBeingEditedViaEventModal.forEach((cellToEdit, index) => {
                const { tdElement, employee, month, day, originalValue } = cellToEdit;
                if (originalValue !== newText) { // Process only if there's a change
                    if (!scheduleData[employee]) scheduleData[employee] = {};
                    if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
                    scheduleData[employee][month][day] = newText;
                    tdElement.textContent = newText;
                    applyShiftCellStyles(tdElement, newText); // Apply styles for "empty" or custom text
                    changesMadeCount++;
                }
            });

            if (changesMadeCount > 0) {
                // Only re-calculate stats if data actually changed
                if (isDataLoadedForStats()) {
                    calculateAndRenderComparativeStats();
                }
            }
            hideCustomEventModal(); // Hide modal after processing
            if (isSingleCellEditViaModal) { // If it was a single cell edit (like dblclick)
                clearSelection(); // Clear selection as the modal was for one cell
            }
        }


        // --- FOOTER ---
        function handleFooterHeartClick() {
            footerHeartClicks++;
            if (footerHeartClicks === 10) {
                if (domCache.creatorNameElement) {
                    domCache.creatorNameElement.classList.add('hidden-name');
                    setTimeout(() => {
                        domCache.creatorNameElement.textContent = 'Scrulius';
                        domCache.creatorNameElement.classList.remove('hidden-name');
                        domCache.creatorNameElement.classList.add('visible-name');
                        showToast('✨ ¡Easter egg activado! ✨', 'success');
                    }, 500);
                }
            }
        }

        // --- YEAR HANDLING ---
        function loadYearFromLocalStorage() {
            const savedYear = localStorage.getItem(LOCAL_STORAGE_KEY_YEAR);
            if (savedYear && !isNaN(parseInt(savedYear))) {
                yearOfSchedule = parseInt(savedYear);
            } else {
                yearOfSchedule = new Date().getFullYear(); // Default to current year
            }
            domCache.yearInput.value = yearOfSchedule;
        }

        function handleYearChange(event) {
            const newYear = parseInt(event.target.value);
            if (!isNaN(newYear) && newYear > 1900 && newYear < 2200 && newYear !== yearOfSchedule) {
                saveStateForUndo(`Año del horario cambiado de ${yearOfSchedule} a ${newYear}.`);
                yearOfSchedule = newYear;
                if (isDataLoadedForStats()) {
                    handleViewChange(); // Re-render table for new year
                    domCache.calculateStatsButtonNew.disabled = !isDataLoadedForStats(); // Re-evaluate button state
                }
                showToast(`Año del horario actualizado a ${yearOfSchedule}.`, 'info');
            } else if (newYear === yearOfSchedule) {
                // No change, do nothing
            }
            else {
                event.target.value = yearOfSchedule; // Revert to old year if invalid
                showToast('Por favor, introduce un año válido (ej. 2024).', 'error');
            }
        }

        // --- CHANGE HISTORY ---
        function addChangeToHistory(description) {
            const newChange = { timestamp: new Date(), description: description };
            changeHistory.unshift(newChange); // Add to the beginning
            if (changeHistory.length > MAX_HISTORY_ITEMS) changeHistory.pop(); // Limit size
            renderChangeHistory();
        }


        function renderChangeHistory() {
            domCache.changeHistoryList.innerHTML = ''; // Clear existing
            if (changeHistory.length === 0) {
                domCache.changeHistoryList.appendChild(createElement('li', {
                    textContent: 'No hay cambios recientes.', className: 'text-center text-gray-400'
                }));
                return;
            }
            changeHistory.forEach(change => {
                const timeSpan = createElement('span', {
                    className: 'history-time', textContent: `[${new Date(change.timestamp).toLocaleTimeString('es-ES')}]`
                });
                domCache.changeHistoryList.appendChild(createElement('li', {}, [ timeSpan, ` ${change.description}` ]));
            });
        }

        function loadChangeHistory() {
            const savedHistory = localStorage.getItem(LOCAL_STORAGE_KEY_HISTORY);
            if (savedHistory) {
                try {
                    changeHistory = JSON.parse(savedHistory).map(item => ({
                        ...item, timestamp: new Date(item.timestamp) // Ensure timestamps are Date objects
                    }));
                } catch (e) { console.error("Error al cargar historial:", e); changeHistory = []; }
            }
        }

        // --- COLORS AND LEGEND ---
        function loadCustomColors() {
            const savedColors = localStorage.getItem(LOCAL_STORAGE_KEY_COLORS);
            if (savedColors) {
                try {
                    const parsedColors = JSON.parse(savedColors);
                    // Basic validation
                    let valid = true;
                    const keysToValidate = [...SHIFT_TYPES, 'empty'];
                    keysToValidate.forEach(type => {
                        if (!parsedColors[type] || !parsedColors[type].bg || !parsedColors[type].text || !parsedColors[type].hexBg || !parsedColors[type].hexText) {
                            valid = false;
                        }
                    });

                    if (valid) currentShiftColors = parsedColors;
                    else throw new Error("Formato de colores guardados inválido.");

                } catch (e) {
                    console.error("Error al cargar colores, usando por defecto.", e);
                    currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS)); // Deep copy
                    localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS); // Remove corrupted data
                }
            } else {
                 currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS)); // Deep copy for new users
            }
            // Ensure hex values exist, fallback if not (e.g. from older versions)
            Object.keys(currentShiftColors).forEach(key => {
                if (!currentShiftColors[key].hexBg || !currentShiftColors[key].hexText) {
                    const defaultColorForKey = DEFAULT_SHIFT_COLORS[key] || DEFAULT_SHIFT_COLORS.empty;
                    const foundColor = AVAILABLE_COLORS.find(c => c.bg === currentShiftColors[key].bg) ||
                                     AVAILABLE_COLORS.find(c => c.bg === defaultColorForKey.bg) ||
                                     AVAILABLE_COLORS[0]; // Absolute fallback
                    currentShiftColors[key].hexBg = foundColor.hexBg || '#ffffff';
                    currentShiftColors[key].hexText = foundColor.hexText || '#000000';
                }
            });
        }

        function loadCustomShiftTimes() {
            const savedTimes = localStorage.getItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
            if (savedTimes) {
                try {
                    const parsedTimes = JSON.parse(savedTimes);
                    // Basic validation for structure
                    let valid = true;
                    Object.keys(DEFAULT_SHIFT_TIMES).forEach(type => {
                        if (!parsedTimes[type] || !Array.isArray(parsedTimes[type].start) || parsedTimes[type].start.length !== 2 ||
                            !Array.isArray(parsedTimes[type].end) || parsedTimes[type].end.length !== 2 ||
                            typeof parsedTimes[type].nextDayEnd !== 'boolean') {
                            valid = false;
                        }
                    });
                    if (valid) currentUserShiftTimes = parsedTimes;
                    else throw new Error("Formato de horarios de turno inválido.");
                } catch (e) {
                    console.error("Error al cargar horarios de turno, usando por defecto.", e);
                    currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
                    localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
                }
            } else {
                currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            }
        }

        function applyAndSaveColorsAndTimes() {
            saveStateForUndo("Colores/horarios de leyenda actualizados.");

            localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, JSON.stringify(currentShiftColors));
            // Save times from inputs
            const timeInputs = domCache.legendItemsContainer.querySelectorAll('.legend-time-inputs input[type="time"]');
            timeInputs.forEach(input => {
                const shiftType = input.dataset.shiftType;
                const timeType = input.dataset.timeType; // 'start' or 'end'
                const [hours, minutes] = input.value.split(':').map(Number);

                if (currentUserShiftTimes[shiftType] && currentUserShiftTimes[shiftType][timeType]) {
                    currentUserShiftTimes[shiftType][timeType] = [hours, minutes];
                    // Special handling for N (Noche) shift nextDayEnd logic
                    if (shiftType === 'N' && timeType === 'end') {
                        const startHours = currentUserShiftTimes.N.start[0];
                        currentUserShiftTimes.N.nextDayEnd = hours < startHours;
                    } else if (currentUserShiftTimes[shiftType].hasOwnProperty('nextDayEnd')) {
                         currentUserShiftTimes[shiftType].nextDayEnd = false; // For M, T, ensure it's false
                    }
                }
            });
            localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, JSON.stringify(currentUserShiftTimes));

            // Visual feedback
            const legendItems = domCache.legendItemsContainer.querySelectorAll('.legend-item-container');
            legendItems.forEach(item => {
                item.classList.add('legend-item-flash');
                setTimeout(() => item.classList.remove('legend-item-flash'), 700);
            });

            updateLegend(); // Re-render legend with new times
            handleViewChange(); // Re-render table with new colors
            if (isDataLoadedForStats()) calculateAndRenderComparativeStats(); // Recalculate stats if needed
            showToast('Colores y horarios de turno aplicados y guardados.', 'success');
            domCache.applyColorsButton.disabled = true; // Disable until further changes
            domCache.resetColorsButton.disabled = false; // Enable reset
        }

        function resetColorsAndTimes() {
            saveStateForUndo("Colores/horarios de leyenda restaurados.");

            currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS);
            localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
            updateLegend();
            handleViewChange();
            if (isDataLoadedForStats()) calculateAndRenderComparativeStats();
            showToast('Colores y horarios de turno restaurados a los valores por defecto.', 'info');
            domCache.applyColorsButton.disabled = false; // Enable apply if user changes again
            domCache.resetColorsButton.disabled = true; // Reset is now done
        }


        function formatTimeForInput(hours, minutes) {
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function updateLegend() {
            domCache.legendItemsContainer.innerHTML = '';
            const relevantShiftTypesForTimeInput = ['M', 'T', 'N']; // Only these have time inputs

            [...SHIFT_TYPES, 'empty'].forEach(type => {
                const colorInfo = currentShiftColors[type];
                const legendItemDiv = createElement('div', { className: 'legend-item-container' });

                const swatch = createElement('span', {
                    className: `legend-color-swatch ${colorInfo.bg}`, // Apply current color
                    dataset: { shiftType: type },
                    title: `Cambiar color para ${type === 'empty' ? 'Otro' : SHIFT_TYPE_FULL_NAMES[type]}`
                });
                swatch.addEventListener('click', (event) => openColorPalette(event, type));

                const labelText = type === 'empty' ? 'Otro' : `${SHIFT_TYPE_FULL_NAMES[type]} (${type})`;
                const label = createElement('span', { textContent: labelText, className: 'mr-2' });

                legendItemDiv.appendChild(swatch);
                legendItemDiv.appendChild(label);

                // Add time inputs for M, T, N
                if (relevantShiftTypesForTimeInput.includes(type)) {
                    const timeConfig = currentUserShiftTimes[type] || DEFAULT_SHIFT_TIMES[type]; // Fallback just in case
                    const timeInputsDiv = createElement('div', { className: 'legend-time-inputs' });

                    const startTimeInput = createElement('input', {
                        attributes: { type: 'time', value: formatTimeForInput(timeConfig.start[0], timeConfig.start[1])},
                        dataset: { shiftType: type, timeType: 'start' }
                    });
                    const endTimeInput = createElement('input', {
                        attributes: { type: 'time', value: formatTimeForInput(timeConfig.end[0], timeConfig.end[1])},
                        dataset: { shiftType: type, timeType: 'end' }
                    });

                    startTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);
                    endTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);

                    timeInputsDiv.appendChild(startTimeInput);
                    timeInputsDiv.appendChild(createElement('span', {textContent: '-', className: 'mx-1'}));
                    timeInputsDiv.appendChild(endTimeInput);
                    legendItemDiv.appendChild(timeInputsDiv);
                }
                domCache.legendItemsContainer.appendChild(legendItemDiv);
            });
        }

        function handleShiftTimeChangeInLegend(event) {
            // Enable Apply and Reset buttons when time is changed
            domCache.applyColorsButton.disabled = false;
            domCache.resetColorsButton.disabled = false;
        }


        function openColorPalette(event, shiftTypeToEdit) {
            event.stopPropagation(); // Prevent body click from closing it immediately
            closeColorPalette(); // Close any existing palette

            const swatchElement = event.target;
            const swatchRect = swatchElement.getBoundingClientRect();

            activeColorPalette = createElement('div', { className: 'color-palette-popup' });
            document.body.appendChild(activeColorPalette); // Append to body for positioning

            AVAILABLE_COLORS.forEach((colorOption) => {
                const paletteSwatch = createElement('div', {
                    className: `palette-color-swatch ${colorOption.bg}`,
                    title: colorOption.name
                });
                paletteSwatch.addEventListener('click', () => {
                    currentShiftColors[shiftTypeToEdit] = {
                        bg: colorOption.bg,
                        text: colorOption.text,
                        name: colorOption.name, // Store name for reference if needed
                        hexBg: colorOption.hexBg || tailwindColorToHex(colorOption.bg), // Ensure hex is stored
                        hexText: colorOption.hexText || tailwindColorToHex(colorOption.text, true)
                    };
                    swatchElement.className = `legend-color-swatch ${colorOption.bg}`; // Update legend swatch
                    closeColorPalette();
                    domCache.applyColorsButton.disabled = false; // Enable apply button
                    domCache.resetColorsButton.disabled = false;
                });
                activeColorPalette.appendChild(paletteSwatch);
            });

            // Position the palette
            let top = swatchRect.bottom + window.scrollY + 5;
            let left = swatchRect.left + window.scrollX;
            const paletteRect = activeColorPalette.getBoundingClientRect(); // Get dimensions after filling

            // Adjust if it overflows viewport
            if (left + paletteRect.width > window.innerWidth) {
                left = window.innerWidth - paletteRect.width - 10; // 10px buffer
            }
            if (top + paletteRect.height > window.innerHeight) {
                top = swatchRect.top + window.scrollY - paletteRect.height - 5; // Position above
            }
            activeColorPalette.style.top = `${Math.max(0,top)}px`; // Ensure not off-screen top
            activeColorPalette.style.left = `${Math.max(0,left)}px`; // Ensure not off-screen left
        }

        function closeColorPalette() {
            if (activeColorPalette) {
                activeColorPalette.remove();
                activeColorPalette = null;
            }
        }

        // Helper to get hex for SVG if not directly available (simplified)
        function tailwindColorToHex(twClass, isTextClass = false) {
            // This is a simplified lookup. For a robust solution, you'd need a full Tailwind color map.
            const foundInAvailable = AVAILABLE_COLORS.find(c => c.bg === twClass || c.text === twClass);
            if (foundInAvailable) {
                return isTextClass ? (foundInAvailable.hexText || '#000000') : (foundInAvailable.hexBg || '#ffffff');
            }
            // Basic fallbacks
            if (twClass === 'bg-white') return '#ffffff';
            if (twClass === 'text-black') return '#000000';
            // Default fallback if color not in our limited list
            return isTextClass ? '#000000' : '#ffffff';
        }

        // --- TOAST NOTIFICATIONS ---
        function showToast(message, type = 'info', duration = 3500) {
            let iconClass = 'fas fa-info-circle', bgColorClass = 'bg-blue-500';
            if (type === 'success') { bgColorClass = 'bg-green-500'; iconClass = 'fas fa-check-circle'; }
            else if (type === 'error') { bgColorClass = 'bg-red-500'; iconClass = 'fas fa-times-circle'; }
            else if (type === 'warning') { bgColorClass = 'bg-yellow-500'; iconClass = 'fas fa-exclamation-triangle'; }

            const toast = createElement('div', {
                className: `flex items-center p-4 rounded-lg shadow-xl text-sm text-white ${bgColorClass} transition-opacity duration-300 opacity-0`,
                innerHTML: `<i class="${iconClass} mr-3 text-xl"></i><span>${message}</span>`
            });
            domCache.toastContainer.appendChild(toast);
            setTimeout(() => toast.classList.remove('opacity-0'), 50); // Fade in
            setTimeout(() => {
                toast.classList.add('opacity-0'); // Fade out
                setTimeout(() => toast.remove(), 500); // Remove from DOM after fade
            }, duration);
        }

        // --- UI CONTROL ENABLE/DISABLE ---
        function enableControls(dataLoaded = true) {
            const disable = !dataLoaded;
            domCache.exportCsvButton.disabled = disable;
            domCache.downloadImageButton.disabled = disable;
            domCache.calculateStatsButtonNew.disabled = disable;
            domCache.statsPeriodFilterNew.disabled = disable;

            if (domCache.viewModeButtonsContainer) {
                domCache.viewModeButtonsContainer.classList.toggle('hidden-by-default', !dataLoaded);
            }
            domCache.viewMonthlyButton.disabled = disable;
            domCache.viewAnnualButton.disabled = disable;
            domCache.saveLocalButton.disabled = !dataLoaded || !hasUnsavedChanges; // Also depends on unsaved changes

            updateCalendarExportButtonsState(); // This handles its own logic based on view and data

            if (dataLoaded) {
                domCache.welcomeMessage.classList.add('hidden-by-default');
                domCache.scheduleDisplaySection.classList.remove('hidden-by-default');
                domCache.noDataMessage.classList.add('hidden-by-default');
                domCache.monthTabsContainer.style.display = currentViewMode === 'monthly' ? 'flex' : 'none';
                domCache.statsPlaceholder.classList.add('hidden-by-default');
                domCache.comparativeStatsTableContainer.classList.remove('hidden-by-default');
            } else {
                domCache.welcomeMessage.classList.remove('hidden-by-default');
                domCache.scheduleDisplaySection.classList.add('hidden-by-default');
                domCache.noDataMessage.classList.remove('hidden-by-default');
                domCache.monthTabsContainer.style.display = 'none';
                if (domCache.viewModeButtonsContainer) {
                    domCache.viewModeButtonsContainer.classList.add('hidden-by-default');
                }
                updateStatsDisplayForNoData();
            }
        }

        function updateStatsDisplayForNoData() {
            if (domCache.statsPlaceholder && domCache.comparativeStatsTableContainer) {
                domCache.statsPlaceholder.classList.remove('hidden-by-default');
                domCache.comparativeStatsTableContainer.classList.add('hidden-by-default');
                domCache.comparativeStatsTableContainer.innerHTML = ''; // Clear any old table
                 domCache.employeeShiftDistributionDetailContainer.classList.add('hidden-by-default');
            }
             if (domCache.calculateStatsButtonNew) domCache.calculateStatsButtonNew.disabled = true;
             if (domCache.statsPeriodFilterNew) domCache.statsPeriodFilterNew.disabled = true;
        }

        function isDataLoadedForSave() {
            return Object.keys(scheduleData).length > 0 || employeeNamesOrdered.length > 0 || domCache.generalNotesTextarea.value.trim();
        }
        function isDataLoadedForStats() {
            // Requires both schedule data and some employees
            return Object.keys(scheduleData).length > 0 && employeeNamesOrdered.length > 0;
        }

        // --- FILENAME GENERATION ---
        function generateDefaultFilename(context, sourceFileName = null) {
            let baseName = "horario";
            const currentMonthNameSafe = MONTH_NAMES[currentSelectedMonth - 1].toLowerCase().replace(/\s+/g, '_');
            const year = yearOfSchedule;

            switch (context) {
                case 'csv':
                    if (sourceFileName) {
                        baseName = sourceFileName.substring(0, sourceFileName.lastIndexOf('.')) || "horario_importado";
                    } else if (isDataLoadedForStats()) {
                        baseName += `_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}`;
                    } else {
                        baseName += "_vacio";
                    }
                    break;
                case 'pdfWeekly': baseName += `_semanal_${currentMonthNameSafe}_${year}`; break;
                case 'pdfMonthly': baseName += `_mensual_${currentMonthNameSafe}_${year}`; break;
                case 'pdfAnnual': baseName += `_anual_${year}`; break;
                case 'calendar':
                    baseName += `_calendar_${sourceFileName ? sourceFileName.toLowerCase().replace(/\s+/g, '_') : 'empleado'}_${currentMonthNameSafe}_${year}`;
                    break;
                default: // Fallback, e.g., for general image download
                     if (isDataLoadedForStats()) {
                        baseName += `_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}`;
                    }
            }
            return baseName.replace(/[^a-z0-9_-]/gi, '_').replace(/_{2,}/g, '_'); // Sanitize
        }

        // --- CSV HANDLING ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csvContent = e.target.result;
                        parseCSV(csvContent); // Parse data first

                        if (isDataLoadedForStats()) { // Check if parsing resulted in usable data
                            if (domCache.csvFileInput.files[0]) { // Store original filename if available
                                domCache.csvFileInput.dataset.uploadedFileName = domCache.csvFileInput.files[0].name;
                            }
                            // Add to visual history AFTER parsing and validation
                            addChangeToHistory("Horario cargado desde CSV.");

                            // Clear undo/redo stacks to make this the new base state
                            undoStack = [];
                            redoStack = [];
                            updateUndoRedoButtonsState();

                            populateMonthTabs();
                            currentSelectedMonth = 1; // Default to January after new CSV load
                            hasUnsavedChanges = false; // Fresh load is considered "saved" for undo purposes
                            updateUnsavedChangesIndicator();
                            enableControls(true);
                            switchViewMode('monthly'); // Default to monthly view
                            calculateAndRenderComparativeStats(); // Calculate stats for new data
                            showToast('Horario cargado correctamente desde CSV.', 'success');
                        } else {
                            showToast('El CSV está vacío o no tiene el formato esperado.', 'error');
                            resetToInitialState(); // Reset if CSV is not valid
                        }
                    } catch (error) {
                        console.error("Error al procesar el CSV:", error);
                        showToast(`Error al procesar el CSV: ${error.message}`, 'error');
                        resetToInitialState();
                    }
                };
                reader.readAsText(file, 'UTF-8'); // Specify UTF-8 encoding
            }
        }

        function resetToInitialState(keepNotes = false) {
            addChangeToHistory("Aplicación reseteada al estado inicial."); // Optional: Log reset

            // Clear core data structures
            undoStack = []; redoStack = []; updateUndoRedoButtonsState();

            scheduleData = {}; employeeNamesOrdered = [];
            hasUnsavedChanges = false; updateUnsavedChangesIndicator();
            currentSelectedMonth = new Date().getMonth() + 1;
            yearOfSchedule = new Date().getFullYear();
            domCache.yearInput.value = yearOfSchedule;
            changeHistory = []; clearSelection(); // Clear visual history as well, or keep if preferred
            if (domCache.csvFileInput) domCache.csvFileInput.dataset.uploadedFileName = ''; // Clear uploaded filename

            // Update UI
            enableControls(false); // Disable most controls
            domCache.monthTabsContainer.innerHTML = '';
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes Año]';
            updateStatsDisplayForNoData();
            renderChangeHistory(); // Re-render to show "No hay cambios" or the reset message
            if (!keepNotes) domCache.generalNotesTextarea.value = '';

            // Reset configurations
            currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            updateLegend();

            // Clear local storage
            localStorage.removeItem(LOCAL_STORAGE_KEY_SCHEDULE);
            localStorage.removeItem(LOCAL_STORAGE_KEY_NOTES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_VIEW);
            localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS);
            localStorage.removeItem(LOCAL_STORAGE_KEY_HISTORY); // Clear saved history on reset
            localStorage.removeItem(LOCAL_STORAGE_KEY_YEAR);
            localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);

            renderAddEmployeeButtonInTable(); // Ensure add employee button is visible
            if (domCache.viewModeButtonsContainer) { // Hide view mode buttons
                domCache.viewModeButtonsContainer.classList.add('hidden-by-default');
            }
             domCache.employeeShiftDistributionDetailContainer.classList.add('hidden-by-default');
        }


        function parseCSV(csvText) {
            scheduleData = {}; employeeNamesOrdered = []; // Reset before parsing
            const uniqueEmployeeNames = new Set();
            const lines = csvText.trim().split(/\r\n|\n/); // Handle both CRLF and LF

            if (lines.length <= 1) return; // Header only or empty

            // Skip header (lines[0])
            for (let i = 1; i < lines.length; i++) {
                const cells = lines[i].split(','); // Simple split, assumes no commas within quoted fields initially
                if (cells.length < 3) continue; // Need at least Employee, Mes, and one day

                let employeeName = cells[0].trim();
                const month = parseInt(cells[1].trim(), 10);

                // Handle names enclosed in quotes (e.g., "Doe, John")
                if (employeeName.length >= 2 && employeeName.startsWith('"') && employeeName.endsWith('"')) {
                    employeeName = employeeName.substring(1, employeeName.length - 1).replace(/""/g, '"');
                }

                if (!employeeName || isNaN(month) || month < 1 || month > 12) continue;

                if (!scheduleData[employeeName]) {
                    scheduleData[employeeName] = {};
                    uniqueEmployeeNames.add(employeeName); // Add to set for ordered list
                }
                if (!scheduleData[employeeName][month]) {
                    scheduleData[employeeName][month] = {};
                }

                // Days start from cells[2] (index 2 for day 1, index 3 for day 2, etc.)
                for (let dayIndex = 1; dayIndex <= 31; dayIndex++) {
                    // cells[dayIndex + 1] because cells[0] is name, cells[1] is month
                    let cellValue = cells[dayIndex + 1] ? cells[dayIndex + 1].trim() : "";

                    // Handle cell values enclosed in quotes
                    if (cellValue.length >= 2 && cellValue.startsWith('"') && cellValue.endsWith('"')) {
                        cellValue = cellValue.substring(1, cellValue.length - 1).replace(/""/g, '"');
                    }
                    scheduleData[employeeName][month][dayIndex] = cellValue;
                }
            }
            employeeNamesOrdered = Array.from(uniqueEmployeeNames); // Create ordered list from unique names
        }

        // --- LOCAL STORAGE ---
        function saveScheduleToLocalStorage() {
            if (!isDataLoadedForSave()) {
                showToast('No hay datos para guardar.', 'error'); return;
            }
            try {
                const dataToSave = {
                    schedule: scheduleData,
                    employeeOrder: employeeNamesOrdered,
                    selectedMonth: currentSelectedMonth,
                    uploadedCsvName: domCache.csvFileInput && domCache.csvFileInput.dataset.uploadedFileName ? domCache.csvFileInput.dataset.uploadedFileName : null
                };
                localStorage.setItem(LOCAL_STORAGE_KEY_SCHEDULE, JSON.stringify(dataToSave));
                localStorage.setItem(LOCAL_STORAGE_KEY_NOTES, domCache.generalNotesTextarea.value);
                localStorage.setItem(LOCAL_STORAGE_KEY_VIEW, currentViewMode);
                localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, JSON.stringify(currentShiftColors));
                localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, JSON.stringify(currentUserShiftTimes));
                localStorage.setItem(LOCAL_STORAGE_KEY_HISTORY, JSON.stringify(changeHistory));
                localStorage.setItem(LOCAL_STORAGE_KEY_YEAR, yearOfSchedule.toString());

                // After saving, clear undo/redo as this is the new "saved" baseline
                undoStack = [];
                redoStack = [];
                updateUndoRedoButtonsState();

                hasUnsavedChanges = false; // Mark as saved
                updateUnsavedChangesIndicator();
                domCache.saveLocalButton.disabled = true; // Disable save button until new changes
                domCache.applyColorsButton.disabled = true; // Assume colors applied are now part of saved state
                domCache.resetColorsButton.disabled = true; // If saved, current state is the "default" for this session
                showToast('Datos guardados localmente.', 'success');
            } catch (error) {
                console.error("Error al guardar en localStorage:", error);
                showToast('Error al guardar. Espacio lleno o navegador no compatible.', 'error');
            }
        }

        function loadDataFromLocalStorage() {
            let dataLoadedSuccessfully = false;
            try {
                const savedDataString = localStorage.getItem(LOCAL_STORAGE_KEY_SCHEDULE);
                const savedNotes = localStorage.getItem(LOCAL_STORAGE_KEY_NOTES);
                const savedView = localStorage.getItem(LOCAL_STORAGE_KEY_VIEW);
                // Colors and times are loaded separately by their dedicated functions

                if (savedNotes) domCache.generalNotesTextarea.value = savedNotes;
                if (savedView) currentViewMode = savedView; // Load view preference

                if (savedDataString) {
                    const savedData = JSON.parse(savedDataString);
                    if (savedData && savedData.schedule && savedData.employeeOrder) {
                        scheduleData = savedData.schedule;
                        employeeNamesOrdered = savedData.employeeOrder;
                        currentSelectedMonth = savedData.selectedMonth || (new Date().getMonth() + 1); // Fallback for selectedMonth
                        if (domCache.csvFileInput && savedData.uploadedCsvName) {
                            domCache.csvFileInput.dataset.uploadedFileName = savedData.uploadedCsvName;
                        }

                        if (isDataLoadedForStats()) { // Check if the loaded data is substantial
                            dataLoadedSuccessfully = true; // Mark as successful before further operations
                            addChangeToHistory("Datos cargados desde almacenamiento local."); // Add to visual history

                            // Clear undo/redo stacks for new base state upon successful load
                            undoStack = [];
                            redoStack = [];
                            updateUndoRedoButtonsState();

                            populateMonthTabs();
                            hasUnsavedChanges = false; // Loaded state is considered "saved"
                            updateUnsavedChangesIndicator();
                            enableControls(true); // Enable UI controls
                            showToast('Datos cargados desde almacenamiento local.', 'success');
                        }
                    }
                }
            } catch (error) {
                console.error("Error al cargar desde localStorage:", error);
                showToast('Error al cargar datos locales. Podrían estar corruptos.', 'error');
                localStorage.removeItem(LOCAL_STORAGE_KEY_SCHEDULE); // Remove potentially corrupt data
                // Ensure stacks are cleared even on error if some partial load happened
                undoStack = []; redoStack = []; updateUndoRedoButtonsState();
            }

            if (!dataLoadedSuccessfully) { // If no valid data was loaded
                 enableControls(false);
                 renderAddEmployeeButtonInTable();
                 updateStatsDisplayForNoData();
                 // Ensure stacks are cleared if no data loaded
                 undoStack = []; redoStack = [];
            }
            updateUnsavedChangesIndicator(); // Reflect loaded state
            updateUndoRedoButtonsState(); // Reflect stack state
            return dataLoadedSuccessfully;
        }


        // --- EXPORT/DOWNLOAD FILENAME MODAL ---
        function showFilenameModal(title, description, defaultName, extension, confirmCallback) {
            domCache.filenameModalTitle.textContent = title;
            domCache.filenameModalDescription.textContent = description;
            domCache.modalFilenameInput.value = defaultName;
            currentFilenameConfirmCallback = confirmCallback;
            currentFilenameExtension = extension; // e.g., ".csv", ".pdf"
            showModal(domCache.filenameModal, domCache.modalFilenameInput);
        }

        function handleFilenameConfirm() {
            const filenameBase = domCache.modalFilenameInput.value.trim();
            if (!filenameBase) {
                showToast('Por favor, introduce un nombre para el archivo.', 'error');
                domCache.modalFilenameInput.focus(); return;
            }
            if (currentFilenameConfirmCallback) currentFilenameConfirmCallback(filenameBase);
            hideModal(domCache.filenameModal, () => { // Cleanup after confirm
                currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
            });
        }

        // --- CSV EXPORT AND TEMPLATE ---
        function prepareExportScheduleToCSV() {
            if (!isDataLoadedForStats()) {
                showToast('No hay datos para exportar.', 'error'); return;
            }
            const uploadedFileName = domCache.csvFileInput && domCache.csvFileInput.dataset.uploadedFileName ? domCache.csvFileInput.dataset.uploadedFileName : null;
            const defaultName = generateDefaultFilename('csv', uploadedFileName);
            showFilenameModal("Exportar Horario a CSV", "Nombre base para el archivo CSV:", defaultName, ".csv", exportScheduleToCSV);
        }

        function exportScheduleToCSV(filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`; // e.g., "horario_enero.csv"
            let csvContent = "Empleado,Mes,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31\n";

            employeeNamesOrdered.forEach(empName => {
                for (let month = 1; month <= 12; month++) { // Iterate through all 12 months
                    let row = `"${empName.replace(/"/g, '""')}",${month}`; // Quote employee name, add month
                    const monthData = scheduleData[empName]?.[month] || {};
                    const daysInThisMonth = getDaysInMonth(month, yearOfSchedule); // Use current schedule year

                    for (let day = 1; day <= 31; day++) { // Always output 31 day columns for consistency
                        if (day <= daysInThisMonth) {
                            let cellValue = monthData[day] || "";
                            // Quote cell value if it contains comma, quote, or newline
                            if (/[",\n\r]/.test(cellValue)) {
                                cellValue = `"${cellValue.replace(/"/g, '""')}"`;
                            }
                            row += `,${cellValue}`;
                        } else {
                            row += `,`; // Empty cell for days beyond the current month's length
                        }
                    }
                    csvContent += row + "\n";
                }
            });

            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); // UTF-8 BOM
            const link = createElement("a", {
                attributes: { href: URL.createObjectURL(blob), download: finalFilename },
                style: { visibility: 'hidden' }
            });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href); // Clean up blob URL
            showToast(`Horario exportado como ${finalFilename}.`, 'success');
        }

        function createEmptyCSVTemplate() {
            const csvHeader = "Empleado,Mes,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31\n";
            const placeholderRow = "\"Empleado Ejemplo\",1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n"; // Example for January
            const csvContent = csvHeader + placeholderRow;
            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
            const filename = "plantilla_horario_vacia.csv";

            const link = createElement("a", {
                attributes: { href: URL.createObjectURL(blob), download: filename },
                style: { visibility: 'hidden' }
            });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Plantilla CSV "${filename}" descargada.`, 'success');
        }

        // --- PDF/SVG EXPORT ---
        function prepareDownloadSvgOrPdf(type) { // type: 'weekly' or 'monthlyAnnual'
            if (!isDataLoadedForStats()) {
                showToast('No hay horario para descargar.', 'error'); return;
            }
            if (type === 'weekly' && currentViewMode !== 'monthly') {
                 showToast('La descarga semanal solo está disponible en vista mensual.', 'warning'); return;
            }

            let defaultNameContext = type === 'weekly' ? 'pdfWeekly' : (currentViewMode === 'monthly' ? 'pdfMonthly' : 'pdfAnnual');
            const defaultName = generateDefaultFilename(defaultNameContext);
            const modalTitle = `Descargar ${type === 'weekly' ? 'Semanal' : (currentViewMode === 'monthly' ? 'Mensual' : 'Anual')} PDF`;
            showFilenameModal(modalTitle, "Nombre base para el archivo PDF:", defaultName, ".pdf", (filenameBase) => downloadSvgOrPdfInternal(type, filenameBase));
        }

        async function downloadSvgOrPdfInternal(type, filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`; // e.g., "horario_semanal.pdf"
            showToast('Generando PDF, por favor espera...', 'info');

            const svgString = getSvgString(type); // Generate SVG content
            if (!svgString) { showToast('Error al generar contenido SVG.', 'error'); return; }

            try {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
                const svgElement = svgDoc.documentElement;

                // Check for parsing errors
                if (svgElement.tagName === "parsererror" || !svgElement) {
                    throw new Error("Error al parsear SVG: " + (svgDoc.body ? svgDoc.body.innerText : "Error desconocido"));
                }

                const svgWidth = parseFloat(svgElement.getAttribute('width'));
                const svgHeight = parseFloat(svgElement.getAttribute('height'));

                if (isNaN(svgWidth) || isNaN(svgHeight) || svgWidth <= 0 || svgHeight <= 0) {
                    throw new Error(`Dimensiones SVG inválidas: ${svgWidth}x${svgHeight}`);
                }

                const { jsPDF } = window.jspdf; // Make sure jsPDF is loaded
                const pdf = new jsPDF({
                    orientation: svgWidth > svgHeight ? 'l' : 'p', // Landscape if wider
                    unit: 'px',
                    format: [svgWidth, svgHeight], // Custom format based on SVG size
                    hotfixes: ['px_scaling'] // Important for correct px interpretation
                });

                await pdf.svg(svgElement, { x: 0, y: 0, width: svgWidth, height: svgHeight });
                pdf.save(finalFilename);
                showToast(`PDF descargado como ${finalFilename}.`, 'success');
            } catch (error) {
                console.error("Error al generar PDF:", error, error.stack);
                showToast('Error al generar el PDF: ' + error.message, 'error');
            }
        }


        // --- VIEW MODE HANDLING ---
        function switchViewMode(mode) { // mode: 'monthly' or 'annual'
            if (currentViewMode !== mode) { // Only save state if view actually changes
                saveStateForUndo(`Vista cambiada a ${mode === 'monthly' ? 'mensual' : 'anual'}.`);
            }
            clearSelection(); // Clear selection when switching views
            currentViewMode = mode;
            updateViewModeUI(); // Update button states, titles
            handleViewChange(); // Re-render the table
            updateCalendarExportButtonsState(); // Enable/disable calendar export
            domCache.calculateStatsButtonNew.disabled = !isDataLoadedForStats(); // Re-check stats button
        }


        function updateViewModeUI() {
            const dataExists = isDataLoadedForStats();
            domCache.monthTabsContainer.style.display = (currentViewMode === 'monthly' && dataExists) ? 'flex' : 'none';
            domCache.downloadImageButton.disabled = !dataExists; // General PDF download
            domCache.downloadWeeklySvgButton.disabled = !dataExists || currentViewMode !== 'monthly'; // Weekly PDF only in monthly view

            if (currentViewMode === 'annual' && dataExists) {
                domCache.downloadImageButton.title = "Descargar vista anual como PDF.";
                domCache.viewAnnualButton.classList.add('active');
                domCache.viewMonthlyButton.classList.remove('active');
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${yearOfSchedule}`;
            } else if (currentViewMode === 'monthly' && dataExists){
                domCache.downloadImageButton.title = "Descargar vista mensual como PDF.";
                domCache.viewMonthlyButton.classList.add('active');
                domCache.viewAnnualButton.classList.remove('active');
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`;
                highlightActiveMonthTab();
            } else { // No data loaded or invalid state
                 domCache.downloadImageButton.title = "";
                 if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes Año]';
                 domCache.viewMonthlyButton.classList.remove('active');
                 domCache.viewAnnualButton.classList.remove('active');
            }
            updateCalendarExportButtonsState();
            updateUnsavedChangesIndicator(); // Show/hide unsaved dot
        }

        function handleViewChange() {
            clearSelection(); // Clear any active selection
            if (currentViewMode === 'annual') {
                renderAnnualScheduleTable(yearOfSchedule);
            } else { // 'monthly'
                renderMonthlyScheduleTable(currentSelectedMonth, yearOfSchedule);
            }
        }

        // --- MONTH TABS ---
        function populateMonthTabs() {
            domCache.monthTabsContainer.innerHTML = ''; // Clear existing tabs
            if (!isDataLoadedForStats()) { // Hide if no data
                domCache.monthTabsContainer.classList.add('hidden-by-default'); return;
            }
            domCache.monthTabsContainer.classList.remove('hidden-by-default');

            MONTH_NAMES.forEach((monthName, index) => {
                const monthNum = index + 1;
                const button = createElement('button', {
                    className: 'month-tab',
                    textContent: monthName.substring(0,3).toUpperCase(), // e.g., ENE
                    dataset: { month: monthNum }
                });
                if (monthNum === currentSelectedMonth) button.classList.add('active');

                button.addEventListener('click', () => {
                    if (currentSelectedMonth !== monthNum) {
                        saveStateForUndo(`Mes cambiado a ${MONTH_NAMES[monthNum - 1]}.`);
                        currentSelectedMonth = monthNum;
                        switchViewMode('monthly'); // Will call handleViewChange
                    }
                });
                domCache.monthTabsContainer.appendChild(button);
            });
            highlightActiveMonthTab(); // Ensure correct tab is highlighted
        }


        function highlightActiveMonthTab() {
            domCache.monthTabsContainer.querySelectorAll('.month-tab').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.month) === currentSelectedMonth);
            });
        }

        // --- EMPLOYEE SELECTS (for modals) ---
        function populateEmployeeSelects(selectElement) {
            selectElement.innerHTML = ''; // Clear existing
            const placeholder = createElement('option', { textContent: 'Selecciona empleado', attributes: { value: "" } });
            selectElement.appendChild(placeholder);
            selectElement.value = ""; // Default to placeholder

            employeeNamesOrdered.forEach(name => {
                selectElement.appendChild(createElement('option', { textContent: name, attributes: { value: name } }));
            });
        }

        // --- DATE UTILITIES ---
        function getDaysInMonth(month, year) { // month is 1-12
            return new Date(year, month, 0).getDate();
        }
        function getWeekDayInitial(year, month, day) { // month is 1-12
            return SHORT_WEEK_DAY_NAMES[new Date(year, month - 1, day).getDay()];
        }

        // --- CELL STYLING ---
        function applyShiftCellStyles(cell, shiftValue) {
            // Remove all potentially existing color classes first
            const allColorKeys = [...SHIFT_TYPES, 'empty', ...Object.keys(currentShiftColors), ...Object.keys(DEFAULT_SHIFT_COLORS)];
            allColorKeys.forEach(stKey => {
                // Check both current and default in case one was removed or is undefined
                if (DEFAULT_SHIFT_COLORS[stKey]?.bg) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].bg);
                if (DEFAULT_SHIFT_COLORS[stKey]?.text) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].text);
                if (currentShiftColors[stKey]?.bg) cell.classList.remove(currentShiftColors[stKey].bg);
                if (currentShiftColors[stKey]?.text) cell.classList.remove(currentShiftColors[stKey].text);
            });

            // Apply the correct color based on currentShiftColors
            const colorConfToApply = SHIFT_TYPES.includes(shiftValue) ? currentShiftColors[shiftValue] : currentShiftColors.empty;
            if (colorConfToApply?.bg) cell.classList.add(colorConfToApply.bg);
            if (colorConfToApply?.text) cell.classList.add(colorConfToApply.text);
        }

        // --- TABLE INTERACTION (DBLCLICK, DRAG & DROP EMPLOYEES) ---
        function handleTableDblClick(event) {
            const target = event.target;
            const employeeNameDisplay = target.closest('.employee-name-display');
            const shiftCell = target.closest('td.shift-cell');

            if (employeeNameDisplay && !target.closest('.delete-employee-icon')) { // Dblclick on name (not delete icon)
                const td = employeeNameDisplay.closest('.employee-name-cell');
                const currentName = employeeNameDisplay.textContent;
                const input = createElement('input', {
                    attributes: { type: 'text', value: currentName },
                    className: 'w-full p-1 border border-indigo-300 rounded text-sm'
                });
                td.innerHTML = ''; td.appendChild(input); input.focus(); input.select();

                const saveName = () => {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        if (employeeNamesOrdered.includes(newName)) {
                            showToast(`El nombre "${newName}" ya existe.`, 'error');
                            // Restore original display
                            td.innerHTML = '';
                            const newNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                            const deleteIcon = createDeleteEmployeeIcon(currentName);
                            td.appendChild(newNameSpan); td.appendChild(deleteIcon);
                            return;
                        }
                        updateEmployeeName(currentName, newName); // This will re-render
                    } else { // No change or empty name, revert
                        td.innerHTML = '';
                        const newNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIcon = createDeleteEmployeeIcon(currentName);
                        td.appendChild(newNameSpan); td.appendChild(deleteIcon);
                    }
                };
                input.addEventListener('blur', saveName);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') saveName();
                    else if (e.key === 'Escape') { // Revert on Escape
                        td.innerHTML = '';
                        const newNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIcon = createDeleteEmployeeIcon(currentName);
                        td.appendChild(newNameSpan); td.appendChild(deleteIcon);
                    }
                });
            } else if (shiftCell) { // Dblclick on a shift cell
                const cellInfo = getCellInfoFromElement(shiftCell);
                if (!cellInfo) return;

                const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                // Allow editing only if it's NOT one of the predefined M,T,N,L,V shifts
                if (SHIFT_TYPES.includes(currentValue)) {
                    return; // Do nothing for standard shifts on dblclick
                }

                // Prepare for custom event modal
                cellsBeingEditedViaEventModal = [{
                    tdElement: shiftCell,
                    employee: cellInfo.employee,
                    month: cellInfo.month,
                    day: cellInfo.day,
                    originalValue: currentValue // Store the original value for undo
                }];
                isSingleCellEditViaModal = true;
                const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
                showCustomEventModal(modalTitle, currentValue);
                clearSelection(false); // Clear selection as modal takes over
            }
        }

        function updateEmployeeName(oldName, newName) {
            saveStateForUndo(`Nombre de empleado: "${oldName}" -> "${newName}".`);

            const index = employeeNamesOrdered.indexOf(oldName);
            if (index > -1) employeeNamesOrdered[index] = newName;

            if (scheduleData[oldName]) {
                scheduleData[newName] = scheduleData[oldName]; // Transfer data
                delete scheduleData[oldName];
            }
            handleViewChange(); // Re-render table
            if (isDataLoadedForStats()) calculateAndRenderComparativeStats(); // Update stats
            showToast(`Nombre de empleado actualizado a "${newName}".`, 'success');
        }


        function createDeleteEmployeeIcon(employeeName) {
            const deleteIcon = createElement('i', {
                className: 'fas fa-trash-alt delete-employee-icon text-red-400 hover:text-red-600',
                title: `Eliminar a ${employeeName}`
            });
            deleteIcon.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent dblclick on name cell if icon is clicked
                promptDeleteEmployee(employeeName);
            });
            return deleteIcon;
        }

        // --- TABLE RENDERING ---
        function buildScheduleTableHeader(viewType, month, year) { // month is 1-12 or null for annual
            const headerRow = createElement('tr');
            headerRow.appendChild(createElement('th', {
                textContent: 'Empleado',
                className: 'py-3 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sticky-col-header'
            }));

            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(month, year);
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    headerRow.appendChild(createElement('th', {
                        className: 'py-3 px-2 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider',
                        innerHTML: `<span class="day-header-date">${day}</span><span class="day-header-weekday">${getWeekDayInitial(year, month, day)}</span>`
                    }));
                }
            } else if (viewType === 'annual') {
                for (let m = 1; m <= 12; m++) {
                    const daysInThisMonth = getDaysInMonth(m, year);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        headerRow.appendChild(createElement('th', {
                            className: 'py-3 px-1.5 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider min-w-[50px]',
                            innerHTML: `<span class="day-header-date">${day}</span><span class="day-header-weekday">${SHORT_MONTH_NAMES[m-1]}</span>`
                        }));
                    }
                }
            }
            return headerRow;
        }

        function buildEmployeeRow(employeeName, rowIndex, viewType, currentDisplayMonth, yearToDisplay) { // currentDisplayMonth is 1-12 or null for annual
            const employeeRow = createElement('tr', {
                className: `draggable-row ${rowIndex % 2 === 0 ? 'bg-white' : 'bg-gray-50 hover:bg-gray-100'}`,
                dataset: { rowIndex: rowIndex.toString() } // Store original index for reordering
            });

            const nameCell = createElement('td', {
                className: 'py-2 px-4 whitespace-nowrap text-sm font-medium text-gray-800 sticky-col employee-name-cell',
                title: 'Doble clic para editar. Arrastra para reordenar.'
            });
            // Ensure background color for sticky name cell matches row
            nameCell.style.backgroundColor = (rowIndex % 2 === 0) ? '#ffffff' : '#f9fafb';


            const nameSpan = createElement('span', {
                className: 'employee-name-display flex-grow', // flex-grow to take available space
                textContent: employeeName,
                attributes: { draggable: "true" } // Make the name span draggable
            });
            const deleteIcon = createDeleteEmployeeIcon(employeeName);

            nameCell.appendChild(nameSpan);
            nameCell.appendChild(deleteIcon);
            employeeRow.appendChild(nameCell);

            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(currentDisplayMonth, yearToDisplay);
                const employeeMonthData = scheduleData[employeeName]?.[currentDisplayMonth] || {};
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    const shift = employeeMonthData[day] || "";
                    const tdShift = createElement('td', {
                        textContent: shift,
                        className: 'shift-cell',
                        dataset: { employee: employeeName, month: currentDisplayMonth.toString(), day: day.toString(), colIndex: (day - 1).toString() }
                    });
                    applyShiftCellStyles(tdShift, shift);
                    // Re-apply 'cell-selected' if this cell is in the selectedCells array
                    if (selectedCells.some(sc => sc.employee === employeeName && sc.month === currentDisplayMonth && sc.day === day)) {
                        tdShift.classList.add('cell-selected');
                    }
                    employeeRow.appendChild(tdShift);
                }
            } else if (viewType === 'annual') {
                let currentAnnualColIndex = 0;
                for (let m = 1; m <= 12; m++) {
                    const employeeMonthData = scheduleData[employeeName]?.[m] || {};
                    const daysInThisMonth = getDaysInMonth(m, yearToDisplay);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = employeeMonthData[day] || "";
                        const tdShift = createElement('td', {
                            textContent: shift,
                            className: 'shift-cell',
                            dataset: { employee: employeeName, month: m.toString(), day: day.toString(), colIndex: currentAnnualColIndex.toString() }
                        });
                        applyShiftCellStyles(tdShift, shift);
                         if (selectedCells.some(sc => sc.employee === employeeName && sc.month === m && sc.day === day)) {
                            tdShift.classList.add('cell-selected');
                        }
                        employeeRow.appendChild(tdShift);
                        currentAnnualColIndex++;
                    }
                }
            }
            return employeeRow;
        }

        function renderMonthlyScheduleTable(month, year) { // month is 1-12
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = ''; // Clear previous content

            const headerRow = buildScheduleTableHeader('monthly', month, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) { // If no employees or data
                renderAddEmployeeButtonInTable();
                enableControls(false); // Ensure controls are correctly disabled
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;
                domCache.noDataMessage.classList.remove('hidden-by-default');
                return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'monthly', month, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable(); // Add the "Add Employee" button row
            highlightActiveMonthTab();
            enableControls(true); // Ensure controls are enabled if data exists
        }

        function renderAnnualScheduleTable(year) {
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';

            const headerRow = buildScheduleTableHeader('annual', null, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) {
                 renderAddEmployeeButtonInTable();
                 enableControls(false);
                 if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;
                 domCache.noDataMessage.classList.remove('hidden-by-default');
                 return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'annual', null, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable();
            enableControls(true);
        }

        function renderAddEmployeeButtonInTable() {
            // Remove existing add row if any to prevent duplicates
            const existingAddRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
            if (existingAddRow) existingAddRow.remove();

            const addEmployeeRow = createElement('tr', { className: 'add-employee-row-reformed' });
            const buttonCell = createElement('td', { className: 'sticky-col add-employee-cell-reformed' });
            const buttonVisual = createElement('button', {
                className: 'add-employee-button-visual',
                title: 'Añadir nuevo empleado'
            });
            const addIcon = createElement('i', { className: 'fas fa-user-plus' });
            const buttonText = createElement('span', { textContent: 'Añadir Empleado' });
            buttonVisual.appendChild(addIcon);
            buttonVisual.appendChild(buttonText);
            buttonVisual.addEventListener('click', showAddEmployeeModal);
            buttonCell.appendChild(buttonVisual);
            addEmployeeRow.appendChild(buttonCell);

            // Add empty cells to match the number of day columns
            let numberOfDayCells = 0;
            const headerRow = domCache.scheduleTableHead.querySelector('tr');
            if (headerRow && headerRow.cells.length > 1) { // cells.length > 1 to account for "Empleado" header
                numberOfDayCells = headerRow.cells.length - 1;
            }
            for (let i = 0; i < numberOfDayCells; i++) {
                addEmployeeRow.appendChild(createElement('td', { className: 'add-employee-empty-cell-reformed' }));
            }
            domCache.scheduleTableBody.appendChild(addEmployeeRow);
        }


        // --- DRAG & DROP FOR EMPLOYEE REORDERING ---
        function handleDragStart(event) {
            if (event.target.classList.contains('employee-name-display')) {
                const targetRow = event.target.closest('.draggable-row');
                if (targetRow && targetRow.dataset.rowIndex) { // Ensure it's a data row, not add button row
                    draggedRow = targetRow;
                    event.dataTransfer.effectAllowed = 'move';
                    // event.dataTransfer.setData('text/plain', targetRow.dataset.rowIndex); // Optional
                    setTimeout(() => draggedRow.classList.add('dragging'), 0); // Style while dragging
                }
            } else {
                event.preventDefault(); // Prevent dragging other elements
            }
        }
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable-row:not(.dragging):not(.add-employee-row-reformed)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow drop
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
            removeDragOverIndicator(); // Clear previous indicator

            // Create and insert new indicator
            dragOverIndicator = createElement('tr', {className: 'drag-over-indicator-row'}, [
                createElement('td', {attributes: {colspan: "100%"}}, [ // Colspan to fill width
                     createElement('div', {className: 'drag-over-indicator'})
                ])
            ]);

            const addRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
            if (afterElement == null) { // If dragging to the end
                if (addRow) domCache.scheduleTableBody.insertBefore(dragOverIndicator, addRow);
                else domCache.scheduleTableBody.appendChild(dragOverIndicator);
            } else {
                domCache.scheduleTableBody.insertBefore(dragOverIndicator, afterElement);
            }
        }
        function handleDragLeave(event) {
            // Remove indicator if cursor leaves the table body area
            if (!domCache.scheduleTableBody.contains(event.relatedTarget)) {
                removeDragOverIndicator();
            }
        }
        function removeDragOverIndicator() {
            if (dragOverIndicator && dragOverIndicator.parentElement) {
                dragOverIndicator.parentElement.removeChild(dragOverIndicator);
            }
            dragOverIndicator = null;
        }
        function handleDrop(event) {
            event.preventDefault();
            removeDragOverIndicator();
            if (!draggedRow) return;

            saveStateForUndo("Empleados reordenados."); // Save state before actual data change

            const originalIndex = parseInt(draggedRow.dataset.rowIndex);
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
            let newIndex;

            if (afterElement) {
                newIndex = parseInt(afterElement.dataset.rowIndex);
                // If dragging downwards and originalIndex < newIndex, the effective splice index is newIndex - 1
                // If dragging upwards and originalIndex > newIndex, the effective splice index is newIndex
            } else {
                newIndex = employeeNamesOrdered.length; // Dropping at the very end
            }

            // Adjust newIndex if dragging downwards past its original position
            if (originalIndex < newIndex && afterElement) {
                 // No adjustment needed if afterElement exists, splice logic handles it.
            } else if (originalIndex > newIndex && afterElement) {
                // No adjustment needed here either.
            }


            const [draggedEmployeeName] = employeeNamesOrdered.splice(originalIndex, 1);

            if (afterElement) {
                if (originalIndex < newIndex) {
                    employeeNamesOrdered.splice(newIndex - 1, 0, draggedEmployeeName);
                } else {
                    employeeNamesOrdered.splice(newIndex, 0, draggedEmployeeName);
                }
            } else { // Dropping at the end
                 employeeNamesOrdered.push(draggedEmployeeName);
            }


            handleViewChange(); // Re-render the table with new order
            if (isDataLoadedForStats()) calculateAndRenderComparativeStats(); // Update stats if data exists
            if(draggedRow) draggedRow.classList.remove('dragging');
            draggedRow = null;
        }

        function handleDragEnd(event) {
            if(draggedRow) draggedRow.classList.remove('dragging'); // Clean up class
            removeDragOverIndicator(); // Ensure indicator is removed
            draggedRow = null;
        }

        // --- CELL EDITING (LONG PRESS / DBLCLICK) ---
        function editCellOnLongPress(cellInfo) { // For touch devices
            const shiftCell = cellInfo.tdElement;
            const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";

            // Only open modal if it's not a standard shift type (M,T,N,L,V)
            if (SHIFT_TYPES.includes(currentValue)) {
                 return; // Or, potentially trigger selection like Ctrl+Click
            }

            cellsBeingEditedViaEventModal = [{
                tdElement: shiftCell,
                employee: cellInfo.employee,
                month: cellInfo.month,
                day: cellInfo.day,
                originalValue: currentValue // Store original value for undo
            }];
            isSingleCellEditViaModal = true;
            const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
            showCustomEventModal(modalTitle, currentValue);
            clearSelection(false); // Don't hide toolbar if it was a long press on a selected cell
        }

        // --- CELL SELECTION LOGIC ---
        function getCellInfoFromElement(tdElement) {
            if (!tdElement || !tdElement.dataset.employee) return null;
            return {
                employee: tdElement.dataset.employee,
                month: parseInt(tdElement.dataset.month),
                day: parseInt(tdElement.dataset.day),
                tdElement: tdElement,
                rowIndex: parseInt(tdElement.parentElement.dataset.rowIndex), // Assumes parent TR has rowIndex
                colIndex: parseInt(tdElement.dataset.colIndex)
            };
        }
        function processCellClick(cellInfo, isShiftKey, isCtrlOrMetaKey, isTap = false) {
            if (isCtrlOrMetaKey || (isTap && !isShiftKey)) { // Ctrl/Cmd click or simple tap
                toggleCellSelection(cellInfo);
                lastSelectedCellInfo = cellInfo; // Update last selected for potential Shift+Click
            } else if (isShiftKey && lastSelectedCellInfo) { // Shift+Click
                clearSelection(false); // Clear previous selection but keep toolbar if open
                // Select range from lastSelectedCellInfo to cellInfo
                const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
                const minRow = Math.min(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const maxRow = Math.max(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const minCol = Math.min(lastSelectedCellInfo.colIndex, cellInfo.colIndex);
                const maxCol = Math.max(lastSelectedCellInfo.colIndex, cellInfo.colIndex);

                allCellsInTable.forEach(cellElement => {
                    const cellIterInfo = getCellInfoFromElement(cellElement);
                    if (cellIterInfo &&
                        cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol) {
                        if (!selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement)) {
                            selectedCells.push(cellIterInfo);
                            cellIterInfo.tdElement.classList.add('cell-selected');
                        }
                    }
                });
                // lastSelectedCellInfo remains the start of the Shift+Click for subsequent Shift+Clicks
            } else { // Simple click (not Ctrl/Shift, not a tap handled as Ctrl)
                if (selectedCells.length > 0 && !selectedCells.some(sc => sc.tdElement === cellInfo.tdElement)) {
                    clearSelection(false); // Clear previous selection if clicking a new cell
                }
                toggleCellSelection(cellInfo);
                lastSelectedCellInfo = cellInfo;
            }
            // updateMultiselectToolbar(); // Called by the drag handlers or after tap
        }

        function toggleCellSelection(cellInfo) {
            const existingIndex = selectedCells.findIndex(sc => sc.tdElement === cellInfo.tdElement);
            if (existingIndex > -1) { // Cell is already selected, deselect it
                selectedCells.splice(existingIndex, 1);
                cellInfo.tdElement.classList.remove('cell-selected');
            } else { // Cell is not selected, select it
                selectedCells.push(cellInfo);
                cellInfo.tdElement.classList.add('cell-selected');
            }
        }
        function clearSelection(hideToolbar = true) {
            selectedCells.forEach(cell => cell.tdElement.classList.remove('cell-selected'));
            selectedCells = [];
            lastSelectedCellInfo = null; // Reset for Shift+Click
            if (hideToolbar) updateMultiselectToolbar(); // Hide toolbar if selection is cleared
        }
        // --- MULTISELECT TOOLBAR ---
        function setupMultiselectToolbar() {
            domCache.multiselectToolbar.innerHTML = ''; // Clear existing buttons
            SHIFT_TYPES.forEach(shift => {
                const button = createElement('button', {
                    textContent: shift,
                    title: `Asignar ${SHIFT_TYPE_FULL_NAMES[shift]} (${shift}) a selección`
                });
                button.addEventListener('click', () => { applyShiftToSelection(shift); });
                domCache.multiselectToolbar.appendChild(button);
            });
            const otherButton = createElement('button', {
                textContent: 'Otro',
                title: 'Asignar "Otro" (vacío) a selección',
                className: 'other-selection'
            });
            otherButton.addEventListener('click', () => { applyShiftToSelection(''); }); // '' for custom/empty
            domCache.multiselectToolbar.appendChild(otherButton);
        }
        function updateMultiselectToolbar() {
            domCache.multiselectToolbar.classList.toggle('hidden-by-default', selectedCells.length === 0);
        }
        function applyShiftToSelection(newShift) {
            // If "Otro" is clicked, open the custom event modal for all selected cells
            if (newShift === '' && selectedCells.length > 0) {
                cellsBeingEditedViaEventModal = selectedCells.map(sc => ({
                    tdElement: sc.tdElement,
                    employee: sc.employee,
                    month: sc.month,
                    day: sc.day,
                    originalValue: scheduleData[sc.employee]?.[sc.month]?.[sc.day] || "" // Store original value
                }));
                isSingleCellEditViaModal = false; // It's a multi-cell edit via toolbar
                let modalTitle;
                if (selectedCells.length === 1) {
                    const sc = selectedCells[0];
                    modalTitle = `Establecer Evento: ${sc.employee} - ${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}`;
                } else {
                    modalTitle = `Establecer Evento para ${selectedCells.length} Celdas`;
                }
                showCustomEventModal(modalTitle, ""); // Start with empty text for "Otro"
                return; // Modal will handle saving
            }

            if (selectedCells.length === 0) return;

            let changesMadeCount = 0;
            let undoDescription = `Turno de ${selectedCells.length} celda(s) cambiado a '${newShift || "Vacío"}'.`;
            if (selectedCells.length === 1) { // More specific undo message for single cell
                 const sc = selectedCells[0];
                 const originalShift = scheduleData[sc.employee]?.[sc.month]?.[sc.day] || "";
                 undoDescription = `Turno de ${sc.employee} (${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}) cambiado de '${originalShift || "Vacío"}' a '${newShift || "Vacío"}'.`;
            }

            // Check if any actual change will occur before saving state for undo
            let needsStateSave = selectedCells.some(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                return originalShift !== newShift;
            });

            if (needsStateSave) {
                saveStateForUndo(undoDescription);
            }

            selectedCells.forEach(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                if (originalShift !== newShift) { // Only update if different
                    updateShift(cellInfo.tdElement, cellInfo.employee, cellInfo.month, cellInfo.day, newShift, originalShift, false); // false because undo is handled globally
                    changesMadeCount++;
                }
            });
            if (changesMadeCount > 0) {
                 if (isDataLoadedForStats()) calculateAndRenderComparativeStats(); // Update stats if data changed
            }
        }

        function updateShift(td, employee, month, day, newShift, originalShift, logIndividualChange = true) {
            // logIndividualChange is true if called from a single cell edit (like dblclick),
            // false if called from applyShiftToSelection (where undo is handled globally)
            if (originalShift !== newShift && logIndividualChange) {
                 const originalShiftDisplay = SHIFT_TYPE_FULL_NAMES[originalShift] || (originalShift === "" ? "Vacío" : (originalShift || "Vacío"));
                 const newShiftDisplay = SHIFT_TYPE_FULL_NAMES[newShift] || (newShift === "" ? "Vacío" : (newShift || "Vacío"));
                 saveStateForUndo(`Turno de ${employee} (${day}/${SHORT_MONTH_NAMES[month-1]}) cambiado de '${originalShiftDisplay}' a '${newShiftDisplay}'.`);
            }

            if (!scheduleData[employee]) scheduleData[employee] = {};
            if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
            scheduleData[employee][month][day] = newShift;

            td.textContent = newShift; // Update cell text
            applyShiftCellStyles(td, newShift); // Apply new styles
        }


        // --- STATISTICS ---
        function calculateAndRenderComparativeStats() {
            if (!isDataLoadedForStats()) {
                updateStatsDisplayForNoData();
                domCache.calculateStatsButtonNew.disabled = true; // Ensure button is disabled
                return;
            }
            domCache.statsPlaceholder.classList.add('hidden-by-default');
            domCache.comparativeStatsTableContainer.classList.remove('hidden-by-default');
            domCache.calculateStatsButtonNew.disabled = false; // Enable button as data is present

            const selectedPeriodValue = domCache.statsPeriodFilterNew.value;
            const currentYearForStats = yearOfSchedule; // Use the globally set year
            let employeeStatsArray = [];

            employeeNamesOrdered.forEach(empName => {
                let stats = { M: 0, T: 0, N: 0, L: 0, V: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0 };
                if (!scheduleData[empName]) { // Handle case where employee has no schedule data yet
                    employeeStatsArray.push({ name: empName, ...stats, totalShifts: 0 });
                    return;
                }

                let monthsToProcess = [];
                if (selectedPeriodValue === 'full_year') {
                    for (let m = 1; m <= 12; m++) monthsToProcess.push(m);
                } else {
                    monthsToProcess.push(parseInt(selectedPeriodValue));
                }

                monthsToProcess.forEach(month => {
                    if (!scheduleData[empName][month]) return; // Skip if no data for this month

                    const daysInThisMonth = getDaysInMonth(month, currentYearForStats);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = scheduleData[empName][month][day];
                        if (shift !== undefined && shift !== null) { // Ensure shift exists
                            if (SHIFT_TYPES.includes(shift)) {
                                stats[shift]++;
                                if (["M", "T", "N"].includes(shift)) stats.totalWorkDays++;
                            } else if (shift !== "") { // Custom event, count as "Otro" and work day
                                stats.Otro++;
                                stats.totalWorkDays++;
                            }
                            // Weekend off calculation (Saturday + Sunday are L, V, or empty)
                            const currentDate = new Date(currentYearForStats, month - 1, day);
                            if (currentDate.getDay() === 6) { // If it's a Saturday
                                const nextDayDate = new Date(currentYearForStats, month - 1, day + 1);
                                if (nextDayDate.getMonth() === month - 1) { // Ensure Sunday is in the same month
                                    const satShift = scheduleData[empName][month][day];
                                    const sunShift = scheduleData[empName][month][day + 1];
                                    if ((satShift === "L" || satShift === "V" || satShift === "") &&
                                        (sunShift === "L" || sunShift === "V" || sunShift === "")) {
                                         stats.weekendsOff++;
                                    }
                                }
                            }
                        }
                    }
                });
                const totalShifts = stats.M + stats.T + stats.N + stats.L + stats.V + stats.Otro;
                employeeStatsArray.push({ name: empName, ...stats, totalShifts });
            });

            // Sort data if sort config exists
            if (comparativeStatsSortConfig.column) {
                employeeStatsArray.sort((a, b) => {
                    let valA = a[comparativeStatsSortConfig.column];
                    let valB = b[comparativeStatsSortConfig.column];

                    if (typeof valA === 'string') valA = valA.toLowerCase();
                    if (typeof valB === 'string') valB = valB.toLowerCase();

                    if (valA < valB) return comparativeStatsSortConfig.direction === 'asc' ? -1 : 1;
                    if (valA > valB) return comparativeStatsSortConfig.direction === 'asc' ? 1 : -1;
                    return 0;
                });
            }
            renderComparativeTable(employeeStatsArray);
        }

        function renderComparativeTable(employeeStatsArray) {
            domCache.comparativeStatsTableContainer.innerHTML = ''; // Clear previous table
            domCache.employeeShiftDistributionDetailContainer.classList.add('hidden-by-default'); // Hide detail chart initially

            if (employeeStatsArray.length === 0) { // Should be handled by isDataLoadedForStats, but as a fallback
                updateStatsDisplayForNoData();
                return;
            }

            const table = createElement('table', { id: 'comparative-stats-table', className: 'min-w-full' });
            const thead = createElement('thead');
            const tbody = createElement('tbody');
            const headerRow = createElement('tr');
            const columns = [
                { key: 'name', label: 'Empleado', sortable: true },
                { key: 'M', label: 'M', sortable: true }, { key: 'T', label: 'T', sortable: true },
                { key: 'N', label: 'N', sortable: true }, { key: 'L', label: 'L', sortable: true },
                { key: 'V', label: 'V', sortable: true }, { key: 'Otro', label: 'Otros', sortable: true },
                { key: 'totalWorkDays', label: 'Días Trab.', sortable: true },
                { key: 'weekendsOff', label: 'FDS Lib.', sortable: true, title: 'Fines de Semana Libres (Sáb+Dom)' }
            ];

            columns.forEach(col => {
                const th = createElement('th', { textContent: col.label, title: col.title || col.label });
                if (col.key === 'name') th.classList.add('employee-name-col'); // For sticky styling
                if (col.sortable) {
                    th.classList.add('sortable');
                    th.dataset.sortKey = col.key;
                    const sortIcon = createElement('span', {className: 'sort-icon fas'});
                    if (comparativeStatsSortConfig.column === col.key) {
                        sortIcon.classList.add(comparativeStatsSortConfig.direction === 'asc' ? 'fa-sort-up' : 'fa-sort-down');
                    } else {
                        sortIcon.classList.add('fa-sort'); // Default sort icon
                    }
                    th.appendChild(sortIcon);
                    th.addEventListener('click', handleStatsSort);
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            employeeStatsArray.forEach((empStat, rowIndex) => {
                const tr = createElement('tr');
                tr.dataset.employeeName = empStat.name; // For identifying row
                if (rowIndex % 2 !== 0) tr.classList.add('bg-gray-50'); // Alternating row color

                columns.forEach(col => {
                    const td = createElement('td');
                    if (col.key === 'name') {
                        td.textContent = empStat.name;
                        td.classList.add('employee-name-col', 'font-medium', 'text-gray-900');
                        td.style.backgroundColor = 'inherit'; // Ensure sticky column bg matches row
                    } else {
                        td.textContent = empStat[col.key];
                        td.classList.add('text-center'); // Center align numbers
                    }
                    tr.appendChild(td);
                });
                tr.addEventListener('click', () => handleEmployeeStatsRowClick(empStat, tr));
                tbody.appendChild(tr);
            });

            table.appendChild(thead);
            table.appendChild(tbody);
            domCache.comparativeStatsTableContainer.appendChild(table);
        }

        function handleEmployeeStatsRowClick(employeeData, clickedRow) {
            // Highlight selected row
            if (lastSelectedEmployeeStatsRow) {
                lastSelectedEmployeeStatsRow.classList.remove('stats-row-selected');
            }
            clickedRow.classList.add('stats-row-selected');
            lastSelectedEmployeeStatsRow = clickedRow;

            // Render and show detail chart
            renderEmployeeShiftDetailChart(employeeData);
            domCache.employeeShiftDistributionDetailContainer.classList.remove('hidden-by-default');
            domCache.employeeShiftDistributionDetailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function renderEmployeeShiftDetailChart(employeeData) {
            domCache.employeeNameForDetailChart.textContent = employeeData.name;
            const chartElement = domCache.employeeShiftChart;
            chartElement.innerHTML = ''; // Clear previous chart

            const relevantShiftTypes = [...SHIFT_TYPES, 'Otro']; // M, T, N, L, V, Otro
            let maxCount = 0;
            relevantShiftTypes.forEach(typeKey => {
                const count = typeKey === 'Otro' ? employeeData.Otro : employeeData[typeKey];
                if (count > maxCount) maxCount = count;
            });
             if (maxCount === 0) maxCount = 1; // Avoid division by zero for height calculation


            const chartContainerHeight = 200; // Max height of a bar in pixels

            relevantShiftTypes.forEach(typeKey => {
                const count = typeKey === 'Otro' ? employeeData.Otro : employeeData[typeKey];
                const colorConf = typeKey === 'Otro' ? currentShiftColors.empty : currentShiftColors[typeKey];
                const fullName = typeKey === 'Otro' ? 'Otros' : SHIFT_TYPE_FULL_NAMES[typeKey];

                const barWrapper = createElement('div', { className: 'shift-chart-bar-wrapper' });
                const barPixelHeight = (count / maxCount) * chartContainerHeight;
                const actualBarHeight = count > 0 ? Math.max(5, barPixelHeight) : 0; // Min height of 5px if count > 0


                const bar = createElement('div', {
                    className: 'shift-chart-bar',
                    style: {
                        height: `${actualBarHeight}px`,
                        backgroundColor: colorConf.hexBg // Use hex color for SVG/PDF consistency
                    }
                });
                const valueSpan = createElement('span', { className: 'bar-value', textContent: count });
                const labelSpan = createElement('span', { className: 'shift-chart-bar-label', textContent: `${fullName} (${typeKey === 'empty' ? 'Otro' : typeKey})` });

                bar.appendChild(valueSpan);
                barWrapper.appendChild(bar);
                barWrapper.appendChild(labelSpan);
                chartElement.appendChild(barWrapper);
            });
        }


        function handleStatsSort(event) {
            const sortKey = event.currentTarget.dataset.sortKey;
            if (!sortKey) return;

            if (comparativeStatsSortConfig.column === sortKey) {
                // Toggle direction if same column
                comparativeStatsSortConfig.direction = comparativeStatsSortConfig.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to ascending
                comparativeStatsSortConfig.column = sortKey;
                comparativeStatsSortConfig.direction = 'asc';
            }
            calculateAndRenderComparativeStats(); // Re-render with new sort
        }

        // --- SVG GENERATION FOR PDF ---
        function getSvgString(type) { // type: 'weekly' or 'monthlyAnnual'
            const yearToRender = yearOfSchedule;
            let svgElements = [];
            let svgWidth = 0, svgHeight = 0;

            // Common styles and dimensions
            const padding = 20, logoRenderWidth = 200, logoRenderHeight = 75, logoBottomMargin = 20;
            const employeeColWidth = 120, cellHeight = 30, headerHeight = 45;
            const cellFontSize = 10, headerFontSize = 9, weekdayFontSize = 8, titleFontSize = 16;
            const monthTitleSpacing = 30, tableSpacing = 25, textYAdjust = cellFontSize * 0.35; // Fine-tune vertical text alignment

            let currentY = padding; // Start Y position
            // Add logo at the top center (calculated after width is known for some types)
            currentY += logoRenderHeight + logoBottomMargin;

            if (type === 'monthlyAnnual') {
                if (currentViewMode === 'monthly') {
                    const monthToRender = currentSelectedMonth;
                    const titleText = `Horario para ${MONTH_NAMES[monthToRender - 1]} ${yearToRender}`;
                    const svgCellWidthMonthly = 45;
                    const daysInSelectedMonth = getDaysInMonth(monthToRender, yearToRender);

                    svgWidth = padding * 2 + employeeColWidth + (daysInSelectedMonth * svgCellWidthMonthly);
                    const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
                    svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

                    const titleY = currentY + titleFontSize / 2 + 5;
                    svgElements.push(`<text x="${svgWidth / 2}" y="${titleY}" font-family="Inter, sans-serif" font-size="${titleFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${titleText}</text>`);
                    currentY = titleY + titleFontSize / 2 + monthTitleSpacing - titleFontSize / 2 ; // Adjust Y for table

                    // Table Header
                    let tableHeaderX = padding;
                    svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${employeeColWidth}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
                    svgElements.push(`<text x="${tableHeaderX + employeeColWidth / 2}" y="${currentY + headerHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">Empleado</text>`);
                    tableHeaderX += employeeColWidth;

                    for (let day = 1; day <= daysInSelectedMonth; day++) {
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthMonthly}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
                        const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
                        const dayNumberY = currentY + headerHeight * 0.38 + textYAdjust * 0.5; // Adjusted for two lines
                        const weekDayY = currentY + headerHeight * 0.72 + textYAdjust * 0.5;
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly / 2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${day}</text>`);
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly / 2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${weekdayFontSize}px" font-weight="bold" text-anchor="middle" fill="#6b7280" dominant-baseline="middle">${weekDayInitial}</text>`);
                        tableHeaderX += svgCellWidthMonthly;
                    }
                    currentY += headerHeight; // Move Y down for employee rows

                    // Employee Rows
                    employeeNamesOrdered.forEach((empName, rowIndex) => {
                        const rowY = currentY + rowIndex * cellHeight;
                        let currentCellX = padding;
                        // Employee Name Cell
                        svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`);
                        svgElements.push(`<text x="${currentCellX + employeeColWidth / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
                        currentCellX += employeeColWidth;

                        // Shift Cells
                        const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = employeeMonthData[day] || "";
                            const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthMonthly}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#e0e0e0" />`);
                            if (shift) { // Only add text if shift exists
                                svgElements.push(`<text x="${currentCellX + svgCellWidthMonthly / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${shift}</text>`);
                            }
                            currentCellX += svgCellWidthMonthly;
                        }
                    });
                    svgHeight = currentY + (employeeNamesOrdered.length * cellHeight) + padding; // Total height
                    svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`); // Background

                } else { // Annual View
                    const svgCellWidthAnnual = 35; // Narrower cells for annual view
                    let maxDaysInMonth = 0;
                    for (let m = 1; m <= 12; m++) maxDaysInMonth = Math.max(maxDaysInMonth, getDaysInMonth(m, yearToRender));

                    svgWidth = padding * 2 + employeeColWidth + (maxDaysInMonth * svgCellWidthAnnual); // Max width based on longest month
                    const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
                    svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

                    let currentGlobalY = currentY; // Y position for the start of the current month's table

                    for (let monthToRender = 1; monthToRender <= 12; monthToRender++) {
                        const monthTitleText = `${MONTH_NAMES[monthToRender - 1]} ${yearToRender}`;
                        const titleY = currentGlobalY + titleFontSize / 2 + 5;
                        svgElements.push(`<text x="${svgWidth / 2}" y="${titleY}" font-family="Inter, sans-serif" font-size="${titleFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${monthTitleText}</text>`);
                        currentGlobalY = titleY + titleFontSize / 2 + monthTitleSpacing - titleFontSize / 2;

                        // Table Header for this month
                        let tableHeaderX = padding;
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${employeeColWidth}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
                        svgElements.push(`<text x="${tableHeaderX + employeeColWidth / 2}" y="${currentGlobalY + headerHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">Empleado</text>`);
                        tableHeaderX += employeeColWidth;

                        const daysInCurrentMonth = getDaysInMonth(monthToRender, yearToRender);
                        for (let day = 1; day <= daysInCurrentMonth; day++) {
                            svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
                            const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
                            const dayNumberY = currentGlobalY + headerHeight * 0.38 + textYAdjust * 0.7; // Adjusted for annual view
                            const weekDayY = currentGlobalY + headerHeight * 0.72 + textYAdjust * 0.7;
                            svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual / 2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${day}</text>`);
                            svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual / 2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${weekdayFontSize}px" font-weight="bold" text-anchor="middle" fill="#6b7280" dominant-baseline="middle">${weekDayInitial}</text>`);
                            tableHeaderX += svgCellWidthAnnual;
                        }
                        // Fill remaining columns if this month is shorter than maxDaysInMonth
                        for (let day = daysInCurrentMonth + 1; day <= maxDaysInMonth; day++) {
                            svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#fdfdff" stroke="#e0e0e0" />`); // Lighter fill for empty day headers
                            tableHeaderX += svgCellWidthAnnual;
                        }
                        currentGlobalY += headerHeight;

                        // Employee Rows for this month
                        employeeNamesOrdered.forEach((empName, rowIndex) => {
                            const rowY = currentGlobalY + rowIndex * cellHeight;
                            let currentCellX = padding;
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`);
                            svgElements.push(`<text x="${currentCellX + employeeColWidth / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
                            currentCellX += employeeColWidth;

                            const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
                            for (let day = 1; day <= daysInCurrentMonth; day++) {
                                const shift = employeeMonthData[day] || "";
                                const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
                                svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#e0e0e0" />`);
                                if (shift) {
                                    svgElements.push(`<text x="${currentCellX + svgCellWidthAnnual / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${shift}</text>`);
                                }
                                currentCellX += svgCellWidthAnnual;
                            }
                            // Fill remaining cells if this month is shorter
                            for (let day = daysInCurrentMonth + 1; day <= maxDaysInMonth; day++) {
                                svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`); // Match row color
                                currentCellX += svgCellWidthAnnual;
                            }
                        });
                        currentGlobalY += (employeeNamesOrdered.length * cellHeight) + tableSpacing; // Add spacing between month tables
                    }
                    svgHeight = currentGlobalY - tableSpacing + padding / 2; // Adjust total height
                    svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);
                }
            } else if (type === 'weekly') {
                const monthToRender = currentSelectedMonth;
                const weeks = getWeeksForMonth(yearToRender, monthToRender);
                if (weeks.length === 0) return ''; // No weeks to render

                // Weekly specific dimensions
                const dayHeaderHeightWeekly = 40, cellWidthWeekly = 90; // Wider cells for weekly view with times
                const titleHeightWeekly = 30, weekTitleHeight = 25;
                const dateFontSizeWeekly = 10, dayNameFontSizeWeekly = 8;
                const titleFontSizeWeekly = 16, weekTitleFontSizeWeekly = 12;

                svgWidth = padding * 2 + employeeColWidth + (7 * cellWidthWeekly); // 7 days
                const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
                svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

                let currentGlobalY = currentY;
                const mainTitleY = currentGlobalY + titleFontSizeWeekly / 2 + 5;
                svgElements.push(`<text x="${svgWidth / 2}" y="${mainTitleY}" font-family="Inter, sans-serif" font-size="${titleFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">Horario Semanal - ${MONTH_NAMES[monthToRender - 1]} ${yearToRender}</text>`);
                currentGlobalY = mainTitleY + titleFontSizeWeekly / 2 + tableSpacing / 2;

                weeks.forEach((week, weekIndex) => {
                    const firstDayOfWeek = week[0], lastDayOfWeek = week[week.length-1];
                    const weekTitle = `Semana ${weekIndex + 1}: ${firstDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short'})} - ${lastDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short', year:'numeric'})}`;
                    const weekTitleYPos = currentGlobalY + weekTitleHeight / 2;
                    svgElements.push(`<text x="${svgWidth / 2}" y="${weekTitleYPos}" font-family="Inter, sans-serif" font-size="${weekTitleFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#374151" dominant-baseline="middle">${weekTitle}</text>`);
                    currentGlobalY = weekTitleYPos + weekTitleHeight / 2; // Space after week title

                    // Table Header for this week
                    let tableHeaderX = padding;
                    svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${employeeColWidth}" height="${dayHeaderHeightWeekly}" fill="#f3f4f6" stroke="#d1d5db"/>`);
                    svgElements.push(`<text x="${tableHeaderX + employeeColWidth/2}" y="${currentGlobalY + dayHeaderHeightWeekly/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${dateFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">Empleado</text>`);
                    tableHeaderX += employeeColWidth;

                    week.forEach(dateObj => {
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${cellWidthWeekly}" height="${dayHeaderHeightWeekly}" fill="#f3f4f6" stroke="#d1d5db"/>`);
                        const dayStr = dateObj.toLocaleDateString('es-ES', { day: '2-digit' });
                        const monthStr = SHORT_MONTH_NAMES[dateObj.getMonth()];
                        const dayNameStr = WEEK_DAY_NAMES[dateObj.getDay()].substring(0,3); // e.g., Lun
                        const dayNumberY = currentGlobalY + dayHeaderHeightWeekly * 0.38 + textYAdjust * 0.7;
                        const weekDayY = currentGlobalY + dayHeaderHeightWeekly * 0.72 + textYAdjust * 0.7;
                        svgElements.push(`<text x="${tableHeaderX + cellWidthWeekly/2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${dateFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${dayStr} ${monthStr}</text>`);
                        svgElements.push(`<text x="${tableHeaderX + cellWidthWeekly/2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${dayNameFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${dayNameStr}</text>`);
                        tableHeaderX += cellWidthWeekly;
                    });
                    currentGlobalY += dayHeaderHeightWeekly;

                    // Employee Rows for this week
                    employeeNamesOrdered.forEach((empName, rowIndex) => {
                        const rowY = currentGlobalY + rowIndex * cellHeight;
                        let currentCellX = padding;
                        svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#d1d5db"/>`);
                        svgElements.push(`<text x="${currentCellX + employeeColWidth/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
                        currentCellX += employeeColWidth;

                        week.forEach(dateObj => {
                            const day = dateObj.getDate(); const month = dateObj.getMonth() + 1; // 1-indexed month
                            let shift = scheduleData[empName]?.[month]?.[day] || "";
                            const shiftTimeConfig = currentUserShiftTimes[shift];
                            let displayShift = shift;
                            // For M, T, N shifts, display times if configured
                            if (shiftTimeConfig && (shift === 'M' || shift === 'T' || shift === 'N')) {
                                displayShift = `${formatTimeForInput(shiftTimeConfig.start[0], shiftTimeConfig.start[1])}-${formatTimeForInput(shiftTimeConfig.end[0], shiftTimeConfig.end[1])}`;
                            }

                            const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${cellWidthWeekly}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#d1d5db"/>`);
                            if (displayShift) {
                                svgElements.push(`<text x="${currentCellX + cellWidthWeekly/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${displayShift}</text>`);
                            }
                            currentCellX += cellWidthWeekly;
                        });
                    });
                    currentGlobalY += (employeeNamesOrdered.length * cellHeight) + tableSpacing; // Space before next week
                });
                 svgHeight = currentGlobalY - tableSpacing + padding / 2; // Adjust total height
                 svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);
            }
            return `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="font-family: 'Inter', sans-serif;">${svgElements.join('')}</svg>`;
        }

        function getWeeksForMonth(year, month) { // month is 1-12
            const weeks = [];
            const firstDateOfMonth = new Date(year, month - 1, 1);
            const lastDateOfMonth = new Date(year, month, 0); // Day 0 of next month is last day of current

            let currentDate = new Date(year, month - 1, 1); // Start with the 1st of the month

            // Adjust currentDate to the start of the week (Monday) it belongs to
            let dayOfWeek = currentDate.getDay(); // Sunday is 0, Monday is 1...
            let diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Calculate diff to get to Monday
            currentDate.setDate(currentDate.getDate() + diffToMonday);


            while (currentDate <= lastDateOfMonth || weeks.length === 0 || (weeks.length > 0 && weeks[weeks.length-1][0] <= lastDateOfMonth) ) {
                const week = [];
                for (let i = 0; i < 7; i++) {
                    week.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                // Add week only if it contains any day from the target month OR if it's the first week and starts before the month
                 if (week.some(d => d.getFullYear() === year && d.getMonth() === month - 1) ||
                    (weeks.length === 0 && week[0] <= firstDateOfMonth) ) {
                     weeks.push(week);
                 } else if (week[0] > lastDateOfMonth) { // Stop if the new week starts after the month ends
                     break;
                 }


                if (weeks.length > 6 && currentDate > lastDateOfMonth) break; // Safety break for very long months / edge cases
            }
            return weeks;
        }


        function showExportToCalendarModal() {
            if (currentViewMode !== 'monthly' || !isDataLoadedForStats()) {
                showToast('Exportación a Calendar: vista mensual y datos cargados requeridos.', 'warning'); return;
            }
            if (employeeNamesOrdered.length === 0) {
                showToast('No hay empleados para seleccionar.', 'info'); return;
            }
            populateEmployeeSelects(domCache.modalCalendarEmployeeSelect);
            showModal(domCache.exportCalendarModal, domCache.modalCalendarEmployeeSelect);
        }
        function updateCalendarExportButtonsState() {
            const dataExistsAndMonthlyView = isDataLoadedForStats() && currentViewMode === 'monthly';
            domCache.exportMonthCalendarButton.disabled = !dataExistsAndMonthlyView;
            if (domCache.downloadWeeklySvgButton) {
                 domCache.downloadWeeklySvgButton.disabled = !dataExistsAndMonthlyView;
            }
        }
        const formatForICalTimezone = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            const H = String(date.getHours()).padStart(2, '0'), M = String(date.getMinutes()).padStart(2, '0'), S = String(date.getSeconds()).padStart(2, '0');
            return `${y}${m}${d}T${H}${M}${S}`;
        };
        const formatDateForICalAllDay = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            return `${y}${m}${d}`;
        };
        function exportToCalendar(selectedEmployeeForCalendar) {
            let icalFilenameBase = generateDefaultFilename('calendar', selectedEmployeeForCalendar);
            const firstDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth - 1, 1);
            const lastDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth, 0);
            let icalContent = [
                'BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//NefiBadillo//GestorHorariosLaborales//ES',
                `X-WR-CALNAME:Horario ${selectedEmployeeForCalendar} - ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`
            ];
            const empName = selectedEmployeeForCalendar;
            if (!scheduleData[empName]) { showToast(`No hay datos para ${empName}.`, 'error'); return; }
            let currentDateIter = new Date(firstDayOfMonth);
            while(currentDateIter <= lastDayOfMonth) {
                const day = currentDateIter.getDate(), currentIterMonth = currentDateIter.getMonth() + 1, currentIterYear = currentDateIter.getFullYear();
                let shiftType = scheduleData[empName]?.[currentIterMonth]?.[day];
                if (shiftType === undefined || shiftType === null) shiftType = "";
                if (shiftType !== undefined) {
                    const shiftTimeConfig = currentUserShiftTimes[shiftType];
                    const isKnownShift = SHIFT_TYPE_FULL_NAMES[shiftType];
                    if (isKnownShift || (shiftType && !isKnownShift) || shiftType === "") {
                        const dtStamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15) + 'Z';
                        const uidSuffix = shiftType || 'otro';
                        const uid = `${formatDateForICalAllDay(currentDateIter)}-${empName.replace(/\s+/g, '')}-${uidSuffix}@gestorhorarios.com`;
                        icalContent.push('BEGIN:VEVENT', `UID:${uid}`, `DTSTAMP:${dtStamp}`);
                        let summaryText = shiftType === "" ? `Otro - ${empName}` : (isKnownShift ? `Turno ${SHIFT_TYPE_FULL_NAMES[shiftType]} (${shiftType}) - ${empName}` : `${shiftType} - ${empName}`);
                        icalContent.push(`SUMMARY:${summaryText}`, `DESCRIPTION:Horario laboral: ${summaryText}.`, `LOCATION:Gran Hotel Miramar`, `STATUS:CONFIRMED`);
                        if (!shiftTimeConfig || shiftType === 'L' || shiftType === 'V' || shiftType === "") {
                            const eventDate = new Date(currentIterYear, currentIterMonth - 1, day);
                            const startDateAllDay = formatDateForICalAllDay(eventDate);
                            eventDate.setDate(eventDate.getDate() + 1);
                            const endDateAllDay = formatDateForICalAllDay(eventDate);
                            icalContent.push(`DTSTART;VALUE=DATE:${startDateAllDay}`, `DTEND;VALUE=DATE:${endDateAllDay}`, `TRANSP:OPAQUE`);
                        } else {
                            let startDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.start[0], shiftTimeConfig.start[1]);
                            let endDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.end[0], shiftTimeConfig.end[1]);
                            if (shiftTimeConfig.nextDayEnd) endDateEvent.setDate(endDateEvent.getDate() + 1);
                            icalContent.push(`DTSTART;TZID=Europe/Madrid:${formatForICalTimezone(startDateEvent)}`, `DTEND;TZID=Europe/Madrid:${formatForICalTimezone(endDateEvent)}`, `TRANSP:OPAQUE`);
                        }
                        icalContent.push('END:VEVENT');
                    }
                }
                currentDateIter.setDate(currentDateIter.getDate() + 1);
            }
            icalContent.push('END:VCALENDAR');
            if (icalContent.length <= 4) {
                 showToast(`No hay eventos programados para ${selectedEmployeeForCalendar} en ${MONTH_NAMES[currentSelectedMonth - 1]}.`, 'info'); return;
            }
            const blob = new Blob([icalContent.join('\r\n')], { type: 'text/calendar;charset=utf-8;' });
            const link = createElement("a", { attributes: { href: URL.createObjectURL(blob), download: `${icalFilenameBase}.ics` }, style: { visibility: 'hidden' } });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Archivo Calendar (.ics) generado para ${selectedEmployeeForCalendar}.`, 'success');
        }

        function showAddEmployeeModal() {
            domCache.modalEmployeeNameInput.value = '';
            showModal(domCache.addEmployeeModal, domCache.modalEmployeeNameInput);
        }
        function handleAddEmployeeFromModal() {
            const newName = domCache.modalEmployeeNameInput.value.trim();
            if (!newName) { showToast('Introduce un nombre.', 'error'); domCache.modalEmployeeNameInput.focus(); return; }
            if (employeeNamesOrdered.includes(newName)) { showToast(`"${newName}" ya existe.`, 'error'); domCache.modalEmployeeNameInput.focus(); return; }

            saveStateForUndo(`Empleado "${newName}" añadido.`); // Save state before change

            employeeNamesOrdered.push(newName);
            if (!scheduleData[newName]) {
                 scheduleData[newName] = {};
                 for (let m = 1; m <= 12; m++) scheduleData[newName][m] = {};
            }
            hideModal(domCache.addEmployeeModal);
            handleViewChange();
            if (isDataLoadedForStats()) calculateAndRenderComparativeStats();
            // addChangeToHistory is called by saveStateForUndo
            // hasUnsavedChanges and button states are handled by saveStateForUndo
            showToast(`Empleado "${newName}" añadido.`, 'success');
            enableControls(true);
        }

        function promptDeleteEmployee(employeeName) {
            employeeToDeleteName = employeeName;
            domCache.employeeNameToDeleteSpan.textContent = employeeName;
            domCache.modalConfirmDeleteEmployee.disabled = true;
            let countdown = 5;
            domCache.deleteCountdownMessageSpan.textContent = `Botón activo en ${countdown}s...`;
            if (deleteCountdownInterval) clearInterval(deleteCountdownInterval);
            deleteCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) domCache.deleteCountdownMessageSpan.textContent = `Botón activo en ${countdown}s...`;
                else {
                    clearInterval(deleteCountdownInterval);
                    domCache.deleteCountdownMessageSpan.textContent = '¡Botón de eliminar activo!';
                    domCache.modalConfirmDeleteEmployee.disabled = false;
                }
            }, 1000);
            showModal(domCache.deleteEmployeeModal);
        }
        function confirmEmployeeDeletion() {
            if (employeeToDeleteName) {
                saveStateForUndo(`Empleado "${employeeToDeleteName}" eliminado.`); // Save state before change

                const index = employeeNamesOrdered.indexOf(employeeToDeleteName);
                if (index > -1) employeeNamesOrdered.splice(index, 1);
                delete scheduleData[employeeToDeleteName];
                handleViewChange();
                if (isDataLoadedForStats()) calculateAndRenderComparativeStats();
                else updateStatsDisplayForNoData();
                // addChangeToHistory is called by saveStateForUndo
                // hasUnsavedChanges and button states are handled by saveStateForUndo
                showToast(`Empleado "${employeeToDeleteName}" eliminado.`, 'success');
                if (!isDataLoadedForStats()) {
                    resetToInitialState(true);
                }
            }
            hideModal(domCache.deleteEmployeeModal, () => {
                 if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
            });
        }

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Horarios Laborales para Gran Hotel Miramar</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📆</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Times+New+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.1/dist/svg2pdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> 
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Tailwind gray-100 (original) / #f0f2f5 (prototype) - Kept original for now */
        }
        #logo-container svg {
            width: 200px;
            height: auto;
            margin-bottom: 0.75rem;
        }
        .table-container {
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0 0 0.375rem 0.375rem;
        }
        .sticky-col {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 10;
        }
        .draggable-row.bg-white > .sticky-col,
        .draggable-row > .sticky-col.employee-name-cell {
            background-color: #ffffff !important;
        }
        .draggable-row.bg-gray-50 > .sticky-col {
             background-color: #f9fafb !important; /* Tailwind bg-gray-50 */
        }

        .sticky-col-header {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 30;
            background-color: #f9fafb; /* gray-50 */
        }
        .sticky-header th {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            background-color: #f9fafb; /* gray-50 */
            z-index: 20;
        }
        .shift-cell {
            padding: 0.5rem 0.25rem;
            text-align: center;
            white-space: nowrap;
            font-size: 0.75rem;
            font-weight: 500;
            border-right: 1px solid #f3f4f6; /* gray-100 */
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .shift-cell:last-child {
            border-right: none;
        }
        .cell-selected {
            outline: 2px dashed #4f46e5; /* indigo-600 */
            outline-offset: -2px;
            background-color: #e0e7ff !important; /* indigo-100 */
        }

        .hidden-by-default {
            display: none !important;
        }

        .view-toggle-button {
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .view-toggle-button.active {
            background-color: #4f46e5;
            color: white;
            box-shadow: 0 4px 6px -1px rgba(79,70,229,0.3), 0 2px 4px -1px rgba(79,70,229,0.2);
        }
        .view-toggle-button:not(.active) {
            background-color: #e5e7eb;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        .view-toggle-button:not(.active):hover {
            background-color: #d1d5db;
            border-color: #9ca3af;
        }
        .action-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        }
        .action-button:hover {
            opacity: 0.9;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .action-button:hover .fa-sync-alt { /* Animación existente para el botón de actualizar estadísticas */
            animation: fa-spin 1.5s linear infinite;
        }
        @keyframes fa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .notes-textarea {
            min-height: 150px;
            flex-grow: 1;
        }
        .day-header-date {
            display: block;
            font-weight: 600;
        }
        .day-header-weekday {
            display: block;
            font-size: 0.7rem;
            color: #6b7280;
            font-weight: 400;
        }
        .month-tabs-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
        }
        .month-tab {
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            background-color: #f9fafb;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
        }
        .month-tab:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
        }
        .month-tab.active {
            background-color: #4f46e5;
            color: white;
            border-color: #4f46e5;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(79, 70, 229, 0.2);
            font-size: 0.85rem;
        }
        .color-palette-popup {
            position: absolute;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            padding: 0.75rem;
            z-index: 50;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.375rem;
            width: auto;
            min-width: 260px;
        }
        .palette-color-swatch {
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.25rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s ease-in-out, border-color 0.1s;
        }
        .palette-color-swatch:hover {
            transform: scale(1.1);
            border-color: #4f46e5;
        }
        .legend-item-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }
        .legend-color-swatch {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
            border: 1px solid #9ca3af;
            cursor: pointer;
            transition: transform 0.1s;
            flex-shrink: 0;
        }
        .legend-color-swatch:hover {
            transform: scale(1.15);
        }
        .legend-time-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-left: 0.5rem;
        }
        .legend-time-inputs input[type="time"] {
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.25rem 0.375rem;
            font-size: 0.75rem;
            width: 75px;
        }
        .legend-item-flash .legend-color-swatch {
            animation: swatch-flash 0.7s ease-out;
        }
        .legend-item-flash .legend-time-inputs input {
            animation: input-flash 0.7s ease-out;
        }
        @keyframes swatch-flash {
            0%, 100% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.15); box-shadow: 0 0 10px rgba(79, 70, 229, 0.6); }
        }
        @keyframes input-flash {
            0%, 100% { border-color: #d1d5db; }
            50% { border-color: #4f46e5;  box-shadow: 0 0 5px rgba(79, 70, 229, 0.4);}
        }

        #history-section, #notes-section, #legend-section { /* Removed #statistics-section from this rule */
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 7px 20px -4px rgba(0,0,0,0.06), 0 4px 8px -3px rgba(0,0,0,0.04);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
        /* Styles for the new statistics section, if it's separate */
        #statistics-section-reformed { /* New ID for the main container of new stats */
             /* Basic styling, can be enhanced. The prototype uses .stats-section */
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }
        .section-title i {
            margin-right: 0.75rem;
            color: #4f46e5;
        }
        #legend-section .section-title {
            flex-grow: 1;
        }
        #legend-section .flex-shrink-0 {
            margin-left: auto;
        }


        #change-history-list-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            background-color: #f9fafb;
            min-height: 150px;
            max-height: 250px;
        }
        #change-history-list li {
            padding: 0.375rem 0.25rem;
            font-size: 0.8rem;
            color: #4b5563;
            border-bottom: 1px solid #f3f4f6;
        }
        #change-history-list li:last-child {
            border-bottom: none;
        }
        #change-history-list li .history-time {
            font-weight: 500;
            color: #1f2937;
            margin-right: 0.375rem;
        }
        #multiselect-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #374151;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            z-index: 100;
            gap: 0.5rem;
        }
        #multiselect-toolbar:not(.hidden-by-default) {
            display: flex;
        }
        #multiselect-toolbar.hidden-by-default {
             display: none !important;
        }
        #multiselect-toolbar button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #multiselect-toolbar button:hover {
            background-color: #4338ca;
        }
        #multiselect-toolbar button.other-selection {
            background-color: #6b7280;
        }
        #multiselect-toolbar button.other-selection:hover {
            background-color: #4b5563;
        }
        /* ESTILOS PARA EL ICONO DE AYUDA Y SU MODAL - INICIO */
        #help-icon-container i {
            transition: transform 0.2s ease-in-out, color 0.2s ease-in-out;
        }

        #help-icon-container:hover i {
            transform: scale(1.2);
            color: #facc15; /* Tailwind yellow-500, un poco más brillante */
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.7); /* Efecto de brillo */
        }

        #current-month-year-display {
            padding-right: 4rem; /* Asegura espacio para el icono de ayuda */
        }
        #help-icon-container {
            top: 50%; /* Centra verticalmente respecto al h2 */
            right: 1rem; /* Espacio desde la derecha */
            transform: translateY(-50%); /* Ajuste fino para centrar verticalmente */
        }

        /* Estilos para la modal de Consejos */
        #tips-modal .modal-content {
			max-width: 42rem;
			background-color: #f9fafb;
			border-radius: 0.75rem;
			box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
			padding: 1.5rem;
			width: 90%;
			max-height: 85vh;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			margin-bottom: 5vh;
        }

        #tips-modal h3 {
            font-family: 'Inter', sans-serif;
        }

        #tips-modal h4 {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            margin-top: 0.75rem;
        }

        #tips-modal ul {
            margin-left: 1rem;
        }

        #tips-modal li {
            margin-bottom: 0.375rem;
        }

        #tips-modal code {
            background-color: #e0e7ff;
            color: #3730a3;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.85em;
            font-family: 'Courier New', Courier, monospace;
        }
        /* ESTILOS PARA EL ICONO DE AYUDA Y SU MODAL - FIN */
        .employee-name-cell {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
        }
        .employee-name-display {
             cursor: grab;
             flex-grow: 1;
        }
        .employee-name-cell:hover .edit-icon, .employee-name-cell:hover .delete-employee-icon {
            opacity: 1;
        }
        .edit-icon, .delete-employee-icon {
            opacity: 0.3;
            margin-left: 8px;
            font-size: 0.9em;
            transition: opacity 0.2s;
            cursor: pointer;
        }
        .delete-employee-icon:hover {
            color: #ef4444;
        }
        .draggable-row.dragging {
            opacity: 0.4;
            background: #c7d2fe;
        }
        .drag-over-indicator {
            height: 3px;
            background-color: #4f46e5;
            margin: -1px 0;
        }
        .modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-start; /* Alinea los modales arriba para permitir scroll */
            justify-content: center;
            z-index: 1000;
            padding: 1rem; /* Espacio alrededor para que no pegue a los bordes */
			overflow-y: auto; /* Permite scroll en el overlay si el modal es muy alto */
            padding-top: 5vh; /* Un poco de margen superior */
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            width: 100%;
            max-width: 28rem; /* Default max-width, can be overridden */
        }
        .unsaved-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #ef4444;
            border-radius: 50%;
            margin-left: 0.5rem;
            vertical-align: middle;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .unsaved-dot.hidden-by-default {
            opacity: 0;
            transform: scale(0);
        }

        .add-employee-row-reformed {
            border-top: 1px dashed #d1d5db;
        }

        .add-employee-cell-reformed {
            padding: 0.75rem;
            text-align: left;
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background-color: #f9fafb;
            z-index: 10;
        }

        .add-employee-button-visual {
            display: inline-flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.55rem 0.9rem;
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
        }

        .add-employee-button-visual:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
            color: #1f2937;
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 4px 8px -1px rgba(0,0,0,0.07), 0 2px 4px -1px rgba(0,0,0,0.04);
        }

        .add-employee-button-visual:active {
            transform: translateY(0px) scale(0.99);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }

        .add-employee-button-visual i {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.85em;
        }

        .add-employee-button-visual:hover i {
            transform: rotate(135deg) scale(1.1);
            color: #4f46e5;
        }

        .add-employee-empty-cell-reformed {
            padding: 0.5rem 1rem;
            background-color: #f9fafb;
            border-right: 1px solid #f3f4f6;
            height: 54px;
        }
        .add-employee-empty-cell-reformed:last-child {
            border-right: none;
        }

        */

        .footer-name {
            transition: opacity 0.5s ease-in-out, color 0.5s ease-in-out;
            cursor: pointer;
        }
        .footer-name.hidden-name {
            opacity: 0;
            color: #4f46e5;
        }
        .footer-name.visible-name {
            opacity: 1;
            color: inherit;
        }

        /* === INICIO: ANIMACIONES PARA BOTONES === */
        @keyframes button-shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        #save-local-button:hover {
            animation: button-shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes icon-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        #create-empty-csv-button:hover .fa-file-alt {
            animation: icon-pulse 0.6s ease-in-out;
        }

        @keyframes icon-jiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
        }
        #export-csv-button:hover .fa-file-csv {
            animation: icon-jiggle 0.4s ease-in-out;
        }

        @keyframes icon-download {
            0% { transform: translateY(0); }
            50% { transform: translateY(3px); }
            100% { transform: translateY(0); }
        }
        #download-weekly-svg-button:hover .fa-file-pdf,
        #download-image-button:hover .fa-file-pdf {
            animation: icon-download 0.5s ease-in-out;
        }

        #export-month-calendar-button:hover .fa-calendar-plus::after {
            content: '+';
            display: inline-block;
            animation: plus-grow 0.3s ease-out forwards;
            transform-origin: center;
        }
        @keyframes plus-grow {
            0% { transform: scale(1); }
            100% { transform: scale(1.3); }
        }
        .view-toggle-button:not(.active):hover i {
            transform: scale(1.15);
            color: #3730a3;
            transition: transform 0.2s, color 0.2s;
        }
        .view-toggle-button.active i {
             transform: scale(1.1);
        }
        /* === FIN: ANIMACIONES PARA BOTONES === */

            }
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* === INICIO: ESTILOS DEL PROTOTIPO DE ESTADÍSTICAS (GestorHorario-Graficos.html) === */
        /* El body del prototipo usa #f0f2f5, el original #f3f4f6. Se mantiene el original por ahora. */
        .stats-section { /* Clase principal del prototipo para cada bloque de estadísticas */
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        .stats-section h2.section-main-title { /* Título principal dentro de .stats-section */
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
        }
        .stats-section h3.chart-title { /* Título para cada gráfico individual */
            font-size: 1.125rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
        }
        .table-header-controls { /* Contenedor para título de tabla y dropdown de mes */
            display: flex;
            flex-direction: column; /* Apilar en móvil por defecto */
            align-items: flex-start; /* Alinear a la izquierda en móvil */
            gap: 0.5rem; /* Espacio entre título y selector */
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        @media (min-width: 640px) { /* sm breakpoint de Tailwind */
            .table-header-controls {
                flex-direction: row; /* Fila en pantallas más grandes */
                align-items: center;
                justify-content: space-between;
            }
        }
        .table-wrapper { /* Para scroll horizontal en la tabla */
            overflow-x: auto;
        }
        /* Estilos para la tabla de estadísticas del prototipo */
        #stats-table-head th { /* Cabecera de la nueva tabla */
            background-color: #f9fafb;
            color: #374151;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.75rem 1rem;
            text-align: left;
            white-space: nowrap;
        }
        #stats-table-head th i { /* Iconos en la cabecera */
            margin-right: 0.375rem;
        }
        #tbody-idea1-expanded td { /* Celdas del cuerpo de la nueva tabla */
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.875rem;
            white-space: nowrap;
            text-align: center;
        }
        #tbody-idea1-expanded td.employee-name-cell { /* Celda de nombre de empleado en la nueva tabla */
            text-align: left;
            font-weight: 500;
            color: #1f2937;
            background-color: white !important; /* Para asegurar que sea blanco incluso en hover de fila */
        }
        #tbody-idea1-expanded tr:last-child td {
            border-bottom: none;
        }
        #tbody-idea1-expanded tr:hover {
            background-color: #f3f4f6;
            cursor: pointer;
        }
         #tbody-idea1-expanded tr:hover td.employee-name-cell { /* Celda de nombre en hover */
             background-color: white !important; /* Mantener blanco */
        }

        .kpi-card {
            background-color: white;
            border-radius: 0.375rem;
            padding: 0.5rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            border: 1px solid #e5e7eb;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 70px;
        }
        .kpi-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: #111827;
            line-height: 1.2;
        }
        .kpi-label {
            font-size: 0.65rem;
            color: #6b7280;
            line-height: 1.1;
        }

        .individual-charts-container, .general-stats-content { /* Contenedores punteados del prototipo */
            border: 2px dashed #cbd5e1;
            padding: 1.5rem;
            border-radius: 0.5rem;
        }
        .chart-container { /* Contenedor para cada canvas de Chart.js */
            background-color: #f9fafb;
            padding: 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            position: relative;
            min-height: 280px;
        }
        .chart-canvas { /* Clase para los canvas */
            max-width: 100%;
            width: 100% !important;
            height: auto !important;
            margin: auto;
        }
        #normalBarChartCanvas { /* Ajustes específicos de altura del prototipo */
            max-height: 200px;
        }
        #donutChartCanvas {
            max-height: 180px;
        }
        #generalStackedBarCanvas, #generalGroupedBarCanvas {
            max-height: 280px;
            min-height: 200px; /* Para asegurar espacio en móvil */
        }
         @media (max-width: 767px) { /* Ajustes responsivos para gráficos del prototipo */
            #generalStackedBarCanvas, #generalGroupedBarCanvas {
                max-height: 250px; /* Menos altura en móvil */
            }
            .chart-container {
                min-height: 200px; /* Reducir altura mínima en móvil */
            }
        }

        .mini-calendar-heatmap {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
            max-width: 220px;
            margin: 0.25rem auto 0;
        }
        .calendar-header-day, .calendar-day {
            width: 28px; height: 28px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        .calendar-header-day {
            font-weight: 600;
            color: #4b5563;
        }
        .calendar-day.empty {
            background-color: transparent;
            border: none;
        }

        .month-dropdown-container {
            position: relative;
            display: inline-block;
        }
        .month-dropdown-button {
            background-color: white;
            color: #374151;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            transition: background-color 0.2s;
        }
        .month-dropdown-button:hover {
            background-color: #f9fafb;
        }
        .month-dropdown-button i {
            margin-left: 0.5rem;
            transition: transform 0.2s;
        }
        /* .month-dropdown-button.open i {  JS controlará esto, clase 'open' no usada en prototipo directamente en HTML */
        /* transform: rotate(180deg); */
        /* } */
        .month-dropdown-content {
            display: none; /* Controlado por JS con clase 'show' */
            position: absolute;
            background-color: white;
            min-width: 180px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.1);
            z-index: 10; /* Asegurar que esté sobre otros elementos */
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            max-height: 300px;
            overflow-y: auto;
            right: 0; /* Alineado a la derecha del botón */
        }
        .month-dropdown-content.show { /* Clase para mostrar el dropdown */
            display: block;
        }
        .month-dropdown-content a {
            color: #374151;
            padding: 0.75rem 1rem;
            text-decoration: none;
            display: block;
            font-size: 0.875rem;
        }
        .month-dropdown-content a:hover {
            background-color: #f3f4f6;
        }
         .month-dropdown-content a.active { /* Para el mes activo en el dropdown */
            background-color: #4f46e5;
            color: white;
        }
        .details-header-controls { /* Contenedor para controles en la cabecera de detalles */
            display: flex;
            flex-wrap: wrap; /* Permitir que los elementos se envuelvan en móvil */
            align-items: center;
            gap: 0.75rem;
        }
        .close-details-button { /* Botón para cerrar vistas de detalle/generales */
            background-color: #ef4444; /* Rojo */
            color: white;
            padding: 0.625rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .close-details-button:hover {
            background-color: #dc2626; /* Rojo más oscuro */
            transform: translateY(-1px);
        }
         .close-details-button:active {
            transform: translateY(0px);
        }
        .close-details-button i {
            margin-right: 0.375rem;
        }
        .general-stats-content {
            /* Tus estilos existentes: grid grid-cols-1 gap-8; */
            max-width: 100rem; /* Un buen punto de partida, equivale a 896px. ¡Ajusta si lo necesitas! */
            margin-left: auto;
            margin-right: auto;
        }
        /* === FIN: ESTILOS DEL PROTOTIPO DE ESTADÍSTICAS === */

/* === INICIO: ESTILOS PARA ADAPTACIÓN MÓVIL DE TABLAS === */
		@media (max-width: 767px) {

			/* --- Tabla de Estadísticas (#stats-table-head, #tbody-idea1-expanded) --- */
			/* .table-wrapper para la tabla de estadísticas ya tiene overflow-x: auto */

			#stats-table-head th {
				font-size: 0.7rem; /* Reducido */
				padding: 0.5rem 0.4rem; /* Reducido */
				white-space: normal; /* Permitir que el texto de la cabecera se ajuste */
				text-align: center; /* Centrar cabeceras para ahorrar espacio */
				line-height: 1.1;
			}
			#stats-table-head th:first-child { /* Cabecera "Empleado" de la tabla de stats */
				text-align: left; /* Mantener alineación izquierda para el nombre */
				padding-left: 0.5rem;
				min-width: 90px; /* Ancho mínimo para la columna de empleado */
			}

			#tbody-idea1-expanded td {
				font-size: 0.75rem; /* Reducido */
				padding: 0.4rem 0.3rem; /* Reducido */
				line-height: 1.3;
			}

			#tbody-idea1-expanded td.employee-name-cell { /* Celda de nombre en tabla de stats */
				font-size: 0.75rem;
				padding-left: 0.5rem;
				max-width: 90px; /* Limitar ancho del nombre del empleado */
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			/* --- Ajustes específicos para la Vista Anual en Móvil --- */
			/* La clase 'annual-view-active' se añade al body mediante JavaScript */
			body.annual-view-active #schedule-table .shift-cell {
				font-size: 0.6rem; /* Aún más pequeño para la densa vista anual */
				padding: 0.3rem 0.1rem; /* Padding mínimo */
				min-width: 28px; /* Ancho mínimo muy ajustado */
			}
			body.annual-view-active #schedule-table-head .day-header-date,
			body.annual-view-active #schedule-table-head .day-header-weekday {
				font-size: 0.55rem; /* Fuentes de cabecera muy pequeñas */
			}
			body.annual-view-active #schedule-table-head .sticky-col-header,
			body.annual-view-active #schedule-table .employee-name-cell {
				font-size: 0.7rem; /* Nombre de empleado ligeramente más pequeño en anual */
			}
			body.annual-view-active #schedule-table .employee-name-cell .employee-name-display {
				max-width: 70px; /* Aún más corto para nombres en vista anual */
			}
		/* === FIN: ESTILOS PARA ADAPTACIÓN MÓVIL DE TABLAS === */
		
		/* === INICIO: ESTILOS PARA ADAPTACIÓN MÓVIL DE LA BARRA DE TURNOS === */
			#multiselect-toolbar {
				/* Permitir que los botones se envuelvan en múltiples líneas */
				flex-wrap: wrap;
				justify-content: center; /* Centrar los botones si se envuelven */

				/* Ajustar el ancho máximo para que no exceda la pantalla con paddings */
				width: calc(100% - 40px); /* 100% del viewport menos algo de padding lateral */
				max-width: 400px; /* Un máximo razonable para que no sea demasiado ancha incluso en móviles grandes */
        
				/* Opcional: reducir el padding vertical de la barra si es necesario */
				padding-top: 0.5rem;    /* Reducido desde 0.75rem */
				padding-bottom: 0.5rem; /* Reducido desde 0.75rem */
        
				/* Ajustar el 'gap' si es necesario para líneas envueltas */
				gap: 0.375rem; /* Reducido desde 0.5rem */
			}

			#multiselect-toolbar button {
				/* Reducir ligeramente el padding y tamaño de fuente de los botones */
				padding: 0.4rem 0.6rem; /* Reducido desde 0.5rem 0.75rem */
				font-size: 0.8rem;    /* Reducido desde 0.875rem */
        
				/* Opcional: añadir un pequeño margen inferior si se envuelven mucho */
				margin-bottom: 0.25rem; 
			}
		}
		/* === FIN: ESTILOS PARA ADAPTACIÓN MÓVIL DE LA BARRA DE TURNOS === */

    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto max-w-full">
        <header class="mb-10 text-center">
            <div id="logo-container" class="flex justify-center mb-3">
                </div>
            <h1 id="main-title-text" class="text-4xl md:text-5xl font-bold text-gray-800 tracking-tight inline-block"></i>Gestor de Horarios Laborales
            </h1>
        </header>

        <section id="controls-section" class="mb-8 p-6 bg-white rounded-xl shadow-xl">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 items-end">
                <div>
                    <label for="csv-file-input" class="block text-sm font-medium text-gray-700 mb-1">Importar Horario (CSV):</label>
                    <input type="file" id="csv-file-input" accept=".csv" class="w-full text-sm text-gray-500
                        file:mr-4 file:py-2.5 file:px-4 file:cursor-pointer
                        file:rounded-lg file:border-0
                        file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700
                        hover:file:bg-indigo-100 transition-colors
                    "/>
                    <button id="create-empty-csv-button" class="action-button w-full mt-2 bg-sky-600 text-white hover:bg-sky-700 focus:ring-2 focus:ring-sky-500 focus:ring-offset-2">
                        <i class="fas fa-file-alt mr-2"></i>Nuevo Horario Vacío
                    </button>
                </div>
                <div>
                    <label for="year-input" class="block text-sm font-medium text-gray-700 mb-1">Año del Horario:</label>
                    <input type="number" id="year-input" value="2026" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                 <div class="lg:col-start-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                    <div class="flex items-center gap-2 flex-1">
                        <button id="save-local-button" title="Guarda el horario actual, las notas y la configuración de colores en el almacenamiento local de tu navegador." class="action-button flex-1 bg-green-600 text-white hover:bg-green-700 focus:ring-2 focus:ring-green-500 focus:ring-offset-2" disabled>
                            <i class="fas fa-save"></i>Guardar Local
                        </button>
                        <i id="save-local-help-icon" class="fas fa-question-circle text-gray-500 hover:text-indigo-600 cursor-pointer text-xl" title="Ayuda sobre Guardado Local"></i>
                    </div>
                    <button id="export-csv-button" class="action-button flex-1 bg-blue-600 text-white hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-csv"></i>Exportar CSV
                    </button>
                </div>
            </div>

             <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-4 items-end mt-4">
                <div class="md:col-span-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                     <button id="export-month-calendar-button" class="action-button flex-1 bg-orange-500 text-white hover:bg-orange-600 focus:ring-2 focus:ring-orange-400 focus:ring-offset-2" disabled>
                        <i class="fas fa-calendar-plus mr-2"></i>Exportar Mes a Calendar
                    </button>
                    <button id="download-weekly-svg-button" class="action-button flex-1 bg-teal-600 text-white hover:bg-teal-700 focus:ring-2 focus:ring-teal-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Semanal PDF
                    </button>
                    <button id="download-image-button" class="action-button flex-1 bg-purple-600 text-white hover:bg-purple-700 focus:ring-2 focus:ring-purple-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Calendario PDF
                    </button>
                </div>
            </div>

            <div id="view-mode-buttons-container" class="mt-4 flex justify-center gap-3 border-t border-gray-200 pt-4 hidden-by-default">
                <button id="view-monthly-button" class="view-toggle-button active"><i class="fas fa-calendar-day mr-2"></i>Vista Mensual</button>
                <button id="view-annual-button" class="view-toggle-button"><i class="fas fa-calendar-alt mr-2"></i>Vista Anual</button>
            </div>
             <div class="mt-4 pt-4 border-t border-gray-200 flex items-center justify-end">
                <label for="autosave-toggle" class="flex items-center cursor-pointer">
                    <span class="mr-3 text-sm font-medium text-gray-700">Autoguardado local (30s):</span>
                    <div class="relative">
                        <input type="checkbox" id="autosave-toggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:bg-indigo-600 transition-colors"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>
            </section>

        <section id="welcome-message" class="my-8 p-8 bg-indigo-50 text-indigo-700 rounded-xl shadow-lg text-center">
            <i class="fas fa-info-circle fa-2x mb-3"></i>
            <p class="text-lg">Bienvenido/a al Gestor de Horarios.</p>
            <p class="text-sm">Por favor, importa un archivo CSV, aplica una plantilla vacía o carga datos guardados localmente para comenzar.</p>
        </section>

        <main id="schedule-display-section" class="hidden-by-default">
             <div id="month-tabs-container" class="month-tabs-container">
                </div>

            <section id="schedule-table-section" class="bg-white rounded-xl shadow-xl overflow-hidden">
                <h2 id="current-month-year-display" class="text-2xl font-bold text-gray-800 p-5 border-b border-gray-200 bg-gray-50 rounded-t-xl relative">
                    <span id="current-month-year-text">Horario para [Mes Año]</span>
                    <span id="unsaved-indicator-table" class="unsaved-dot hidden-by-default" title="Hay cambios sin guardar"></span>
                    <span id="help-icon-container" class="absolute top-0 right-0 p-3 cursor-pointer" title="Mostrar Consejos Útiles">
                        <i class="fas fa-lightbulb text-gray-500 text-2xl"></i>
                    </span>
                </h2>
                <div class="table-container">
                    <table id="schedule-table" class="min-w-full divide-y divide-gray-200">
                        <thead id="schedule-table-head" class="bg-gray-50 sticky-header"></thead>
                        <tbody id="schedule-table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <div id="no-data-message" class="p-8 text-center text-gray-500 text-lg hidden-by-default">
                    <i class="fas fa-folder-open fa-2x mb-3 text-gray-400"></i><br>
                    No hay datos de horario para mostrar. Importa un archivo CSV, aplica una plantilla vacía o añade empleados.
                </div>
            </section>

            <div class="mt-10 grid grid-cols-1 lg:grid-cols-4 gap-8">
                <section id="statistics-section" class="lg:col-span-4">
                    <section class="stats-section" id="idea1-table-improved-expanded">
                        <div class="table-header-controls">
                            <h2 class="text-xl font-semibold section-main-title">Tabla Comparativa de Empleados</h2>
                            <div class="month-dropdown-container" id="main-month-dropdown-container">
                                <button id="month-dropdown-btn" class="month-dropdown-button">
                                    <span id="selected-month-text">Año Completo</span>
                                    <i class="fas fa-chevron-down text-xs"></i>
                                </button>
                                <div id="month-dropdown-options" class="month-dropdown-content">
                                    </div>
                            </div>
                        </div>
                        <div class="table-wrapper">
                            <table class="min-w-full">
                                <thead id="stats-table-head">
                                    </thead>
                                <tbody id="tbody-idea1-expanded">
                                    </tbody>
                            </table>
                        </div>
                         <div class="mt-4 text-sm text-gray-600">
                            <span id="pagination-info"></span> </div>
                        <div class="mt-8 text-center">
                            <button id="show-general-stats-btn" class="px-8 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 transition-all duration-150 ease-in-out transform hover:scale-105">
                                <i class="fas fa-chart-bar mr-2"></i>Ver Estadísticas Generales de la Plantilla
                            </button>
                        </div>
                    </section>

                    <section class="stats-section hidden" id="individual-employee-charts-section">
                        <div class="flex flex-wrap justify-between items-center mb-1">
                            <h2 class="!text-xl !font-semibold !mb-0 !pb-0 !border-0 section-main-title w-full sm:w-auto mb-2 sm:mb-0">
                                Detalles para <span id="selected-month-year-display-details" class="text-gray-700"></span>:
                                <span id="selected-employee-name" class="text-indigo-600"></span>
                            </h2>
                            <div class="details-header-controls w-full sm:w-auto justify-end">
                                 <div class="month-dropdown-container" id="details-month-dropdown-container">
                                    <button id="details-month-dropdown-btn" class="month-dropdown-button text-sm">
                                        <span id="details-selected-month-text">Año Completo</span>
                                        <i class="fas fa-chevron-down text-xs"></i>
                                    </button>
                                    <div id="details-month-dropdown-options" class="month-dropdown-content">
                                        </div>
                                </div>
                                <button id="close-individual-charts" class="close-details-button">
                                    <i class="fas fa-times"></i>Cerrar
                                </button>
                            </div>
                        </div>

						<div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6" id="donut-calendar-grid">
							<div class="chart-container" id="donut-chart-wrapper">
								<h3 class="chart-title">Proporción Total de Turnos</h3>
								<canvas id="donutChartCanvas" class="chart-canvas donut-chart-canvas"></canvas>
								<div id="donutChartMessage" class="text-center text-gray-500 text-sm mt-2"></div>
							</div>

							<div class="chart-container" id="calendar-heatmap-wrapper">
								<h3 class="chart-title" id="calendar-heatmap-title">Calendario</h3>
								<div id="mini-calendar-heatmap-container" class="mini-calendar-heatmap">
								</div>
							</div>
						</div>

						<div class="mt-6" id="kpi-section-wrapper"> <h3 class="chart-title mb-3">Resumen Clave Detallado</h3>
							<div id="kpi-summary-card-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2 md:gap-3">
                        </div>
                    </section>

                    <section class="stats-section hidden" id="general-plantilla-stats-section">
						<div class="flex flex-wrap justify-between items-center mb-6 pb-3 border-b border-gray-200">
							<h2 class="!text-xl md:!text-2xl !font-semibold !mb-0 !pb-0 !border-0 text-indigo-700 section-main-title w-full sm:w-auto mb-2 sm:mb-0">
								<i class="fas fa-users mr-2"></i>Estadísticas Generales de la Plantilla
							</h2>
							<div class="details-header-controls w-full sm:w-auto justify-end flex items-center gap-3"> <div class="month-dropdown-container" id="general-stats-month-dropdown-container">
									<button id="general-stats-month-dropdown-btn" class="month-dropdown-button text-sm"> 
										<span id="general-stats-selected-month-text">Año Completo</span> 
										<i class="fas fa-chevron-down text-xs"></i>
									</button>
									<div id="general-stats-month-dropdown-options" class="month-dropdown-content"> 
									</div>
								</div>
								<button id="close-general-stats-btn" class="close-details-button"> 
									<i class="fas fa-times"></i>Cerrar
								</button>
							</div>
						</div>

                        <div class="general-stats-content grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div class="chart-container">
                                <h3 class="chart-title">Composición de Turnos por Empleado (Barras Apiladas)</h3>
                                <canvas id="generalStackedBarCanvas"></canvas>
                            </div>
                            <div class="chart-container">
                                <h3 class="chart-title">Días Trabajados vs. FDS Libres por Empleado</h3>
                                <canvas id="generalGroupedBarCanvas"></canvas>
                            </div>
                        </div>
                    </section>
                    </section>
                <section id="legend-section" class="lg:col-span-3 mt-0">
                    <div class="flex flex-wrap justify-between items-center mb-3 border-b border-gray-200 pb-3">
                        <h3 class="section-title flex-grow mb-0 border-b-0 pb-0 !mb-0"><i class="fas fa-palette mr-2 text-gray-400"></i>Leyenda, Colores y Horarios</h3>
                        <div class="flex-shrink-0">
                            <button id="apply-colors-button" class="action-button bg-indigo-500 text-white hover:bg-indigo-600 focus:ring-indigo-400 text-xs px-3 py-1.5 mr-2" disabled>
                                <i class="fas fa-check"></i>Aplicar
                            </button>
                            <button id="reset-colors-button" class="action-button bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-400 text-xs px-3 py-1.5" disabled>
                                <i class="fas fa-undo"></i>Restaurar
                            </button>
                        </div>
                    </div>
                    <div id="legend-items-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 text-sm">
                    </div>
                </section>


                <section id="history-section" class="lg:col-span-1 mt-0">
                    <div class="flex justify-between items-center mb-3 border-b border-gray-200 pb-3">
                        <h3 class="section-title !mb-0 !border-b-0 !pb-0 flex-grow">
                            <i class="fas fa-history"></i>Historial de Cambios
                        </h3>
                        <div class="flex-shrink-0">
                            <button id="undo-button" title="Deshacer (Ctrl+Z)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5 mr-2" disabled>
                                <i class="fas fa-undo"></i>
                            </button>
                            <button id="redo-button" title="Rehacer (Ctrl+Y)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5" disabled>
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                    </div>
                    <div id="change-history-list-container">
                        <ul id="change-history-list">
                            <li class="text-center text-gray-400">No hay cambios recientes.</li>
                        </ul>
                    </div>
                </section>

                <section id="notes-section" class="lg:col-span-4">
                    <h3 class="section-title"><i class="fas fa-pencil-alt"></i>Notas Generales</h3>
                    <textarea id="general-notes" class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 text-sm notes-textarea" placeholder="Añade comentarios o recordatorios aquí..."></textarea>
                </section>
            </div>
        </main>

		<footer class="mt-16 text-center text-sm text-gray-500 relative pb-4 md:pb-2 px-4 md:px-2">
			<p id="footer-text" class="mb-2 md:mb-0">Gestor de Horarios. Creado por <span id="creator-name" class="footer-name">Nefi Badillo</span> con <i id="footer-heart" class="fas fa-heart text-red-500 footer-name"></i>.</p>

			<div class="absolute bottom-1 left-1 md:bottom-2 md:left-2">
				<a id="download-test-csv-link"
				href="https://drive.usercontent.google.com/uc?id=19eMkjmOt4HGF8mLSkhbmoKpiclckcI2y&export=download"  download="csv_prueba.csv"
				title="Descargar CSV de prueba"
				class="inline-block px-2 py-1 bg-gray-200 text-gray-600 hover:bg-gray-300 text-xs rounded-md shadow-sm transition-colors no-underline">
					Prueba CSV
				</a>
			</div>
		</footer>
    </div>

    <div id="toast-container" class="fixed bottom-6 right-6 space-y-3 z-50"></div>
    <div id="color-palette-popup-container"></div>
    <div id="multiselect-toolbar" class="hidden-by-default">
        </div>

    <div id="add-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">Añadir Nuevo Empleado</h3>
                <div>
                    <input type="text" id="modal-employee-name-input" placeholder="Nombre del empleado" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-add-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-add-employee" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Añadir</button>
                </div>
            </div>
        </div>
    </div>
    <div id="delete-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-red-600 mb-2">¡Atención!</h3>
                <p class="text-gray-700 mb-4">Estás a punto de eliminar al empleado <strong id="employee-name-to-delete" class="font-semibold"></strong> y todos sus datos de horario.</p>
                <p class="text-sm text-gray-500 mb-1">Esta acción es permanente.</p>
                <p id="delete-countdown-message" class="text-red-500 font-semibold mb-4"></p>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-delete-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-delete-employee" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2" disabled>Eliminar</button>
                </div>
            </div>
        </div>
    </div>

    <div id="filename-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="filename-modal-title" class="text-xl font-bold text-gray-900 mb-2">Nombre del Archivo</h3>
            <p id="filename-modal-description" class="text-sm text-gray-600 mb-4"></p>
            <div>
                <input type="text" id="modal-filename-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="nombre_del_archivo">
                <p class="text-xs text-gray-500 mt-1">No incluyas la extensión (ej: .csv o .pdf).</p>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-filename" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-filename" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Aceptar</button>
            </div>
        </div>
    </div>

    <div id="export-calendar-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-900 mb-4">Exportar Mes a Calendar</h3>
            <div class="mb-4">
                <label for="modal-calendar-employee-select" class="block text-sm font-medium text-gray-700 mb-1">Selecciona Empleado:</label>
                <select id="modal-calendar-employee-select" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                    </select>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-export-calendar" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-export-calendar" class="action-button bg-orange-500 text-white hover:bg-orange-600 px-4 py-2">Exportar</button>
            </div>
        </div>
    </div>

    <div id="tips-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-lg bg-gray-50 p-6 rounded-lg shadow-xl"> <div class="flex justify-between items-center mb-6 pb-3 border-b border-gray-300">
                <h3 class="text-2xl font-bold text-indigo-700"><i class="fas fa-lightbulb text-yellow-400 mr-3"></i>Consejos Útiles</h3>
                <button id="close-tips-modal" class="text-gray-500 hover:text-gray-800 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>

            <div class="space-y-4 text-gray-700 text-sm">
                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar/Deseleccionar Celdas (Clic):</h4>
                    <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Usa <code>Ctrl/Cmd + Clic</code>.</li>
                        <li><strong>Móvil:</strong> Realiza una pulsación sobre la celda.</li>
                        <li><strong>Seleccionar Rango (PC/Mac):</strong> Haz clic en la celda de inicio, luego mantén presionada la tecla <code>Shift</code> y haz clic en la celda final.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar Múltiples Celdas (Arrastrando):</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Haz clic en una celda, luego vuelve a hacer clic en la misma y, sin soltar, arrastra el cursor para seleccionar un bloque.</li>
                        <li><strong>Móvil:</strong> Toca una celda para seleccionarla. Luego vuelve a tocar la misma celda, mantén pulsado y arrastra el dedo para expandir la selección a celdas adyacentes.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Reordenar Empleados:</h4>
                    <p class="pl-4">Arrastra y suelta el nombre del empleado en la tabla para cambiar su posición.</p>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Editar Texto en Celdas:</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>Nombres de Empleado:</strong> Doble clic (PC/Mac) o pulsación larga (Móvil) sobre el nombre.</li>
                        <li><strong>Turnos Personalizados:</strong> Doble clic (PC/Mac) o pulsación larga (Móvil) sobre una celda que ya contenga texto personalizado (solo sirve si el turno es "Otro"). Si el texto contiene una coma (,) no se guardará.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Barra de Acciones Rápida:</h4>
                    <p class="pl-4">Tras seleccionar una o más celdas, aparecerá una barra de acciones en la parte inferior de la pantalla. Úsala para asignar rápidamente turnos estándar (M, T, N, L, V, B) o para limpiar la celda (botón "Otro", que asigna un valor vacío, permitiendo luego escribir texto personalizado si se desea).</p>
                </div>
            </div>

            <div class="mt-8 text-right">
                <button id="ok-tips-modal" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-6 py-2 rounded-lg">
                    Entendido
                </button>
            </div>
        </div>
    </div>

    <div id="custom-event-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="custom-event-modal-title" class="text-xl font-bold text-gray-900 mb-4">Editar Evento</h3>
            <div>
                <input type="text" id="modal-custom-event-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="Introduce evento o texto">
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-custom-event" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-custom-event" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Guardar</button>
            </div>
        </div>
    </div>

    <div id="confirm-load-csv-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-900 mb-2">Confirmar Carga de Nuevo Horario</h3>
            <p id="confirm-load-csv-message" class="text-sm text-gray-600 mb-4">Ya hay un horario cargado. Si cargas un nuevo archivo CSV, los cambios no guardados se perderán. ¿Deseas continuar?</p>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-load-csv" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-load-csv" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2">Cargar Nuevo</button>
            </div>
        </div>
    </div>

    <div id="save-local-help-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-md"> <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900">Información sobre Guardado Local</h3>
                <button id="close-save-local-help-modal-icon" class="text-gray-500 hover:text-gray-800">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>
            <div class="text-sm text-gray-700 space-y-3">
                <p>La función 'Guardar Local' almacena el estado actual de tu horario (incluyendo todos los turnos, empleados, el nombre del archivo CSV importado originalmente (si aplica), las notas y las configuraciones de colores) directamente en el almacenamiento de tu navegador web.</p>
                <p>Esto te permite cerrar la aplicación y, al volver a abrirla en el mismo navegador y ordenador, cargar tus datos guardados para continuar tu trabajo.</p>
                <p class="font-semibold text-indigo-700">Importante: Esta acción <strong class="text-red-600">NO modifica ni sobrescribe el archivo CSV original</strong> que pudiste haber importado desde tu ordenador. Los navegadores web, por razones de seguridad, no permiten que las páginas web editen archivos directamente en tu disco duro.</p>
                <p>Para obtener una copia de tu horario actual como un archivo CSV en tu ordenador (para guardarlo o compartirlo), debes usar la función '<strong class="text-blue-600">Exportar CSV</strong>'. Esto descargará un nuevo archivo con los datos más recientes.</p>
            </div>
            <div class="mt-6 text-right">
                <button id="close-save-local-help-modal-button" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Entendido</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTES Y CONFIGURACIÓN ---
        const SVG_FINAL_LOGO_MARKUP = `
            <svg width="200" height="75" viewBox="0 0 220 100" xmlns="http://www.w3.org/2000/svg">
                <style>
                    .logo-text-gh { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-weight: normal; fill: #252525; text-anchor: middle; dominant-baseline: central; }
                    .logo-text-m { font-family: 'Times New Roman', Times, serif; font-size: 26px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: central; }
                    .stars-group { fill: #B08D57; }
                </style>
                <defs>
                    <path id="star-shape" d="M10 0 L12.3511 6.1803 L19.5106 7.2949 L14.7295 12.3197 L15.2939 19.0211 L10 16 L4.7061 19.0211 L5.2705 12.3197 L0.4894 7.2949 L7.6489 6.1803 Z" />
                </defs>
                <text x="110" y="28" class="logo-text-gh">GRAN HOTEL</text>
                <text x="110" y="55" class="logo-text-m">MIRAMAR</text>
                <g class="stars-group" transform="translate(68.5, 72) scale(0.7)">
                    <use href="#star-shape" x="0" />
                    <use href="#star-shape" x="25" />
                    <use href="#star-shape" x="50" />
                    <use href="#star-shape" x="75" />
                    <use href="#star-shape" x="100" />
                </g>
            </svg>
        `;

        const MONTH_NAMES = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
        const SHORT_MONTH_NAMES = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const WEEK_DAY_NAMES = ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"];
        const SHORT_WEEK_DAY_NAMES = ["D", "L", "M", "X", "J", "V", "S"];
        const SHIFT_TYPES = ["M", "T", "N", "L", "V", "B", "M2", "T2", "N2"];
        const SHIFT_TYPE_FULL_NAMES = {
            M: "Mañana", T: "Tarde", N: "Noche", L: "Libre", V: "Vacaciones", B: "Baja", M2: "Mañana 2", T2: "Tarde 2", N2: "Noche 2"
        };
        const DEFAULT_SHIFT_TIMES = {
            M: { start: [7,0], end: [15,0], nextDayEnd: false },
            T: { start: [15,0], end: [23,0], nextDayEnd: false },
            N: { start: [23,0], end: [7,0], nextDayEnd: true },
            M2: { start: [8,0], end: [16,0], nextDayEnd: false },
            T2: { start: [16,0], end: [0,0], nextDayEnd: false },
            N2: { start: [0,0], end: [8,0], nextDayEnd: false }
        };
        let currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));

        const LOCAL_STORAGE_KEY_SCHEDULE = 'scheduleAppData_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1'; // Updated key for new version
        const LOCAL_STORAGE_KEY_NOTES = 'scheduleAppNotes_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_VIEW = 'scheduleAppView_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_COLORS = 'scheduleAppColors_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_HISTORY = 'scheduleAppHistory_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_YEAR = 'scheduleAppYear_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_SHIFT_TIMES = 'scheduleAppShiftTimes_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_AUTOSAVE = 'scheduleAppAutosaveEnabled_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_UNDO_STACK = 'scheduleAppUndoStack_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_REDO_STACK = 'scheduleAppRedoStack_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';


        const TEMPLATE_FLAG_FILENAME = "TEMPLATE_SCHEDULE";


        const MAX_HISTORY_ITEMS = 30;
        const MAX_UNDO_STACK_SIZE = 30;

        let undoStack = [];
        let redoStack = [];
        let currentConfirmAction = null;


        const LONG_PRESS_DURATION = 500;
        const MAX_TOUCH_MOVE_THRESHOLD = 10;
        let dragOverIndicator = null;
        let deleteCountdownInterval = null;
        let employeeToDeleteName = null;

        const DEFAULT_SHIFT_COLORS = {
            M: { bg: 'bg-green-300', text: 'text-green-700', hexBg: '#a7f3d0', hexText: '#047857' },
            T: { bg: 'bg-orange-300', text: 'text-orange-700', hexBg: '#fed7aa', hexText: '#c2410c' },
            N: { bg: 'bg-blue-300', text: 'text-blue-700', hexBg: '#bfdbfe', hexText: '#1d4ed8' },
            M2: { bg: 'bg-green-200', text: 'text-green-800', hexBg: '#86efac', hexText: '#185938' },
            T2: { bg: 'bg-orange-200', text: 'text-orange-800', hexBg: '#fdba74', hexText: '#9a3412' },
            N2: { bg: 'bg-blue-200', text: 'text-blue-800', hexBg: '#93c5fd', hexText: '#1e40af' },
            L: { bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            V: { bg: 'bg-yellow-300', text: 'text-yellow-700', hexBg: '#fef08a', hexText: '#a16207' },
            B: { bg: 'bg-red-400', text: 'text-red-800', hexBg: '#fca5a5', hexText: '#991b1b' },
            empty: { bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' }
        };

        const AVAILABLE_COLORS = [
            { name: 'Blanco', bg: 'bg-white', text: 'text-gray-500', hexBg: '#ffffff', hexText: '#6b7280' }, // Texto gris para contraste sobre blanco
            { name: 'Verde Pastel', bg: 'bg-green-200', text: 'text-green-700', hexBg: '#a7f3d0', hexText: '#047857' },
            { name: 'Naranja Pastel', bg: 'bg-orange-200', text: 'text-orange-700', hexBg: '#fed7aa', hexText: '#c2410c' },
            { name: 'Azul Pastel', bg: 'bg-blue-200', text: 'text-blue-700', hexBg: '#bfdbfe', hexText: '#1d4ed8' },
            { name: 'Gris Pastel', bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            { name: 'Amarillo Pastel', bg: 'bg-yellow-200', text: 'text-yellow-700', hexBg: '#fef08a', hexText: '#a16207' }, // Ajustado a yellow-200 para consistencia con otros pasteles
            { name: 'Rojo Pastel', bg: 'bg-red-200', text: 'text-red-700', hexBg: '#fecaca', hexText: '#b91c1c' },
            { name: 'Rojo Suave', bg: 'bg-red-300', text: 'text-red-800', hexBg: '#fca5a5', hexText: '#991b1b' }, // Ajustado a red-300
            { name: 'Morado Pastel (Def. Otro)', bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' },
            { name: 'Cian Pastel', bg: 'bg-cyan-200', text: 'text-cyan-700', hexBg: '#a5f3fc', hexText: '#0e7490' },
            { name: 'Rosa Pastel', bg: 'bg-pink-200', text: 'text-pink-700', hexBg: '#fbcfe8', hexText: '#be185d' },
            { name: 'Lima Pastel', bg: 'bg-lime-200', text: 'text-lime-700', hexBg: '#d9f99d', hexText: '#65a30d' },
            { name: 'Esmeralda Pastel', bg: 'bg-emerald-200', text: 'text-emerald-700', hexBg: '#a7f3d0', hexText: '#065f46' }, // Mismo que Verde Pastel, considerar diferenciar
            { name: 'Turquesa Pastel', bg: 'bg-teal-200', text: 'text-teal-700', hexBg: '#99f6e4', hexText: '#0d9488' },
            { name: 'Fucsia Pastel', bg: 'bg-fuchsia-200', text: 'text-fuchsia-700', hexBg: '#f5d0fe', hexText: '#a21caf' },
            { name: 'Celeste Pastel', bg: 'bg-sky-200', text: 'text-sky-700', hexBg: '#bae6fd', hexText: '#0369a1' },
            { name: 'Índigo Pastel', bg: 'bg-indigo-200', text: 'text-indigo-700', hexBg: '#c7d2fe', hexText: '#4338ca' },
            { name: 'Verde Suave (M2)', bg: 'bg-green-300', text: 'text-green-800', hexBg: '#86efac', hexText: '#185938' },
            { name: 'Naranja Suave (T2)', bg: 'bg-orange-300', text: 'text-orange-800', hexBg: '#fdba74', hexText: '#9a3412' },
            { name: 'Azul Suave (N2)', bg: 'bg-blue-300', text: 'text-blue-800', hexBg: '#93c5fd', hexText: '#1e40af' },
            { name: 'Melocotón', bg: 'bg-orange-100', text: 'text-orange-700', hexBg: '#ffedd5', hexText: '#c2410c' }, // text-orange-700 para más contraste
            { name: 'Azul Cielo', bg: 'bg-blue-100', text: 'text-blue-700', hexBg: '#dbeafe', hexText: '#1d4ed8' }, // text-blue-700 para más contraste
            { name: 'Gris Muy Claro', bg: 'bg-gray-100', text: 'text-gray-700', hexBg: '#f3f4f6', hexText: '#374151' }, // text-gray-700 para más contraste
            { name: 'Crema', bg: 'bg-yellow-100', text: 'text-yellow-700', hexBg: '#fef9c3', hexText: '#a16207' }, // text-yellow-700 para más contraste
            { name: 'Salmón', bg: 'bg-red-100', text: 'text-red-700', hexBg: '#fee2e2', hexText: '#b91c1c' }, // text-red-700 para más contraste
            { name: 'Lavanda', bg: 'bg-purple-100', text: 'text-purple-700', hexBg: '#f3e8ff', hexText: '#7e22ce' }, // text-purple-700 para más contraste
            { name: 'Aguamarina', bg: 'bg-cyan-100', text: 'text-cyan-700', hexBg: '#cffafe', hexText: '#0e7490' }, // text-cyan-700 para más contraste
            { name: 'Menta Azulado', bg: 'bg-teal-100', text: 'text-teal-700', hexBg: '#ccfbf1', hexText: '#0d9488' }, // text-teal-700 para más contraste
            { name: 'Magenta Claro', bg: 'bg-fuchsia-100', text: 'text-fuchsia-700', hexBg: '#fae8ff', hexText: '#a21caf' }, // text-fuchsia-700 para más contraste
            { name: 'Coral Claro', bg: 'bg-rose-100', text: 'text-rose-700', hexBg: '#ffe4e6', hexText: '#be123c' }, // text-rose-700 para más contraste
            { name: 'Azul Hielo', bg: 'bg-sky-100', text: 'text-sky-700', hexBg: '#e0f2fe', hexText: '#0369a1' }, // text-sky-700 para más contraste
            { name: 'Índigo Muy Claro', bg: 'bg-indigo-100', text: 'text-indigo-700', hexBg: '#e0e7ff', hexText: '#4338ca' }, // text-indigo-700 para más contraste
            { name: 'Amarillo Suave', bg: 'bg-yellow-300', text: 'text-yellow-800', hexBg: '#fde047', hexText: '#854d0e' },
            { name: 'Rojo Intenso', bg: 'bg-red-500', text: 'text-red-100', hexBg: '#ef4444', hexText: '#fee2e2' },
            { name: 'Naranja Intenso', bg: 'bg-orange-500', text: 'text-orange-100', hexBg: '#f97316', hexText: '#ffedd5' },
            { name: 'Ámbar Intenso', bg: 'bg-amber-500', text: 'text-amber-900', hexBg: '#f59e0b', hexText: '#78350f' },
            { name: 'Lima Intenso', bg: 'bg-lime-500', text: 'text-lime-900', hexBg: '#84cc16', hexText: '#365314' },
            { name: 'Verde Intenso', bg: 'bg-green-600', text: 'text-green-100', hexBg: '#16a34a', hexText: '#dcfce7' },
            { name: 'Esmeralda Intenso', bg: 'bg-emerald-500', text: 'text-emerald-100', hexBg: '#10b981', hexText: '#d1fae5' },
            { name: 'Turquesa Intenso', bg: 'bg-teal-500', text: 'text-teal-100', hexBg: '#14b8a6', hexText: '#ccfbf1' },
            { name: 'Cian Intenso', bg: 'bg-cyan-500', text: 'text-cyan-100', hexBg: '#06b6d4', hexText: '#cffafe' },
            { name: 'Celeste Intenso', bg: 'bg-sky-600', text: 'text-sky-100', hexBg: '#0284c7', hexText: '#e0f2fe' },
            { name: 'Azul Intenso', bg: 'bg-blue-600', text: 'text-blue-100', hexBg: '#2563eb', hexText: '#dbeafe' },
            { name: 'Índigo Intenso', bg: 'bg-indigo-600', text: 'text-indigo-100', hexBg: '#4f46e5', hexText: '#e0e7ff' },
            { name: 'Violeta Intenso', bg: 'bg-violet-600', text: 'text-violet-100', hexBg: '#7c3aed', hexText: '#ede9fe' },
            { name: 'Púrpura Intenso', bg: 'bg-purple-600', text: 'text-purple-100', hexBg: '#9333ea', hexText: '#f3e8ff' },
            { name: 'Fucsia Intenso', bg: 'bg-fuchsia-600', text: 'text-fuchsia-100', hexBg: '#d946ef', hexText: '#fae8ff' },
            { name: 'Rosa Intenso', bg: 'bg-pink-600', text: 'text-pink-100', hexBg: '#db2777', hexText: '#fce7f3' },
            { name: 'Rosado Intenso', bg: 'bg-rose-600', text: 'text-rose-100', hexBg: '#e11d48', hexText: '#ffe4e6' },
            { name: 'Gris Medio', bg: 'bg-gray-400', text: 'text-gray-800', hexBg: '#9ca3af', hexText: '#1f2937' }, // text-gray-800 para mejor contraste
            { name: 'Gris Oscuro', bg: 'bg-gray-600', text: 'text-gray-100', hexBg: '#4b5563', hexText: '#f3f4f6' },
            { name: 'Amarillo Oro', bg: 'bg-yellow-500', text: 'text-yellow-900', hexBg: '#eab308', hexText: '#713f12' }, // text-yellow-900 para mejor contraste
            { name: 'Verde Bosque', bg: 'bg-green-700', text: 'text-green-100', hexBg: '#047857', hexText: '#dcfce7' },
            { name: 'Azul Marino', bg: 'bg-blue-800', text: 'text-blue-100', hexBg: '#1e40af', hexText: '#dbeafe' },
            { name: 'Morado Real', bg: 'bg-purple-700', text: 'text-purple-100', hexBg: '#6b21a8', hexText: '#f3e8ff' },
            { name: 'Rojo Carmesí', bg: 'bg-red-700', text: 'text-red-100', hexBg: '#b91c1c', hexText: '#fee2e2' },
            { name: 'Naranja Fuerte', bg: 'bg-orange-600', text: 'text-orange-100', hexBg: '#ea580c', hexText: '#ffedd5' },
            { name: 'Cian Oscuro', bg: 'bg-cyan-700', text: 'text-cyan-100', hexBg: '#0891b2', hexText: '#cffafe' },
            { name: 'Índigo Oscuro', bg: 'bg-indigo-700', text: 'text-indigo-100', hexBg: '#4338ca', hexText: '#e0e7ff' },
            { name: 'Rosa Mexicano', bg: 'bg-pink-500', text: 'text-pink-100', hexBg: '#ec4899', hexText: '#fce7f3' },
            { name: 'Verde Lima Fuerte', bg: 'bg-lime-600', text: 'text-lime-100', hexBg: '#65a30d', hexText: '#f7fee7' },
        ];

        let currentShiftColors = { ...DEFAULT_SHIFT_COLORS };
        let activeColorPalette = null;

        let scheduleData = {};
        let employeeNamesOrdered = [];
        let currentViewMode = 'monthly';
        let currentSelectedMonth = new Date().getMonth() + 1;
        let yearOfSchedule = new Date().getFullYear();
        let hasUnsavedChanges = false;
        let changeHistory = [];

        let cellsBeingEditedViaEventModal = [];
        let isSingleCellEditViaModal = false;

        let selectedCells = [];
        let lastSelectedCellInfo = null;
        let cellsAffectedByCurrentDrag = new Set();

        let touchstartTime = 0;
        let touchstartTarget = null;
        let longPressTimer = null;
        let touchstartX = 0, touchstartY = 0;
        let wasLongPress = false;

        let isDraggingToSelect = false;
        let dragSelectionStartCellInfo = null;
        let lastCellOverForDragSelectInfo = null;

        let draggedRow = null;
        let currentFilenameConfirmCallback = null;
        let currentFilenameExtension = '';
        let footerHeartClicks = 0;
        let notesDebounceTimer;

        let isAutosaveEnabled = false;
        let autosaveIntervalId = null;
        const AUTOSAVE_INTERVAL_MS = 30000;

        const domCache = {};

        // --- FUNCIONES DE GESTIÓN DE ESTADO (DESHACER/REHACER) ---
        function getAppStateSnapshot() {
            return {
                scheduleData: JSON.parse(JSON.stringify(scheduleData)),
                employeeNamesOrdered: JSON.parse(JSON.stringify(employeeNamesOrdered)),
                currentShiftColors: JSON.parse(JSON.stringify(currentShiftColors)),
                currentUserShiftTimes: JSON.parse(JSON.stringify(currentUserShiftTimes)),
                generalNotes: domCache.generalNotesTextarea.value,
                yearOfSchedule: yearOfSchedule,
                currentSelectedMonth: currentSelectedMonth,
                currentViewMode: currentViewMode,
                uploadedFileName: domCache.csvFileInput?.dataset?.uploadedFileName || null
            };
        }

		function restoreAppState(snapshot) {
			const currentGlobalYearBeforeRestore = yearOfSchedule;

			scheduleData = snapshot.scheduleData;
			employeeNamesOrdered = snapshot.employeeNamesOrdered;
			currentShiftColors = snapshot.currentShiftColors;
			currentUserShiftTimes = snapshot.currentUserShiftTimes;
			domCache.generalNotesTextarea.value = snapshot.generalNotes;

			currentSelectedMonth = snapshot.currentSelectedMonth;
			currentViewMode = snapshot.currentViewMode;
			if (domCache.csvFileInput) {
				if (snapshot.uploadedFileName) {
					domCache.csvFileInput.dataset.uploadedFileName = snapshot.uploadedFileName;
				} else {
					delete domCache.csvFileInput.dataset.uploadedFileName;
				}
			}

			yearOfSchedule = currentGlobalYearBeforeRestore; // Mantener el año global actual si no está en snapshot o si se prefiere
			// Si el snapshot SÍ debe restaurar el año, entonces: yearOfSchedule = snapshot.yearOfSchedule;
			domCache.yearInput.value = yearOfSchedule; 

			updateLegend();
			handleViewChange(); // Actualiza la tabla de horario principal
			initializeAndRenderNewStatistics(); // <--- AÑADIDO para actualizar las nuevas estadísticas
			populateMonthTabs();
			updateViewModeUI();
			updateUnsavedChangesIndicator();
			updateUndoRedoButtonsState();
		}

        function saveStateForUndo(descriptionForHistory) {
            if (undoStack.length >= MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            undoStack.push(getAppStateSnapshot());
            redoStack = [];
            addChangeToHistory(descriptionForHistory);
            hasUnsavedChanges = true;
            updateUnsavedChangesIndicator();
            if (domCache.saveLocalButton) domCache.saveLocalButton.disabled = !isDataLoadedForSave();
            updateUndoRedoButtonsState();
        }

        function undoChange() {
            if (undoStack.length === 0) return;
            redoStack.push(getAppStateSnapshot());
            if (redoStack.length > MAX_UNDO_STACK_SIZE) {
                redoStack.shift();
            }
            const previousState = undoStack.pop();
            restoreAppState(previousState);
            showToast('Acción deshecha.', 'info');
            addChangeToHistory("Acción deshecha.");
            updateUndoRedoButtonsState();
        }

        function redoChange() {
            if (redoStack.length === 0) return;
            undoStack.push(getAppStateSnapshot());
            if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            const nextState = redoStack.pop();
            restoreAppState(nextState);
            showToast('Acción rehecha.', 'info');
            addChangeToHistory("Acción rehecha.");
            updateUndoRedoButtonsState();
        }

        function updateUndoRedoButtonsState() {
            if (domCache.undoButton) {
                domCache.undoButton.disabled = undoStack.length === 0;
            }
            if (domCache.redoButton) {
                domCache.redoButton.disabled = redoStack.length === 0;
            }
        }

        // --- UTILIDADES ---
        function createElement(tag, options = {}, children = []) {
            const element = document.createElement(tag);
            if (options.className) element.className = options.className;
            if (options.id) element.id = options.id;
            if (options.textContent) element.textContent = options.textContent;
            if (options.innerHTML) element.innerHTML = options.innerHTML;
            if (options.title) element.title = options.title;
            if (options.dataset) {
                for (const key in options.dataset) {
                    element.dataset[key] = options.dataset[key];
                }
            }
            if (options.style) {
                for (const prop in options.style) {
                    element.style[prop] = options.style[prop];
                }
            }
            if (options.attributes) {
                for (const attr in options.attributes) {
                    element.setAttribute(attr, options.attributes[attr]);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    element.appendChild(child);
                }
            });
            return element;
        }

        function updateUnsavedChangesIndicator() {
            if (domCache.unsavedIndicatorTable) {
                domCache.unsavedIndicatorTable.classList.toggle('hidden-by-default', !hasUnsavedChanges);
            }
            if (domCache.saveLocalButton) {
                 domCache.saveLocalButton.disabled = !hasUnsavedChanges || !isDataLoadedForSave();
            }
        }


        function lightenDarkenColor(col, amt) {
            let usePound = false;
            if (col[0] == "#") {
                col = col.slice(1);
                usePound = true;
            }
            let num = parseInt(col, 16);
            if (isNaN(num)) return usePound ? "#FFFFFF" : "FFFFFF";
            let r = (num >> 16) + amt;
            if (r > 255) r = 255; else if (r < 0) r = 0;
            let b = ((num >> 8) & 0x00FF) + amt;
            if (b > 255) b = 255; else if (b < 0) b = 0;
            let g = (num & 0x0000FF) + amt;
            if (g > 255) g = 255; else if (g < 0) g = 0;
            let hex = (g | (b << 8) | (r << 16)).toString(16);
            while(hex.length < 6) hex = '0' + hex;
            return (usePound ? "#" : "") + hex;
        }


        // --- CACHÉ DE ELEMENTOS DEL DOM ---
        function cacheDOMElements() {
            // --- Elementos Generales y de Control Principal ---
            domCache.mainTitleText = document.getElementById('main-title-text');
            domCache.logoContainer = document.getElementById('logo-container');
            domCache.toastContainer = document.getElementById('toast-container');
            domCache.footerTextElement = document.getElementById('footer-text');
            domCache.creatorNameElement = document.getElementById('creator-name');
            domCache.footerHeartElement = document.getElementById('footer-heart');

            // --- Controles de Importación, Año y Guardado/Exportación Principal ---
            domCache.csvFileInput = document.getElementById('csv-file-input');
            domCache.yearInput = document.getElementById('year-input');
            domCache.saveLocalButton = document.getElementById('save-local-button');
            domCache.exportCsvButton = document.getElementById('export-csv-button');
            domCache.createEmptyCsvButton = document.getElementById('create-empty-csv-button');
            domCache.downloadImageButton = document.getElementById('download-image-button'); // Para PDF mensual/anual
            domCache.downloadWeeklySvgButton = document.getElementById('download-weekly-svg-button'); // Para PDF semanal
            domCache.exportMonthCalendarButton = document.getElementById('export-month-calendar-button');
            domCache.autosaveToggle = document.getElementById('autosave-toggle');
            domCache.saveLocalHelpIcon = document.getElementById('save-local-help-icon');

            // --- Controles de Vista y Navegación del Horario Principal ---
            domCache.viewMonthlyButton = document.getElementById('view-monthly-button');
            domCache.viewAnnualButton = document.getElementById('view-annual-button');
            domCache.viewModeButtonsContainer = document.getElementById('view-mode-buttons-container');
            domCache.monthTabsContainer = document.getElementById('month-tabs-container');

            // --- Secciones Principales de la UI ---
            domCache.welcomeMessage = document.getElementById('welcome-message');
            domCache.scheduleDisplaySection = document.getElementById('schedule-display-section');
            domCache.scheduleTableSection = document.getElementById('schedule-table-section'); // Contenedor de la tabla de horario
            domCache.notesSection = document.getElementById('notes-section'); // Sección de notas generales
            domCache.legendSection = document.getElementById('legend-section'); // Sección de leyenda
            domCache.historySection = document.getElementById('history-section'); // Sección de historial

            // --- Elementos de la Tabla de Horario Principal ---
            domCache.currentMonthYearDisplay = document.getElementById('current-month-year-display'); // Cabecera h2 de la tabla
            domCache.currentMonthYearText = document.getElementById('current-month-year-text'); // Span con Mes Año
            domCache.unsavedIndicatorTable = document.getElementById('unsaved-indicator-table');
            domCache.scheduleTableHead = document.getElementById('schedule-table-head');
            domCache.scheduleTableBody = document.getElementById('schedule-table-body');
            domCache.noDataMessage = document.getElementById('no-data-message'); // Mensaje si no hay datos en tabla horario

            // --- Barra de Herramientas de Multiselección y Paleta de Colores ---
            domCache.multiselectToolbar = document.getElementById('multiselect-toolbar');
            domCache.colorPalettePopupContainer = document.getElementById('color-palette-popup-container');

            // --- Leyenda y Controles de Color/Horarios ---
            domCache.legendItemsContainer = document.getElementById('legend-items-container');
            domCache.applyColorsButton = document.getElementById('apply-colors-button');
            domCache.resetColorsButton = document.getElementById('reset-colors-button');

            // --- Historial de Cambios y Notas ---
            domCache.changeHistoryList = document.getElementById('change-history-list');
            domCache.generalNotesTextarea = document.getElementById('general-notes');
            domCache.undoButton = document.getElementById('undo-button');
            domCache.redoButton = document.getElementById('redo-button');

            // --- Modales ---
            domCache.addEmployeeModal = document.getElementById('add-employee-modal');
            domCache.modalEmployeeNameInput = document.getElementById('modal-employee-name-input');
            domCache.modalConfirmAddEmployee = document.getElementById('modal-confirm-add-employee');
            domCache.modalCancelAddEmployee = document.getElementById('modal-cancel-add-employee');

            domCache.deleteEmployeeModal = document.getElementById('delete-employee-modal');
            domCache.employeeNameToDeleteSpan = document.getElementById('employee-name-to-delete');
            domCache.deleteCountdownMessageSpan = document.getElementById('delete-countdown-message');
            domCache.modalConfirmDeleteEmployee = document.getElementById('modal-confirm-delete-employee');
            domCache.modalCancelDeleteEmployee = document.getElementById('modal-cancel-delete-employee');

            domCache.filenameModal = document.getElementById('filename-modal');
            domCache.filenameModalTitle = document.getElementById('filename-modal-title');
            domCache.filenameModalDescription = document.getElementById('filename-modal-description');
            domCache.modalFilenameInput = document.getElementById('modal-filename-input');
            domCache.modalConfirmFilename = document.getElementById('modal-confirm-filename');
            domCache.modalCancelFilename = document.getElementById('modal-cancel-filename');

            domCache.exportCalendarModal = document.getElementById('export-calendar-modal');
            domCache.modalCalendarEmployeeSelect = document.getElementById('modal-calendar-employee-select');
            domCache.modalConfirmExportCalendar = document.getElementById('modal-confirm-export-calendar');
            domCache.modalCancelExportCalendar = document.getElementById('modal-cancel-export-calendar');

            domCache.tipsModal = document.getElementById('tips-modal');
            domCache.helpIconContainer = document.getElementById('help-icon-container'); // Icono de la bombilla
            domCache.closeTipsModalButton = document.getElementById('close-tips-modal'); // Botón 'x' en modal de consejos
            domCache.okTipsModalButton = document.getElementById('ok-tips-modal');     // Botón 'Entendido' en modal de consejos

            domCache.customEventModal = document.getElementById('custom-event-modal');
            domCache.customEventModalTitle = document.getElementById('custom-event-modal-title');
            domCache.modalCustomEventInput = document.getElementById('modal-custom-event-input');
            domCache.modalConfirmCustomEvent = document.getElementById('modal-confirm-custom-event');
            domCache.modalCancelCustomEvent = document.getElementById('modal-cancel-custom-event');

            domCache.confirmLoadCsvModal = document.getElementById('confirm-load-csv-modal');
            domCache.confirmLoadCsvMessage = document.getElementById('confirm-load-csv-message');
            domCache.modalCancelLoadCsv = document.getElementById('modal-cancel-load-csv');
            domCache.modalConfirmLoadCsv = document.getElementById('modal-confirm-load-csv');

            domCache.saveLocalHelpModal = document.getElementById('save-local-help-modal');
            domCache.closeSaveLocalHelpModalIcon = document.getElementById('close-save-local-help-modal-icon');
            domCache.closeSaveLocalHelpModalButton = document.getElementById('close-save-local-help-modal-button');
            domCache.statisticsSectionReformed = document.getElementById('statistics-section'); 
            
            // Sección de la tabla principal de estadísticas (dentro de statisticsSectionReformed)
            domCache.mainStatsTableSection = document.getElementById('idea1-table-improved-expanded');
            domCache.statsTableHead = document.getElementById('stats-table-head'); // Thead de la nueva tabla de estadísticas
            domCache.statsTableBody = document.getElementById('tbody-idea1-expanded'); // Tbody de la nueva tabla de estadísticas
            domCache.paginationInfo = document.getElementById('pagination-info'); // Para mostrar info de conteo de empleados

            // Dropdown de mes/año principal para la nueva tabla de estadísticas
            domCache.mainMonthDropdownContainer = document.getElementById('main-month-dropdown-container');
            domCache.mainMonthDropdownBtn = document.getElementById('month-dropdown-btn'); // Botón que abre el dropdown principal
            domCache.selectedMonthText = document.getElementById('selected-month-text'); // Span que muestra el mes/año seleccionado en el botón principal
            domCache.mainMonthDropdownOptions = document.getElementById('month-dropdown-options'); 

            // Botón para ver estadísticas generales de la plantilla
            domCache.showGeneralStatsBtn = document.getElementById('show-general-stats-btn');

            // Sección de detalles individuales del empleado
            domCache.individualChartsSection = document.getElementById('individual-employee-charts-section');
            domCache.selectedMonthYearDisplayDetails = document.getElementById('selected-month-year-display-details'); // Span para mostrar "Mes Año" en la cabecera de detalles
            domCache.selectedEmployeeName = document.getElementById('selected-employee-name'); // Span para mostrar el nombre del empleado en detalles
            domCache.detailsMonthDropdownContainer = document.getElementById('details-month-dropdown-container'); // Contenedor del dropdown en detalles
            domCache.detailsMonthDropdownBtn = document.getElementById('details-month-dropdown-btn'); // Botón del dropdown en detalles
            domCache.detailsSelectedMonthText = document.getElementById('details-selected-month-text'); // Span para mes/año en el botón de dropdown de detalles
            domCache.detailsMonthDropdownOptions = document.getElementById('details-month-dropdown-options'); // Opciones del dropdown en detalles
            domCache.closeIndividualChartsBtn = document.getElementById('close-individual-charts'); // Botón para cerrar la vista de detalles individuales

            // Canvas para gráficos individuales
            domCache.donutChartCanvas = document.getElementById('donutChartCanvas');
            domCache.donutChartMessage = document.getElementById('donutChartMessage'); // Div para mensajes si el donut chart no tiene datos
            domCache.calendarHeatmapTitle = document.getElementById('calendar-heatmap-title'); // Título del mini calendario
            domCache.miniCalendarHeatmapContainer = document.getElementById('mini-calendar-heatmap-container');
            domCache.kpiSummaryCardContainer = document.getElementById('kpi-summary-card-container'); // Contenedor para las tarjetas KPI
			domCache.donutChartWrapper = document.getElementById('donut-chart-wrapper');
			domCache.calendarHeatmapWrapper = document.getElementById('calendar-heatmap-wrapper');
			domCache.donutCalendarGrid = document.getElementById('donut-calendar-grid');

            // Sección de estadísticas generales de la plantilla
            domCache.generalPlantillaStatsSection = document.getElementById('general-plantilla-stats-section');
            domCache.closeGeneralStatsBtn = document.getElementById('close-general-stats-btn'); // Botón para cerrar las estadísticas generales
			domCache.generalStatsMonthDropdownContainer = document.getElementById('general-stats-month-dropdown-container');
			domCache.generalStatsMonthDropdownBtn = document.getElementById('general-stats-month-dropdown-btn');
			domCache.generalStatsSelectedMonthText = document.getElementById('general-stats-selected-month-text');
			domCache.generalStatsMonthDropdownOptions = document.getElementById('general-stats-month-dropdown-options');

            // Canvas para gráficos generales
            domCache.generalStackedBarCanvas = document.getElementById('generalStackedBarCanvas');
            domCache.generalGroupedBarCanvas = document.getElementById('generalGroupedBarCanvas');
            
            // Placeholder para cuando no hay datos en la nueva sección de estadísticas (si decides usar uno específico)
            // domCache.statsPlaceholderReformed = document.getElementById('stats-placeholder-reformed'); // Descomentar y crear el div si es necesario

        }

        // --- MANEJO DE EVENTOS DE SELECCIÓN DE CELDAS ---
        function handleCellMouseDown(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;
            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            isDraggingToSelect = true;
            dragSelectionStartCellInfo = cellInfo;
            lastCellOverForDragSelectInfo = cellInfo;
            cellsAffectedByCurrentDrag = new Set();

            processCellClick(cellInfo, event.shiftKey, (event.ctrlKey || event.metaKey), false);

            selectedCells.forEach(sc => {
                cellsAffectedByCurrentDrag.add(sc.tdElement);
            });
            updateMultiselectToolbar();
        }

        function handleDocumentMouseMove(event) {
            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return;
            const currentTarget = event.target;
            const currentTd = currentTarget.closest('td.shift-cell');
            if (!currentTd) return;

            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo) return;

            if (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement) {
                return;
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            const minRow = Math.min(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const maxRow = Math.max(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const minCol = Math.min(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);
            const maxCol = Math.max(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);

            const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
            allCellsInTable.forEach(cellElement => {
                const cellIterInfo = getCellInfoFromElement(cellElement);
                if (!cellIterInfo) return;

                const isInCurrentRect = cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol;
                let isSelectedInGlobalList = selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement);

                if (isInCurrentRect) {
                    if (!isSelectedInGlobalList) {
                        selectedCells.push(cellIterInfo);
                        cellElement.classList.add('cell-selected');
                        cellsAffectedByCurrentDrag.add(cellElement);
                    }
                } else {
                    if (isSelectedInGlobalList && cellsAffectedByCurrentDrag.has(cellElement)) {
                        const index = selectedCells.findIndex(sc => sc.tdElement === cellIterInfo.tdElement);
                        if (index > -1) selectedCells.splice(index, 1);
                        cellElement.classList.remove('cell-selected');
                    }
                }
            });
            updateMultiselectToolbar();
        }

        function handleDocumentMouseUp(event) {
            if (isDraggingToSelect) {
                isDraggingToSelect = false;
            }
        }

        function handleCellTouchStart(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;
            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            touchstartTarget = targetTd;
            touchstartTime = new Date().getTime();
            touchstartX = event.touches[0].clientX;
            touchstartY = event.touches[0].clientY;
            wasLongPress = false;
            isDraggingToSelect = false;
            cellsAffectedByCurrentDrag = new Set();

            const isAlreadySelected = selectedCells.some(sc => sc.tdElement === cellInfo.tdElement);

            if (isAlreadySelected) {
                dragSelectionStartCellInfo = cellInfo;
                lastCellOverForDragSelectInfo = cellInfo;
            } else {
                dragSelectionStartCellInfo = null;
                lastCellOverForDragSelectInfo = null;
            }
            selectedCells.forEach(sc => {
                cellsAffectedByCurrentDrag.add(sc.tdElement);
            });


            if (longPressTimer) clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if (isDraggingToSelect) {
                    longPressTimer = null;
                    return;
                }
                wasLongPress = true;
                const currentCellInfoOnTimeout = getCellInfoFromElement(touchstartTarget);
                if (currentCellInfoOnTimeout) {
                    const currentValue = scheduleData[currentCellInfoOnTimeout.employee]?.[currentCellInfoOnTimeout.month]?.[currentCellInfoOnTimeout.day] || "";
                    if (!SHIFT_TYPES.includes(currentValue)) {
                         event.preventDefault();
                         editCellOnLongPress(currentCellInfoOnTimeout);
                    }
                }
                longPressTimer = null;
            }, LONG_PRESS_DURATION);
        }

        function handleDocumentTouchMove(event) {
            let movedSignificantly = false;
            if (dragSelectionStartCellInfo && !isDraggingToSelect) {
                const deltaX = Math.abs(event.touches[0].clientX - touchstartX);
                const deltaY = Math.abs(event.touches[0].clientY - touchstartY);
                if (deltaX > MAX_TOUCH_MOVE_THRESHOLD || deltaY > MAX_TOUCH_MOVE_THRESHOLD) {
                    isDraggingToSelect = true;
                    movedSignificantly = true;
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                }
            }

            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return;

            if (movedSignificantly || isDraggingToSelect) {
                 event.preventDefault();
            }

            const currentTarget = document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY);
            const currentTd = currentTarget ? currentTarget.closest('td.shift-cell') : null;
            if (!currentTd) return;

            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo || (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement)) {
                return;
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            const minRow = Math.min(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const maxRow = Math.max(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const minCol = Math.min(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);
            const maxCol = Math.max(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);

            const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
            allCellsInTable.forEach(cellElement => {
                const cellIterInfo = getCellInfoFromElement(cellElement);
                if (!cellIterInfo) return;

                const isInCurrentRect = cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol;
                let isSelectedInGlobalList = selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement);

                if (isInCurrentRect) {
                    if (!isSelectedInGlobalList) {
                        selectedCells.push(cellIterInfo);
                        cellElement.classList.add('cell-selected');
                        cellsAffectedByCurrentDrag.add(cellElement);
                    }
                } else {
                    if (isSelectedInGlobalList && cellsAffectedByCurrentDrag.has(cellElement)) {
                        const index = selectedCells.findIndex(sc => sc.tdElement === cellIterInfo.tdElement);
                        if (index > -1) selectedCells.splice(index, 1);
                        cellElement.classList.remove('cell-selected');
                    }
                }
            });
            updateMultiselectToolbar();
        }

        function handleDocumentTouchEnd(event) {
            const wasActuallyDragging = isDraggingToSelect;
            if (isDraggingToSelect) {
                isDraggingToSelect = false;
            }

            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (!wasActuallyDragging && !wasLongPress && touchstartTarget) {
                const cellInfo = getCellInfoFromElement(touchstartTarget);
                if (cellInfo) {
                    const deltaX = Math.abs(event.changedTouches[0].clientX - touchstartX);
                    const deltaY = Math.abs(event.changedTouches[0].clientY - touchstartY);
                    if (deltaX <= MAX_TOUCH_MOVE_THRESHOLD && deltaY <= MAX_TOUCH_MOVE_THRESHOLD) {
                        const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                        if (!SHIFT_TYPES.includes(currentValue)) {
                             processCellClick(cellInfo, false, false, true);
                        } else {
                            processCellClick(cellInfo, false, false, true);
                        }
                    }
                }
            }

            touchstartTarget = null;
            touchstartTime = 0;
            dragSelectionStartCellInfo = null;
            lastCellOverForDragSelectInfo = null;
        }


        // --- CONFIGURACIÓN DE EVENT LISTENERS ---
        function setupEventListeners() {
            domCache.csvFileInput.addEventListener('change', handleFileUpload);
            domCache.yearInput.addEventListener('change', handleYearChange);
            domCache.saveLocalButton.addEventListener('click', () => saveScheduleToLocalStorage(false));
            domCache.exportCsvButton.addEventListener('click', prepareExportScheduleToCSV);
            domCache.createEmptyCsvButton.addEventListener('click', handleCreateEmptyScheduleClick);
            domCache.downloadImageButton.addEventListener('click', () => prepareDownloadSvgOrPdf('monthlyAnnual'));
            domCache.downloadWeeklySvgButton.addEventListener('click', () => prepareDownloadSvgOrPdf('weekly'));
            domCache.exportMonthCalendarButton.addEventListener('click', showExportToCalendarModal);
            domCache.viewMonthlyButton.addEventListener('click', () => switchViewMode('monthly'));
            domCache.viewAnnualButton.addEventListener('click', () => switchViewMode('annual'));
            domCache.scheduleTableBody.addEventListener('dblclick', handleTableDblClick);
            domCache.scheduleTableBody.addEventListener('dragstart', handleDragStart);
            domCache.scheduleTableBody.addEventListener('dragover', handleDragOver);
            domCache.scheduleTableBody.addEventListener('dragleave', handleDragLeave);
            domCache.scheduleTableBody.addEventListener('drop', handleDrop);
            domCache.scheduleTableBody.addEventListener('dragend', handleDragEnd);

            domCache.scheduleTableBody.addEventListener('mousedown', handleCellMouseDown);
            document.addEventListener('mousemove', handleDocumentMouseMove);
            document.addEventListener('mouseup', handleDocumentMouseUp);

            domCache.scheduleTableBody.addEventListener('touchstart', handleCellTouchStart, { passive: false });
            document.addEventListener('touchmove', handleDocumentTouchMove, { passive: false });
            document.addEventListener('touchend', handleDocumentTouchEnd);


            domCache.scheduleTableBody.addEventListener('contextmenu', (event) => {
                if (event.target.closest('td.shift-cell') && wasLongPress) {
                    const cellInfo = getCellInfoFromElement(event.target.closest('td.shift-cell'));
                    if(cellInfo) {
                        const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                        if (!SHIFT_TYPES.includes(currentValue)) {
                            event.preventDefault();
                        }
                    }
                }
            });

            domCache.applyColorsButton.addEventListener('click', applyAndSaveColorsAndTimes);
            domCache.resetColorsButton.addEventListener('click', resetColorsAndTimes);
            domCache.generalNotesTextarea.addEventListener('input', () => {
                hasUnsavedChanges = true;
                updateUnsavedChangesIndicator();
                if (Object.keys(scheduleData).length > 0 || domCache.generalNotesTextarea.value.trim()) {
                    domCache.saveLocalButton.disabled = false;
                }
                clearTimeout(notesDebounceTimer);
                notesDebounceTimer = setTimeout(() => {
                    const lastUndoState = undoStack.length > 0 ? undoStack[undoStack.length - 1] : null;
                    if (!lastUndoState || lastUndoState.generalNotes !== domCache.generalNotesTextarea.value) {
                         // saveStateForUndo("Notas generales modificadas.");
                    }
                }, 1500);
            });


            domCache.modalConfirmAddEmployee.addEventListener('click', handleAddEmployeeFromModal);
            domCache.modalCancelAddEmployee.addEventListener('click', () => hideModal(domCache.addEmployeeModal));
            domCache.addEmployeeModal.addEventListener('click', (event) => {
                if (event.target === domCache.addEmployeeModal) hideModal(domCache.addEmployeeModal);
            });
            domCache.modalConfirmDeleteEmployee.addEventListener('click', confirmEmployeeDeletion);
            domCache.modalCancelDeleteEmployee.addEventListener('click', () => hideModal(domCache.deleteEmployeeModal, () => {
                if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
            }));
            domCache.deleteEmployeeModal.addEventListener('click', (event) => {
                if (event.target === domCache.deleteEmployeeModal) hideModal(domCache.deleteEmployeeModal, () => {
                    if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
                });
            });
            domCache.modalConfirmFilename.addEventListener('click', handleFilenameConfirm);
            domCache.modalCancelFilename.addEventListener('click', () => hideModal(domCache.filenameModal, () => {
                currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
            }));
            domCache.filenameModal.addEventListener('click', (event) => {
                if (event.target === domCache.filenameModal) hideModal(domCache.filenameModal, () => {
                    currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
                });
            });
            domCache.modalConfirmExportCalendar.addEventListener('click', () => {
                const selectedEmployee = domCache.modalCalendarEmployeeSelect.value;
                if (selectedEmployee) exportToCalendar(selectedEmployee);
                else showToast('Por favor, selecciona un empleado para exportar.', 'error');
                hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';});
            });
            domCache.modalCancelExportCalendar.addEventListener('click', () => hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';}));
            domCache.exportCalendarModal.addEventListener('click', (event) => {
                if (event.target === domCache.exportCalendarModal) hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = '';});
            });

            if (domCache.footerHeartElement) {
                domCache.footerHeartElement.addEventListener('click', handleFooterHeartClick);
            }

            window.addEventListener('beforeunload', (event) => {
                if (hasUnsavedChanges) { event.preventDefault(); event.returnValue = ''; }
            });

            document.addEventListener('mousedown', (event) => {
                if (activeColorPalette && !activeColorPalette.contains(event.target) &&
                    !event.target.closest('.legend-color-swatch')) {
                    closeColorPalette();
                }
                const isClickOnTableBody = event.target.closest('#schedule-table-body');
                const isClickOnToolbar = event.target.closest('#multiselect-toolbar');
                const isClickOnModal = event.target.closest('.modal-content');
                const isClickOnLegendItem = event.target.closest('.legend-item-container');
                const isClickOnControls = event.target.closest('#controls-section');

                // Se añade comprobación para no limpiar selección si se hace clic en la nueva sección de estadísticas
                const isClickOnNewStatsSection = event.target.closest('#statistics-section');


                if (!isClickOnTableBody && !isClickOnToolbar && !isClickOnModal && !isClickOnLegendItem && !isClickOnControls && !isClickOnNewStatsSection && selectedCells.length > 0) {
                    clearSelection();
                }
            });


            if (domCache.undoButton) {
                domCache.undoButton.addEventListener('click', undoChange);
            }
            if (domCache.redoButton) {
                domCache.redoButton.addEventListener('click', redoChange);
            }

            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey || event.metaKey) {
                    if (event.key === 'z' || event.key === 'Z') {
                        event.preventDefault();
                        if (domCache.undoButton && !domCache.undoButton.disabled) undoChange();
                    } else if (event.key === 'y' || event.key === 'Y') {
                        event.preventDefault();
                        if (domCache.redoButton && !domCache.redoButton.disabled) redoChange();
                    }
                } else if (event.key === 'Escape') {
                    if (selectedCells.length > 0) clearSelection();
                    if (domCache.addEmployeeModal && !domCache.addEmployeeModal.classList.contains('hidden-by-default')) hideModal(domCache.addEmployeeModal);
                    if (domCache.deleteEmployeeModal && !domCache.deleteEmployeeModal.classList.contains('hidden-by-default')) hideModal(domCache.deleteEmployeeModal, () => { if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null; });
                    if (domCache.filenameModal && !domCache.filenameModal.classList.contains('hidden-by-default')) hideModal(domCache.filenameModal, () => { currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = ''; });
                    if (domCache.exportCalendarModal && !domCache.exportCalendarModal.classList.contains('hidden-by-default')) hideModal(domCache.exportCalendarModal, () => { domCache.modalCalendarEmployeeSelect.innerHTML = ''; });
                    if (domCache.tipsModal && !domCache.tipsModal.classList.contains('hidden-by-default')) hideModal(domCache.tipsModal);
                    if (domCache.customEventModal && !domCache.customEventModal.classList.contains('hidden-by-default')) hideCustomEventModal();
                    if (domCache.confirmLoadCsvModal && !domCache.confirmLoadCsvModal.classList.contains('hidden-by-default')) {
                        hideModal(domCache.confirmLoadCsvModal);
                        domCache.csvFileInput.value = '';
                        currentConfirmAction = null;
                    }
                    if (domCache.saveLocalHelpModal && !domCache.saveLocalHelpModal.classList.contains('hidden-by-default')) {
                        hideModal(domCache.saveLocalHelpModal);
                    }
                    // Cerrar vistas de estadísticas nuevas si están abiertas
                    if (domCache.individualChartsSection && !domCache.individualChartsSection.classList.contains('hidden')) {
                         domCache.individualChartsSection.classList.add('hidden');
                         if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                    }
                    if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                        domCache.generalPlantillaStatsSection.classList.add('hidden');
                        if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                    }
                }
            });

            if (domCache.helpIconContainer) {
                domCache.helpIconContainer.addEventListener('click', () => {
                    showModal(domCache.tipsModal);
                });
            }
            if (domCache.closeTipsModalButton) {
                domCache.closeTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.okTipsModalButton) {
                domCache.okTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.tipsModal) {
                domCache.tipsModal.addEventListener('click', (event) => {
                    if (event.target === domCache.tipsModal) {
                        hideModal(domCache.tipsModal);
                    }
                });
            }

            if (domCache.modalConfirmCustomEvent) {
                domCache.modalConfirmCustomEvent.addEventListener('click', handleConfirmCustomEvent);
            }
            if (domCache.modalCancelCustomEvent) {
                domCache.modalCancelCustomEvent.addEventListener('click', hideCustomEventModal);
            }
            if (domCache.customEventModal) {
                domCache.customEventModal.addEventListener('click', (event) => {
                    if (event.target === domCache.customEventModal) {
                        hideCustomEventModal();
                    }
                });
            }

            domCache.modalConfirmLoadCsv.addEventListener('click', () => {
                hideModal(domCache.confirmLoadCsvModal);

                if (currentConfirmAction === 'applyEmptyTemplate') {
                    applyEmptyScheduleTemplate();
                } else {
                    const fileInput = domCache.csvFileInput;
                    if (fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                const csvContent = e.target.result;
                                parseCSV(csvContent);

                                if (isDataLoadedForStats()) {
                                    if (file) {
                                        domCache.csvFileInput.dataset.uploadedFileName = file.name;
                                    }
                                    undoStack = [];
                                    redoStack = [];
                                    localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                                    localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
                                    updateUndoRedoButtonsState();
                                    populateMonthTabs();
                                    currentSelectedMonth = 1;
                                    hasUnsavedChanges = false;
                                    updateUnsavedChangesIndicator();
                                    enableControls(true);
                                    switchViewMode('monthly');
                                    showToast('Horario cargado correctamente desde CSV.', 'success');
                                } else {
                                    showToast('El CSV está vacío o no tiene el formato esperado.', 'error');
                                    resetToInitialState();
                                }
                            } catch (error) {
                                console.error("Error al procesar el CSV (confirmado):", error);
                                showToast(`Error al procesar el CSV: ${error.message}`, 'error');
                                resetToInitialState();
                            } finally {
                                fileInput.value = '';
                            }
                        };
                        reader.readAsText(file, 'UTF-8');
                    } else if (currentConfirmAction !== 'applyEmptyTemplate' && domCache.csvFileInput.value) {
                        domCache.csvFileInput.value = '';
                    }
                }
                currentConfirmAction = null;
            });

            domCache.modalCancelLoadCsv.addEventListener('click', () => {
                hideModal(domCache.confirmLoadCsvModal);
                domCache.csvFileInput.value = '';
                currentConfirmAction = null;
            });

            domCache.confirmLoadCsvModal.addEventListener('click', (event) => {
                if (event.target === domCache.confirmLoadCsvModal) {
                    hideModal(domCache.confirmLoadCsvModal);
                    domCache.csvFileInput.value = '';
                    currentConfirmAction = null;
                }
            });


            if (domCache.autosaveToggle) {
                domCache.autosaveToggle.addEventListener('change', (event) => {
                    toggleAutosave(event.target.checked);
                });
            }

            if (domCache.saveLocalHelpIcon) {
                domCache.saveLocalHelpIcon.addEventListener('click', () => {
                    showModal(domCache.saveLocalHelpModal);
                });
            }
            if (domCache.closeSaveLocalHelpModalIcon) {
                domCache.closeSaveLocalHelpModalIcon.addEventListener('click', () => {
                    hideModal(domCache.saveLocalHelpModal);
                });
            }
            if (domCache.closeSaveLocalHelpModalButton) {
                domCache.closeSaveLocalHelpModalButton.addEventListener('click', () => {
                    hideModal(domCache.saveLocalHelpModal);
                });
            }
            if (domCache.saveLocalHelpModal) {
                domCache.saveLocalHelpModal.addEventListener('click', (event) => {
                    if (event.target === domCache.saveLocalHelpModal) {
                        hideModal(domCache.saveLocalHelpModal);
                    }
                });
            }

            // Event listeners para los nuevos botones de estadísticas (se añadirán con el JS de estadísticas)
            setupNewStatisticsEventListeners(); // <--- ESTA ES LA LÍNEA AÑADIDA
        }



        // --- INICIALIZACIÓN ---
        document.addEventListener('DOMContentLoaded', () => {
            cacheDOMElements();
            if (domCache.logoContainer) {
                domCache.logoContainer.innerHTML = SVG_FINAL_LOGO_MARKUP;
            }
            setupEventListeners();
            loadYearFromLocalStorage();
            loadCustomColors();
            loadCustomShiftTimes();
            updateLegend();
            loadChangeHistory();

            setupMultiselectToolbar();
            updateMultiselectToolbar();

			const dataLoaded = loadDataFromLocalStorage(); 
			if (dataLoaded) {
				handleViewChange(); 
				initializeAndRenderNewStatistics(); // <--- MODIFICADO/AÑADIDO
			} else {
				enableControls(false);
				renderAddEmployeeButtonInTable();
				initializeAndRenderNewStatistics(); // <--- MODIFICADO/AÑADIDO (para mostrar placeholder)
			}

            renderChangeHistory();
            updateViewModeUI();
            updateCalendarExportButtonsState();
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState();

            const savedAutosaveState = localStorage.getItem(LOCAL_STORAGE_KEY_AUTOSAVE);
            if (savedAutosaveState !== null) {
                toggleAutosave(savedAutosaveState === 'true');
            } else {
                toggleAutosave(false);
            }

            // Inicialización de la nueva sección de estadísticas (se hará con el JS específico)
        });

        // --- MODALES ---
        function showModal(modalElement, elementToFocus = null) {
            if (!modalElement) return;
            modalElement.classList.remove('hidden-by-default');
            if (elementToFocus) {
                elementToFocus.focus();
                if (typeof elementToFocus.select === 'function') elementToFocus.select();
            }
        }

        function hideModal(modalElement, cleanupFunction = null) {
            if (!modalElement) return;
            modalElement.classList.add('hidden-by-default');
            if (typeof cleanupFunction === 'function') cleanupFunction();
        }

        function showCustomEventModal(title, initialText = "") {
            if (!domCache.customEventModal || !domCache.customEventModalTitle || !domCache.modalCustomEventInput) {
                console.error("Error: Elementos de la modal de evento personalizado no encontrados en domCache.");
                return;
            }
            domCache.customEventModalTitle.textContent = title;
            domCache.modalCustomEventInput.value = initialText;
            showModal(domCache.customEventModal, domCache.modalCustomEventInput);
        }

        function hideCustomEventModal() {
            if (!domCache.customEventModal) {
                console.error("Error: Modal de evento personalizado no encontrada en domCache.");
                return;
            }
            hideModal(domCache.customEventModal);
            cellsBeingEditedViaEventModal = [];
            isSingleCellEditViaModal = false;
            if (domCache.modalCustomEventInput) {
                domCache.modalCustomEventInput.value = "";
            }
        }

        function handleConfirmCustomEvent() {
            if (!domCache.modalCustomEventInput) {
                console.error("Error: Input de la modal de evento personalizado no encontrado.");
                return;
            }
            const newText = domCache.modalCustomEventInput.value.trim();

            if (newText.includes(',')) {
                showToast('El texto del evento no puede contener comas (,).', 'error');
                if (domCache.modalCustomEventInput) {
                    domCache.modalCustomEventInput.focus();
                }
                return;
            }

            let changesMadeCount = 0;
            let undoDescription = `Modificación de ${cellsBeingEditedViaEventModal.length} celda(s) a '${newText === "" ? "Vacío" : newText}'.`;

            if (cellsBeingEditedViaEventModal.length === 1) {
                const cellToEdit = cellsBeingEditedViaEventModal[0];
                const originalVal = cellToEdit.originalValue;
                undoDescription = `Evento de ${cellToEdit.employee} (${cellToEdit.day}/${SHORT_MONTH_NAMES[cellToEdit.month-1]}) cambiado de '${originalVal || "Vacío"}' a '${newText || "Vacío"}'.`;
            }

            if (cellsBeingEditedViaEventModal.some(cell => cell.originalValue !== newText)) {
                saveStateForUndo(undoDescription);
            }

            cellsBeingEditedViaEventModal.forEach((cellToEdit, index) => {
                const { tdElement, employee, month, day, originalValue } = cellToEdit;
                if (originalValue !== newText) {
                    if (!scheduleData[employee]) scheduleData[employee] = {};
                    if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
                    scheduleData[employee][month][day] = newText;
                    tdElement.textContent = newText;
                    applyShiftCellStyles(tdElement, newText);
                    changesMadeCount++;
                }
            });

            if (changesMadeCount > 0) {
            }
            hideCustomEventModal();
			initializeAndRenderNewStatistics();
            if (isSingleCellEditViaModal) {
                clearSelection();
            }
        }


        // --- OTRAS FUNCIONES DE UI ---
        function handleFooterHeartClick() {
            footerHeartClicks++;
            if (footerHeartClicks === 10) {
                if (domCache.creatorNameElement) {
                    domCache.creatorNameElement.classList.add('hidden-name');
                    setTimeout(() => {
                        domCache.creatorNameElement.textContent = 'Scrulius';
                        domCache.creatorNameElement.classList.remove('hidden-name');
                        domCache.creatorNameElement.classList.add('visible-name');
                        showToast('✨ ¡Easter egg activado! ✨', 'success');
                    }, 500);
                }
            }
        }

        function loadYearFromLocalStorage() {
            const savedYear = localStorage.getItem(LOCAL_STORAGE_KEY_YEAR);
            if (savedYear && !isNaN(parseInt(savedYear))) {
                yearOfSchedule = parseInt(savedYear);
            } else {
                yearOfSchedule = new Date().getFullYear();
            }
            domCache.yearInput.value = yearOfSchedule;
        }

        function handleYearChange(event) {
            const newYear = parseInt(event.target.value);
            if (!isNaN(newYear) && newYear > 1900 && newYear < 2200 && newYear !== yearOfSchedule) {
                yearOfSchedule = newYear;
                localStorage.setItem(LOCAL_STORAGE_KEY_YEAR, yearOfSchedule.toString());
                hasUnsavedChanges = true;
                updateUnsavedChangesIndicator();

                if (isDataLoadedForStats()) {
                    handleViewChange();
                    initializeAndRenderNewStatistics();
                }
                showToast(`Año del horario actualizado a ${yearOfSchedule}.`, 'info');
            } else if (newYear === yearOfSchedule) {
                // No action
            } else {
                event.target.value = yearOfSchedule;
                showToast('Por favor, introduce un año válido (ej. 2024).', 'error');
            }
        }

        function addChangeToHistory(description) {
            const newChange = { timestamp: new Date(), description: description };
            changeHistory.unshift(newChange);
            if (changeHistory.length > MAX_HISTORY_ITEMS) changeHistory.pop();
            renderChangeHistory();
        }


        function renderChangeHistory() {
            domCache.changeHistoryList.innerHTML = '';
            if (changeHistory.length === 0) {
                domCache.changeHistoryList.appendChild(createElement('li', {
                    textContent: 'No hay cambios recientes.', className: 'text-center text-gray-400'
                }));
                return;
            }
            changeHistory.forEach(change => {
                const timeSpan = createElement('span', {
                    className: 'history-time', textContent: `[${new Date(change.timestamp).toLocaleTimeString('es-ES')}]`
                });
                domCache.changeHistoryList.appendChild(createElement('li', {}, [ timeSpan, ` ${change.description}` ]));
            });
        }

        function loadChangeHistory() {
            const savedHistory = localStorage.getItem(LOCAL_STORAGE_KEY_HISTORY);
            if (savedHistory) {
                try {
                    changeHistory = JSON.parse(savedHistory).map(item => ({
                        ...item, timestamp: new Date(item.timestamp)
                    }));
                } catch (e) { console.error("Error al cargar historial:", e); changeHistory = []; }
            }
        }

        function loadCustomColors() {
            const savedColors = localStorage.getItem(LOCAL_STORAGE_KEY_COLORS);
            if (savedColors) {
                try {
                    const parsedColors = JSON.parse(savedColors);
                    let valid = true;
                    const keysToValidate = [...SHIFT_TYPES, 'empty'];
                    keysToValidate.forEach(type => {
                        if (!parsedColors[type] || !parsedColors[type].bg || !parsedColors[type].text || !parsedColors[type].hexBg || !parsedColors[type].hexText) {
                            valid = false;
                        }
                    });
                    if (valid) currentShiftColors = parsedColors;
                    else throw new Error("Formato de colores guardados inválido.");
                } catch (e) {
                    console.error("Error al cargar colores, usando por defecto.", e);
                    currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
                    localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS);
                }
            } else {
                 currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            }
            Object.keys(currentShiftColors).forEach(key => {
                if (!currentShiftColors[key].hexBg || !currentShiftColors[key].hexText) {
                    const defaultColorForKey = DEFAULT_SHIFT_COLORS[key] || DEFAULT_SHIFT_COLORS.empty;
                    const foundColor = AVAILABLE_COLORS.find(c => c.bg === currentShiftColors[key].bg) ||
                                     AVAILABLE_COLORS.find(c => c.bg === defaultColorForKey.bg) ||
                                     AVAILABLE_COLORS[0];
                    currentShiftColors[key].hexBg = foundColor.hexBg || '#ffffff';
                    currentShiftColors[key].hexText = foundColor.hexText || '#000000';
                }
            });
        }

        function loadCustomShiftTimes() {
            const savedTimes = localStorage.getItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
            if (savedTimes) {
                try {
                    const parsedTimes = JSON.parse(savedTimes);
                    let valid = true;
                    Object.keys(DEFAULT_SHIFT_TIMES).forEach(type => {
                        if (!parsedTimes[type] || !Array.isArray(parsedTimes[type].start) || parsedTimes[type].start.length !== 2 ||
                            !Array.isArray(parsedTimes[type].end) || parsedTimes[type].end.length !== 2 ||
                            typeof parsedTimes[type].nextDayEnd !== 'boolean') {
                            valid = false;
                        }
                    });
                    if (valid) currentUserShiftTimes = parsedTimes;
                    else throw new Error("Formato de horarios de turno inválido.");
                } catch (e) {
                    console.error("Error al cargar horarios de turno, usando por defecto.", e);
                    currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
                    localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
                }
            } else {
                currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            }
        }

		function applyAndSaveColorsAndTimes() {
			localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, JSON.stringify(currentShiftColors));
			localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, JSON.stringify(currentUserShiftTimes));

			const legendItems = domCache.legendItemsContainer.querySelectorAll('.legend-item-container');
			legendItems.forEach(item => {
				item.classList.add('legend-item-flash');
				setTimeout(() => item.classList.remove('legend-item-flash'), 700);
			});

			updateLegend(); 
			handleViewChange(); 
			initializeAndRenderNewStatistics(); 
			showToast('Colores y horarios de turno aplicados y guardados.', 'success');

			if (domCache.applyColorsButton) domCache.applyColorsButton.disabled = true;
			if (domCache.resetColorsButton) domCache.resetColorsButton.disabled = false; 

			hasUnsavedChanges = true; 
			updateUnsavedChangesIndicator();
		}

		function resetColorsAndTimes() {
			currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
			currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
			localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS); 
			localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES); 

			updateLegend(); 
			handleViewChange(); 
			initializeAndRenderNewStatistics();
			showToast('Colores y horarios de turno restaurados a los valores por defecto.', 'info');

			if (domCache.applyColorsButton) domCache.applyColorsButton.disabled = false; 
			if (domCache.resetColorsButton) domCache.resetColorsButton.disabled = true;

			hasUnsavedChanges = true; 
			updateUnsavedChangesIndicator();
		}


        function formatTimeForInput(hours, minutes) {
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function updateLegend() {
            domCache.legendItemsContainer.innerHTML = '';
            const relevantShiftTypesForTimeInput = ['M', 'T', 'N', 'M2', 'T2', 'N2'];

            const legendOrder = ['M', 'T', 'N', 'M2', 'T2', 'N2', 'L', 'V', 'B', 'empty'];

            legendOrder.forEach(type => {
                const colorInfo = currentShiftColors[type];
                if (!colorInfo) {
                    console.warn(`Color configuration for shift type "${type}" not found in currentShiftColors.`);
                    return;
                }

                const legendItemDiv = createElement('div', { className: 'legend-item-container' });

                const swatch = createElement('span', {
                    className: `legend-color-swatch ${colorInfo.bg}`,
                    dataset: { shiftType: type },
                    title: `Cambiar color para ${type === 'empty' ? 'Otro' : (SHIFT_TYPE_FULL_NAMES[type] || type)}`
                });
                swatch.addEventListener('click', (event) => openColorPalette(event, type));

                const labelText = type === 'empty' ? 'Otro' : `${SHIFT_TYPE_FULL_NAMES[type] || type} (${type === 'empty' ? '' : type})`;
                const label = createElement('span', { textContent: labelText, className: 'mr-2' });

                legendItemDiv.appendChild(swatch);
                legendItemDiv.appendChild(label);

                if (relevantShiftTypesForTimeInput.includes(type)) {
                    const timeConfig = currentUserShiftTimes[type] || DEFAULT_SHIFT_TIMES[type];
                    if (timeConfig && timeConfig.start && timeConfig.end) {
                        const timeInputsDiv = createElement('div', { className: 'legend-time-inputs' });

                        const startTimeInput = createElement('input', {
                            attributes: { type: 'time', value: formatTimeForInput(timeConfig.start[0], timeConfig.start[1])},
                            dataset: { shiftType: type, timeType: 'start' }
                        });
                        const endTimeInput = createElement('input', {
                            attributes: { type: 'time', value: formatTimeForInput(timeConfig.end[0], timeConfig.end[1])},
                            dataset: { shiftType: type, timeType: 'end' }
                        });

                        startTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);
                        endTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);

                        timeInputsDiv.appendChild(startTimeInput);
                        timeInputsDiv.appendChild(createElement('span', {textContent: '-', className: 'mx-1'}));
                        timeInputsDiv.appendChild(endTimeInput);
                        legendItemDiv.appendChild(timeInputsDiv);
                    } else {
                         console.warn(`Time configuration for shift type "${type}" not found or incomplete.`);
                    }
                }
                domCache.legendItemsContainer.appendChild(legendItemDiv);
            });
        }

        function handleShiftTimeChangeInLegend(event) {
            domCache.applyColorsButton.disabled = false;
            domCache.resetColorsButton.disabled = false;
        }


        function openColorPalette(event, shiftTypeToEdit) {
            event.stopPropagation();
            closeColorPalette();

            const swatchElement = event.target;
            const swatchRect = swatchElement.getBoundingClientRect();

            activeColorPalette = createElement('div', { className: 'color-palette-popup' });
            document.body.appendChild(activeColorPalette);

            AVAILABLE_COLORS.forEach((colorOption) => {
                const paletteSwatch = createElement('div', {
                    className: `palette-color-swatch ${colorOption.bg}`,
                    title: colorOption.name
                });
                paletteSwatch.addEventListener('click', () => {
                    currentShiftColors[shiftTypeToEdit] = {
                        bg: colorOption.bg,
                        text: colorOption.text,
                        name: colorOption.name,
                        hexBg: colorOption.hexBg || tailwindColorToHex(colorOption.bg),
                        hexText: colorOption.hexText || tailwindColorToHex(colorOption.text, true)
                    };
                    swatchElement.className = `legend-color-swatch ${colorOption.bg}`;
                    closeColorPalette();
                    domCache.applyColorsButton.disabled = false;
                    domCache.resetColorsButton.disabled = false;
                });
                activeColorPalette.appendChild(paletteSwatch);
            });

            let top = swatchRect.bottom + window.scrollY + 5;
            let left = swatchRect.left + window.scrollX;
            const paletteRect = activeColorPalette.getBoundingClientRect();

            if (left + paletteRect.width > window.innerWidth) {
                left = window.innerWidth - paletteRect.width - 10;
            }
            if (top + paletteRect.height > window.innerHeight) {
                top = swatchRect.top + window.scrollY - paletteRect.height - 5;
            }
            activeColorPalette.style.top = `${Math.max(0,top)}px`;
            activeColorPalette.style.left = `${Math.max(0,left)}px`;
        }

        function closeColorPalette() {
            if (activeColorPalette) {
                activeColorPalette.remove();
                activeColorPalette = null;
            }
        }

        function tailwindColorToHex(twClass, isTextClass = false) {
            const foundInAvailable = AVAILABLE_COLORS.find(c => c.bg === twClass || c.text === twClass);
            if (foundInAvailable) {
                return isTextClass ? (foundInAvailable.hexText || '#000000') : (foundInAvailable.hexBg || '#ffffff');
            }
            if (twClass === 'bg-white') return '#ffffff';
            if (twClass === 'text-black') return '#000000';
            return isTextClass ? '#000000' : '#ffffff';
        }

        function showToast(message, type = 'info', duration = 3500) {
            let iconClass = 'fas fa-info-circle', bgColorClass = 'bg-blue-500';
            if (type === 'success') { bgColorClass = 'bg-green-500'; iconClass = 'fas fa-check-circle'; }
            else if (type === 'error') { bgColorClass = 'bg-red-500'; iconClass = 'fas fa-times-circle'; }
            else if (type === 'warning') { bgColorClass = 'bg-yellow-500'; iconClass = 'fas fa-exclamation-triangle'; }

            const toast = createElement('div', {
                className: `flex items-center p-4 rounded-lg shadow-xl text-sm text-white ${bgColorClass} transition-opacity duration-300 opacity-0`,
                innerHTML: `<i class="${iconClass} mr-3 text-xl"></i><span>${message}</span>`
            });
            domCache.toastContainer.appendChild(toast);
            setTimeout(() => toast.classList.remove('opacity-0'), 50);
            setTimeout(() => {
                toast.classList.add('opacity-0');
                setTimeout(() => toast.remove(), 500);
            }, duration);
        }

        function enableControls(dataLoaded = true) {
            const disable = !dataLoaded;
            domCache.exportCsvButton.disabled = disable;
            domCache.downloadImageButton.disabled = disable;

            if (domCache.viewModeButtonsContainer) {
                domCache.viewModeButtonsContainer.classList.toggle('hidden-by-default', !dataLoaded);
            }
            domCache.viewMonthlyButton.disabled = disable;
            domCache.viewAnnualButton.disabled = disable;
            domCache.saveLocalButton.disabled = !dataLoaded || !hasUnsavedChanges;

            updateCalendarExportButtonsState();

            if (dataLoaded) {
                domCache.welcomeMessage.classList.add('hidden-by-default');
                domCache.scheduleDisplaySection.classList.remove('hidden-by-default');
                domCache.noDataMessage.classList.add('hidden-by-default');
                domCache.monthTabsContainer.style.display = currentViewMode === 'monthly' ? 'flex' : 'none';
            } else {
                domCache.welcomeMessage.classList.remove('hidden-by-default');
                domCache.scheduleDisplaySection.classList.add('hidden-by-default');
                domCache.noDataMessage.classList.remove('hidden-by-default');
                domCache.monthTabsContainer.style.display = 'none';
                if (domCache.viewModeButtonsContainer) {
                    domCache.viewModeButtonsContainer.classList.add('hidden-by-default');
                }
            }
        }

        function isDataLoadedForSave() {
            return Object.keys(scheduleData).length > 0 || employeeNamesOrdered.length > 0 || domCache.generalNotesTextarea.value.trim();
        }
        function isDataLoadedForStats() { // General check if any data is loaded for the app
            return Object.keys(scheduleData).length > 0 && employeeNamesOrdered.length > 0;
        }

        function generateDefaultFilename(context, sourceFileName = null) {
            let baseName = "horario";
            const currentMonthNameSafe = MONTH_NAMES[currentSelectedMonth - 1].toLowerCase().replace(/\s+/g, '_');
            const year = yearOfSchedule;

            switch (context) {
                case 'csv':
                    if (sourceFileName === TEMPLATE_FLAG_FILENAME) {
                        baseName = `horario_plantilla_${year}`;
                    } else if (sourceFileName && typeof sourceFileName === 'string' && sourceFileName.lastIndexOf('.') > 0 && sourceFileName.lastIndexOf('.') < sourceFileName.length - 1) {
                        baseName = `${sourceFileName.substring(0, sourceFileName.lastIndexOf('.'))}_${year}`;
                    } else {
                        if (sourceFileName) {
                             showToast('Nombre de archivo original no válido, usando nombre genérico para CSV.', 'warning');
                        }
                        if (isDataLoadedForStats()) {
                            baseName = `horario_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}_exportado`;
                        } else {
                            baseName = `horario_vacio_${year}_exportado`;
                        }
                    }
                    break;
                case 'pdfWeekly': baseName += `_semanal_${currentMonthNameSafe}_${year}`; break;
                case 'pdfMonthly': baseName += `_mensual_${currentMonthNameSafe}_${year}`; break;
                case 'pdfAnnual': baseName += `_anual_${year}`; break;
                case 'calendar':
                    baseName += `_calendar_${sourceFileName ? sourceFileName.toLowerCase().replace(/\s+/g, '_') : 'empleado'}_${currentMonthNameSafe}_${year}`;
                    break;
                default:
                     if (isDataLoadedForStats()) {
                        baseName += `_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}`;
                    }
            }
            return baseName.replace(/[^a-z0-9_-]/gi, '_').replace(/_{2,}/g, '_');
        }

        // --- MANEJO DE ARCHIVOS Y DATOS ---
        function handleCreateEmptyScheduleClick() {
            if (isDataLoadedForSave() || hasUnsavedChanges) {
                currentConfirmAction = 'applyEmptyTemplate';
                domCache.confirmLoadCsvMessage.textContent = "Ya hay un horario cargado. Si aplicas una plantilla vacía, el horario actual será reemplazado. ¿Deseas continuar?";
                showModal(domCache.confirmLoadCsvModal);
            } else {
                applyEmptyScheduleTemplate();
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                if (isDataLoadedForSave() || hasUnsavedChanges) {
                    currentConfirmAction = 'loadFile';
                    domCache.confirmLoadCsvMessage.textContent = hasUnsavedChanges ?
                        "Ya hay un horario cargado con cambios sin guardar. Si cargas un nuevo archivo CSV, estos cambios se perderán. ¿Deseas continuar?" :
                        "Ya hay un horario cargado. Si cargas un nuevo archivo CSV, el horario actual será reemplazado. ¿Deseas continuar?";
                    showModal(domCache.confirmLoadCsvModal);
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csvContent = e.target.result;
                        parseCSV(csvContent);

						if (isDataLoadedForStats()) {
							if (file) {
								domCache.csvFileInput.dataset.uploadedFileName = file.name;
							}
							undoStack = [];
							redoStack = [];
							localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
							localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
							updateUndoRedoButtonsState();
							populateMonthTabs();
							currentSelectedMonth = 1; 
							hasUnsavedChanges = false; 
							updateUnsavedChangesIndicator();
							enableControls(true);
							switchViewMode('monthly'); 
							initializeAndRenderNewStatistics(); 
							showToast('Horario cargado correctamente desde CSV.', 'success');
						} else {
							showToast('El CSV está vacío o no tiene el formato esperado.', 'error');
							resetToInitialState();
						}
                    } catch (error) {
                        console.error("Error al procesar el CSV:", error);
                        showToast(`Error al procesar el CSV: ${error.message}`, 'error');
                        resetToInitialState();
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        function resetToInitialState(keepNotes = false) {
            undoStack = []; redoStack = [];
            localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
            localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
            updateUndoRedoButtonsState();

            scheduleData = {}; employeeNamesOrdered = [];
            hasUnsavedChanges = false; updateUnsavedChangesIndicator();
            currentSelectedMonth = new Date().getMonth() + 1;
            yearOfSchedule = new Date().getFullYear();
            domCache.yearInput.value = yearOfSchedule;
            clearSelection();
            if (domCache.csvFileInput) {
                 domCache.csvFileInput.value = '';
                 delete domCache.csvFileInput.dataset.uploadedFileName;
            }

            enableControls(false);
            domCache.monthTabsContainer.innerHTML = '';
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes Año]';

            if (!keepNotes) domCache.generalNotesTextarea.value = '';

            currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            updateLegend();
            domCache.applyColorsButton.disabled = true;
            domCache.resetColorsButton.disabled = true;

            localStorage.removeItem(LOCAL_STORAGE_KEY_SCHEDULE);
            localStorage.removeItem(LOCAL_STORAGE_KEY_NOTES);
            localStorage.removeItem(LOCAL_STORAGE_KEY_VIEW);
            localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS);
            localStorage.removeItem(LOCAL_STORAGE_KEY_HISTORY);
            localStorage.removeItem(LOCAL_STORAGE_KEY_YEAR);
            localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
			
			initializeAndRenderNewStatistics(); 

            renderAddEmployeeButtonInTable();
            if (domCache.viewModeButtonsContainer) {
                domCache.viewModeButtonsContainer.classList.add('hidden-by-default');
            }
            // Ocultar las nuevas secciones de estadísticas también
            if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.add('hidden');
            if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
            if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
        }


        function parseCSV(csvText) {
            scheduleData = {}; employeeNamesOrdered = [];
            const uniqueEmployeeNames = new Set();
            const lines = csvText.trim().split(/\r\n|\n/);

            if (lines.length <= 1) return;

            for (let i = 1; i < lines.length; i++) {
                const cells = lines[i].split(',');
                if (cells.length < 3) continue;

                let employeeName = cells[0].trim();
                const month = parseInt(cells[1].trim(), 10);

                if (employeeName.length >= 2 && employeeName.startsWith('"') && employeeName.endsWith('"')) {
                    employeeName = employeeName.substring(1, employeeName.length - 1).replace(/""/g, '"');
                }

                if (!employeeName || isNaN(month) || month < 1 || month > 12) continue;

                if (!scheduleData[employeeName]) {
                    scheduleData[employeeName] = {};
                    uniqueEmployeeNames.add(employeeName);
                }
                if (!scheduleData[employeeName][month]) scheduleData[employeeName][month] = {};

                const daysInMonthForCSV = getDaysInMonth(month, yearOfSchedule);

                for (let dayIndex = 1; dayIndex <= 31; dayIndex++) {
                    if (dayIndex + 1 < cells.length) {
                        let cellValue = cells[dayIndex + 1] ? cells[dayIndex + 1].trim() : "";
                        if (cellValue.length >= 2 && cellValue.startsWith('"') && cellValue.endsWith('"')) {
                            cellValue = cellValue.substring(1, cellValue.length - 1).replace(/""/g, '"');
                        }
                        if (dayIndex <= daysInMonthForCSV) {
                           scheduleData[employeeName][month][dayIndex] = cellValue;
                        }
                    } else if (dayIndex <= daysInMonthForCSV) {
                        scheduleData[employeeName][month][dayIndex] = "";
                    }
                }
            }
            employeeNamesOrdered = Array.from(uniqueEmployeeNames);
        }

        function saveScheduleToLocalStorage(clearUndoRedoHistory = true) {
            if (!isDataLoadedForSave()) {
                showToast('No hay datos para guardar.', 'error'); return;
            }
            try {
                const dataToSave = {
                    schedule: scheduleData,
                    employeeOrder: employeeNamesOrdered,
                    selectedMonth: currentSelectedMonth,
                    uploadedCsvName: domCache.csvFileInput?.dataset?.uploadedFileName || null
                };
                localStorage.setItem(LOCAL_STORAGE_KEY_SCHEDULE, JSON.stringify(dataToSave));
                localStorage.setItem(LOCAL_STORAGE_KEY_NOTES, domCache.generalNotesTextarea.value);
                localStorage.setItem(LOCAL_STORAGE_KEY_VIEW, currentViewMode);
                localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, JSON.stringify(currentShiftColors));
                localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, JSON.stringify(currentUserShiftTimes));
                localStorage.setItem(LOCAL_STORAGE_KEY_HISTORY, JSON.stringify(changeHistory));
                localStorage.setItem(LOCAL_STORAGE_KEY_YEAR, yearOfSchedule.toString());
                localStorage.setItem(LOCAL_STORAGE_KEY_UNDO_STACK, JSON.stringify(undoStack));
                localStorage.setItem(LOCAL_STORAGE_KEY_REDO_STACK, JSON.stringify(redoStack));


                hasUnsavedChanges = false;
                updateUnsavedChangesIndicator();
                domCache.saveLocalButton.disabled = true;

                domCache.applyColorsButton.disabled = true;
                domCache.resetColorsButton.disabled = JSON.stringify(currentShiftColors) === JSON.stringify(DEFAULT_SHIFT_COLORS) &&
                                                   JSON.stringify(currentUserShiftTimes) === JSON.stringify(DEFAULT_SHIFT_TIMES);

                if (clearUndoRedoHistory === true) {
                     showToast('Datos guardados localmente.', 'success');
                } else if (clearUndoRedoHistory === false && !isAutosaveEnabled) {
                     showToast('Datos guardados localmente.', 'success');
                }


            } catch (error) {
                console.error("Error al guardar en localStorage:", error);
                showToast('Error al guardar. Espacio lleno o navegador no compatible.', 'error');
            }
        }

        function loadDataFromLocalStorage() {
            let dataLoadedSuccessfully = false;
            try {
                const savedDataString = localStorage.getItem(LOCAL_STORAGE_KEY_SCHEDULE);
                const savedNotes = localStorage.getItem(LOCAL_STORAGE_KEY_NOTES);
                const savedView = localStorage.getItem(LOCAL_STORAGE_KEY_VIEW);

                if (savedNotes) domCache.generalNotesTextarea.value = savedNotes;
                if (savedView) currentViewMode = savedView;

                if (savedDataString) {
                    const savedData = JSON.parse(savedDataString);
                    if (savedData && savedData.schedule && savedData.employeeOrder) {
                        scheduleData = savedData.schedule;
                        employeeNamesOrdered = savedData.employeeOrder;
                        currentSelectedMonth = savedData.selectedMonth || (new Date().getMonth() + 1);
                        if (domCache.csvFileInput && savedData.uploadedCsvName) {
                            domCache.csvFileInput.dataset.uploadedFileName = savedData.uploadedCsvName;
                        } else if (domCache.csvFileInput) {
                            delete domCache.csvFileInput.dataset.uploadedFileName;
                        }


                        if (isDataLoadedForStats()) {
                            dataLoadedSuccessfully = true;
                            hasUnsavedChanges = false;
                            populateMonthTabs();
                            enableControls(true);
                            showToast('Datos cargados desde almacenamiento local.', 'success');
                        }
                    }
                }

                const savedUndoStackString = localStorage.getItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                if (savedUndoStackString) {
                    try {
                        undoStack = JSON.parse(savedUndoStackString);
                    } catch (e) {
                        console.error("Error al cargar undoStack desde localStorage:", e);
                        undoStack = [];
                    }
                } else {
                    undoStack = [];
                }

                const savedRedoStackString = localStorage.getItem(LOCAL_STORAGE_KEY_REDO_STACK);
                if (savedRedoStackString) {
                    try {
                        redoStack = JSON.parse(savedRedoStackString);
                    } catch (e) {
                        console.error("Error al cargar redoStack desde localStorage:", e);
                        redoStack = [];
                    }
                } else {
                    redoStack = [];
                }


            } catch (error) {
                console.error("Error al cargar desde localStorage:", error);
                showToast('Error al cargar datos locales. Podrían estar corruptos.', 'error');
                localStorage.removeItem(LOCAL_STORAGE_KEY_SCHEDULE);
                undoStack = []; redoStack = [];
                localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
            }

            if (!dataLoadedSuccessfully) {
                 enableControls(false);
                 renderAddEmployeeButtonInTable();
                 undoStack = []; redoStack = [];
            }
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState();
            return dataLoadedSuccessfully;
        }

        function applyEmptyScheduleTemplate() {
            let monthForTemplate;
            if (currentSelectedMonth >= 1 && currentSelectedMonth <= 12) {
                monthForTemplate = currentSelectedMonth;
            } else {
                monthForTemplate = new Date().getMonth() + 1;
                currentSelectedMonth = monthForTemplate;
            }
            const yearForTemplate = yearOfSchedule;
            const daysInMonthForTemplate = getDaysInMonth(monthForTemplate, yearForTemplate);

            let csvHeader = "Empleado,Mes";
            for (let i = 1; i <= 31; i++) {
                csvHeader += `,${i}`;
            }
            csvHeader += "\n";

            let employeeRow = `"Empleado Ejemplo",${monthForTemplate}`;
            for (let i = 1; i <= daysInMonthForTemplate; i++) {
                employeeRow += `,`;
            }
            for (let i = daysInMonthForTemplate + 1; i <= 31; i++) {
                employeeRow += `,`;
            }
            employeeRow += "\n";

            const csvContentInterno = csvHeader + employeeRow;

            try {
                parseCSV(csvContentInterno);

				if (isDataLoadedForStats()) {
				if (domCache.csvFileInput) {
					domCache.csvFileInput.value = '';
					domCache.csvFileInput.dataset.uploadedFileName = TEMPLATE_FLAG_FILENAME;
				}
				undoStack = []; 
				redoStack = []; 
				localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK); 
				localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK); 
				updateUndoRedoButtonsState();
				populateMonthTabs();
				hasUnsavedChanges = true; 
				updateUnsavedChangesIndicator();
				enableControls(true);
				switchViewMode('monthly');
				initializeAndRenderNewStatistics();
				showToast('Nueva plantilla de horario aplicada.', 'success');
			} else {
				showToast('Error al aplicar la plantilla vacía. No se cargaron datos.', 'error');
				resetToInitialState();
			}
            } catch (error) {
                console.error("Error al aplicar la plantilla de CSV vacío:", error);
                showToast(`Error al aplicar la plantilla: ${error.message}`, 'error');
                resetToInitialState();
            }
        }


        function showFilenameModal(title, description, defaultName, extension, confirmCallback) {
            domCache.filenameModalTitle.textContent = title;
            domCache.filenameModalDescription.textContent = description;
            domCache.modalFilenameInput.value = defaultName;
            currentFilenameConfirmCallback = confirmCallback;
            currentFilenameExtension = extension;
            showModal(domCache.filenameModal, domCache.modalFilenameInput);
        }

        function handleFilenameConfirm() {
            const filenameBase = domCache.modalFilenameInput.value.trim();
            if (!filenameBase) {
                showToast('Por favor, introduce un nombre para el archivo.', 'error');
                domCache.modalFilenameInput.focus(); return;
            }
            if (currentFilenameConfirmCallback) currentFilenameConfirmCallback(filenameBase);
            hideModal(domCache.filenameModal, () => {
                currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
            });
        }

        function prepareExportScheduleToCSV() {
            if (!isDataLoadedForStats()) {
                showToast('No hay datos para exportar.', 'error'); return;
            }
            const sourceFileNameForDefault = domCache.csvFileInput?.dataset?.uploadedFileName || null;
            const defaultName = generateDefaultFilename('csv', sourceFileNameForDefault);
            showFilenameModal("Exportar Horario a CSV", "Nombre base para el archivo CSV:", defaultName, ".csv", exportScheduleToCSV);
        }

        function exportScheduleToCSV(filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`;
            let csvContent = "Empleado,Mes,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31\n";

            employeeNamesOrdered.forEach(empName => {
                for (let month = 1; month <= 12; month++) {
                    let row = `"${empName.replace(/"/g, '""')}",${month}`;
                    const monthData = scheduleData[empName]?.[month] || {};
                    const daysInThisMonth = getDaysInMonth(month, yearOfSchedule);

                    for (let day = 1; day <= 31; day++) {
                        if (day <= daysInThisMonth) {
                            let cellValue = monthData[day] || "";
                            if (/[",\n\r]/.test(cellValue)) {
                                cellValue = `"${cellValue.replace(/"/g, '""')}"`;
                            }
                            row += `,${cellValue}`;
                        } else {
                            row += `,`;
                        }
                    }
                    csvContent += row + "\n";
                }
            });

            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = createElement("a", { attributes: { href: URL.createObjectURL(blob), download: finalFilename }, style: { visibility: 'hidden' } });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Horario exportado como ${finalFilename}.`, 'success');
        }

        // --- GENERACIÓN DE SVG Y PDF ---
        function prepareDownloadSvgOrPdf(type) {
            if (!isDataLoadedForStats()) {
                showToast('No hay horario para descargar.', 'error'); return;
            }
            if (type === 'weekly' && currentViewMode !== 'monthly') {
                 showToast('La descarga semanal solo está disponible en vista mensual.', 'warning'); return;
            }

            let defaultNameContext = type === 'weekly' ? 'pdfWeekly' : (currentViewMode === 'monthly' ? 'pdfMonthly' : 'pdfAnnual');
            const defaultName = generateDefaultFilename(defaultNameContext);
            const modalTitle = `Descargar ${type === 'weekly' ? 'Semanal' : (currentViewMode === 'monthly' ? 'Mensual' : 'Anual')} PDF`;
            showFilenameModal(modalTitle, "Nombre base para el archivo PDF:", defaultName, ".pdf", (filenameBase) => downloadSvgOrPdfInternal(type, filenameBase));
        }

        async function downloadSvgOrPdfInternal(type, filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`;
            showToast('Generando PDF, por favor espera...', 'info');

            const svgString = getSvgString(type);
            if (!svgString) { showToast('Error al generar contenido SVG.', 'error'); return; }

            try {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
                const svgElement = svgDoc.documentElement;

                if (svgElement.tagName === "parsererror" || !svgElement) {
                    throw new Error("Error al parsear SVG: " + (svgDoc.body ? svgDoc.body.innerText : "Error desconocido"));
                }

                const svgWidth = parseFloat(svgElement.getAttribute('width'));
                const svgHeight = parseFloat(svgElement.getAttribute('height'));

                if (isNaN(svgWidth) || isNaN(svgHeight) || svgWidth <= 0 || svgHeight <= 0) {
                    throw new Error(`Dimensiones SVG inválidas: ${svgWidth}x${svgHeight}`);
                }

                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: svgWidth > svgHeight ? 'l' : 'p',
                    unit: 'px',
                    format: [svgWidth, svgHeight],
                    hotfixes: ['px_scaling']
                });

                await pdf.svg(svgElement, { x: 0, y: 0, width: svgWidth, height: svgHeight });
                pdf.save(finalFilename);
                showToast(`PDF descargado como ${finalFilename}.`, 'success');
            } catch (error) {
                console.error("Error al generar PDF:", error, error.stack);
                showToast('Error al generar el PDF: ' + error.message, 'error');
            }
        }


        // --- VISTAS DE TABLA ---
        function switchViewMode(mode) {
            clearSelection();
            currentViewMode = mode;
            updateViewModeUI();
            handleViewChange();
            updateCalendarExportButtonsState();
            // if(domCache.calculateStatsButtonNew) domCache.calculateStatsButtonNew.disabled = !isDataLoadedForStats(); // Original
        }


        function updateViewModeUI() {
            const dataExists = isDataLoadedForStats();
            domCache.monthTabsContainer.style.display = (currentViewMode === 'monthly' && dataExists) ? 'flex' : 'none';
            domCache.downloadImageButton.disabled = !dataExists;
            domCache.downloadWeeklySvgButton.disabled = !dataExists || currentViewMode !== 'monthly';

            if (currentViewMode === 'annual' && dataExists) {
                domCache.downloadImageButton.title = "Descargar vista anual como PDF.";
                domCache.viewAnnualButton.classList.add('active');
                domCache.viewMonthlyButton.classList.remove('active');
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${yearOfSchedule}`;
            } else if (currentViewMode === 'monthly' && dataExists){
                domCache.downloadImageButton.title = "Descargar vista mensual como PDF.";
                domCache.viewMonthlyButton.classList.add('active');
                domCache.viewAnnualButton.classList.remove('active');
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`;
                highlightActiveMonthTab();
            } else {
                 domCache.downloadImageButton.title = "";
                 if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes Año]';
                 domCache.viewMonthlyButton.classList.remove('active');
                 domCache.viewAnnualButton.classList.remove('active');
            }
            updateCalendarExportButtonsState();
            updateUnsavedChangesIndicator();
        }

        function handleViewChange() {
            clearSelection();
            if (currentViewMode === 'annual') renderAnnualScheduleTable(yearOfSchedule);
            else renderMonthlyScheduleTable(currentSelectedMonth, yearOfSchedule);
        }

        function populateMonthTabs() {
            // Asegúrate de que domCache.monthTabsContainer está disponible
            if (!domCache.monthTabsContainer) {
                console.error("Error: domCache.monthTabsContainer no está definido.");
                return;
            }
            domCache.monthTabsContainer.innerHTML = ''; // Limpia pestañas existentes

            if (!isDataLoadedForStats()) { // Comprueba si hay datos para mostrar pestañas
                domCache.monthTabsContainer.classList.add('hidden-by-default');
                return;
            }
            domCache.monthTabsContainer.classList.remove('hidden-by-default');

            MONTH_NAMES.forEach((monthName, index) => {
                const monthNum = index + 1;
                const button = createElement('button', {
                    className: 'month-tab',
                    textContent: monthName.substring(0, 3).toUpperCase(), // Ejemplo: ENE, FEB
                    dataset: { month: monthNum.toString() }
                });

                if (monthNum === currentSelectedMonth) {
                    button.classList.add('active');
                }

                button.addEventListener('click', () => {
                    if (currentSelectedMonth !== monthNum) {
                        currentSelectedMonth = monthNum; // Actualiza el mes para el horario principal
                        switchViewMode('monthly');    // Renderiza el horario principal para el nuevo mes

                        // --- INICIO: NUEVA LÓGICA PARA SINCRONIZAR ESTADÍSTICAS ---
                        currentSelectedPeriodForMainStats = monthNum.toString(); // Actualiza el período para la tabla de estadísticas

                        // Actualiza el texto y el estado activo del dropdown principal de estadísticas
                        if (domCache.selectedMonthText) {
                            domCache.selectedMonthText.textContent = MONTH_NAMES[monthNum - 1];
                            domCache.selectedMonthText.dataset.currentMonthValue = monthNum.toString();
                        }
                        if (domCache.mainMonthDropdownOptions) {
                            domCache.mainMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                a.classList.toggle('active', a.dataset.month === monthNum.toString());
                            });
                            // Opcional: Si el dropdown estaba abierto, ciérralo
                            // toggleNewStatsMonthDropdown(false, 'month-dropdown-btn');
                        }

                        // Refresca la tabla de estadísticas para el nuevo mes
                        // Esto usará currentSelectedPeriodForMainStats que acabamos de actualizar
                        renderNewStatsTable();

                        // Si la vista de estadísticas generales está abierta, refréscala también
                        if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                            // renderGeneralPlantillaStatsCharts() usará currentSelectedPeriodForMainStats
                            renderGeneralPlantillaStatsCharts();
                        }

                        // Si la vista de detalles individuales está abierta, refréscala para el nuevo mes
                        // y actualiza su propio dropdown de mes.
                        if (domCache.individualChartsSection && !domCache.individualChartsSection.classList.contains('hidden') && currentSelectedEmployeeForDetails) {
                            const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                            if (employeeData) {
                                // Sincroniza también el dropdown de detalles individuales
                                if (domCache.detailsSelectedMonthText) {
                                    domCache.detailsSelectedMonthText.textContent = MONTH_NAMES[monthNum - 1];
                                    domCache.detailsSelectedMonthText.dataset.currentMonthValue = monthNum.toString();
                                }
                                currentSelectedPeriodForDetailsStats = monthNum.toString(); // Actualiza la variable de estado para detalles
                                if (domCache.detailsMonthDropdownOptions) {
                                    domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                        a.classList.toggle('active', a.dataset.month === monthNum.toString());
                                    });
                                }
                                // Mostrar los gráficos individuales con el nuevo período y el empleado que ya estaba seleccionado
                                showIndividualEmployeeCharts(employeeData, monthNum.toString());
                            }
                        }
                        // --- FIN: NUEVA LÓGICA PARA SINCRONIZAR ESTADÍSTICAS ---
                    }
                });
                domCache.monthTabsContainer.appendChild(button);
            });

            highlightActiveMonthTab(); // Asegúrate de que esta función se llame para resaltar la pestaña correcta
        }



        function highlightActiveMonthTab() {
            domCache.monthTabsContainer.querySelectorAll('.month-tab').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.month) === currentSelectedMonth);
            });
        }

        function populateEmployeeSelects(selectElement) {
            selectElement.innerHTML = '';
            const placeholder = createElement('option', { textContent: 'Selecciona empleado', attributes: { value: "" } });
            selectElement.appendChild(placeholder);
            selectElement.value = "";

            employeeNamesOrdered.forEach(name => {
                selectElement.appendChild(createElement('option', { textContent: name, attributes: { value: name } }));
            });
        }

        function getDaysInMonth(month, year) {
            return new Date(year, month, 0).getDate();
        }
        function getWeekDayInitial(year, month, day) {
            return SHORT_WEEK_DAY_NAMES[new Date(year, month - 1, day).getDay()];
        }

		function applyShiftCellStyles(cell, shiftValue) {
		const allColorKeys = [...SHIFT_TYPES, 'empty', ...Object.keys(currentShiftColors)];
			allColorKeys.forEach(stKey => {
				if (DEFAULT_SHIFT_COLORS[stKey]?.bg) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].bg);
				if (DEFAULT_SHIFT_COLORS[stKey]?.text) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].text);
				if (currentShiftColors[stKey]?.bg) cell.classList.remove(currentShiftColors[stKey].bg);
				if (currentShiftColors[stKey]?.text) cell.classList.remove(currentShiftColors[stKey].text);
				cell.classList.remove('font-bold');
			});

			const colorConfToApply = SHIFT_TYPES.includes(shiftValue) ? currentShiftColors[shiftValue] : currentShiftColors.empty;
			if (colorConfToApply?.bg) cell.classList.add(colorConfToApply.bg);
			if (colorConfToApply?.text) cell.classList.add(colorConfToApply.text);

			if (shiftValue && shiftValue.trim() !== "") {
				cell.classList.add('font-bold');
			} else {
				cell.classList.remove('font-bold');
			}
		}


        function handleTableDblClick(event) {
            const target = event.target;
            const employeeNameDisplay = target.closest('.employee-name-display');
            const shiftCell = target.closest('td.shift-cell');

            if (employeeNameDisplay && !target.closest('.delete-employee-icon')) {
                const td = employeeNameDisplay.closest('.employee-name-cell');
                const currentName = employeeNameDisplay.textContent;
                const input = createElement('input', {
                    attributes: { type: 'text', value: currentName },
                    className: 'w-full p-1 border border-indigo-300 rounded text-sm'
                });
                td.innerHTML = ''; td.appendChild(input); input.focus(); input.select();

                const saveName = () => {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        if (newName.includes(',')) {
                            showToast('El nombre del empleado no puede contener comas (,).', 'error');
                            td.innerHTML = '';
                            const originalNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                            const deleteIcon = createDeleteEmployeeIcon(currentName);
                            td.appendChild(originalNameSpan);
                            td.appendChild(deleteIcon);
                            input.focus();
                            return;
                        }
                        if (employeeNamesOrdered.includes(newName)) {
                            showToast(`El nombre "${newName}" ya existe.`, 'error');
                            td.innerHTML = '';
                            const originalNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                            const deleteIcon = createDeleteEmployeeIcon(currentName);
                            td.appendChild(originalNameSpan);
                            td.appendChild(deleteIcon);
                            return;
                        }
                        updateEmployeeName(currentName, newName);
                    } else {
                        td.innerHTML = '';
                        const nameSpanToRestore = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIconToRestore = createDeleteEmployeeIcon(currentName);
                        td.appendChild(nameSpanToRestore);
                        td.appendChild(deleteIconToRestore);
                    }
                };
                input.addEventListener('blur', saveName);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        td.innerHTML = '';
                        const newNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIcon = createDeleteEmployeeIcon(currentName);
                        td.appendChild(newNameSpan); td.appendChild(deleteIcon);
                    }
                });
            } else if (shiftCell) {
                const cellInfo = getCellInfoFromElement(shiftCell);
                if (!cellInfo) return;
                const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";

                if (SHIFT_TYPES.includes(currentValue)) {
                    return;
                }

                cellsBeingEditedViaEventModal = [{
                    tdElement: shiftCell,
                    employee: cellInfo.employee,
                    month: cellInfo.month,
                    day: cellInfo.day,
                    originalValue: currentValue
                }];
                isSingleCellEditViaModal = true;
                const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
                showCustomEventModal(modalTitle, currentValue);
                clearSelection(false);
            }
        }

		function updateEmployeeName(oldName, newName) {
			saveStateForUndo(`Nombre de empleado: "${oldName}" -> "${newName}".`); 

			const index = employeeNamesOrdered.indexOf(oldName);
			if (index > -1) employeeNamesOrdered[index] = newName;

			if (scheduleData[oldName]) {
				scheduleData[newName] = scheduleData[oldName];
				delete scheduleData[oldName];
			}
			handleViewChange();
			initializeAndRenderNewStatistics();   // <--- AÑADIDO
			showToast(`Nombre de empleado actualizado a "${newName}".`, 'success');
		}


        function createDeleteEmployeeIcon(employeeName) {
            const deleteIcon = createElement('i', {
                className: 'fas fa-trash-alt delete-employee-icon text-red-400 hover:text-red-600',
                title: `Eliminar a ${employeeName}`
            });
            deleteIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                promptDeleteEmployee(employeeName);
            });
            return deleteIcon;
        }

        function buildScheduleTableHeader(viewType, month, year) {
            const headerRow = createElement('tr');
            headerRow.appendChild(createElement('th', {
                textContent: 'Empleado',
                className: 'py-3 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sticky-col-header'
            }));

            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(month, year);
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    headerRow.appendChild(createElement('th', {
                        className: 'py-3 px-2 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider',
                        innerHTML: `<span class="day-header-date">${day}</span><span class="day-header-weekday">${getWeekDayInitial(year, month, day)}</span>`
                    }));
                }
            } else if (viewType === 'annual') {
                for (let m = 1; m <= 12; m++) {
                    const daysInThisMonth = getDaysInMonth(m, year);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        headerRow.appendChild(createElement('th', {
                            className: 'py-3 px-1.5 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider min-w-[50px]',
                            innerHTML: `<span class="day-header-date">${day}</span><span class="day-header-weekday">${SHORT_MONTH_NAMES[m-1]}</span>`
                        }));
                    }
                }
            }
            return headerRow;
        }

        function buildEmployeeRow(employeeName, rowIndex, viewType, currentDisplayMonth, yearToDisplay) {
            const employeeRow = createElement('tr', {
                className: `draggable-row ${rowIndex % 2 === 0 ? 'bg-white' : 'bg-gray-50 hover:bg-gray-100'}`,
                dataset: { rowIndex: rowIndex.toString() }
            });

            const nameCell = createElement('td', {
                className: 'py-2 px-4 whitespace-nowrap text-sm font-medium text-gray-800 sticky-col employee-name-cell',
                title: 'Doble clic para editar. Arrastra para reordenar.'
            });
            nameCell.style.backgroundColor = (rowIndex % 2 === 0) ? '#ffffff' : '#f9fafb';

            const nameSpan = createElement('span', {
                className: 'employee-name-display flex-grow', textContent: employeeName, attributes: { draggable: "true" }
            });
            const deleteIcon = createDeleteEmployeeIcon(employeeName);
            nameCell.appendChild(nameSpan);
            nameCell.appendChild(deleteIcon);
            employeeRow.appendChild(nameCell);

            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(currentDisplayMonth, yearToDisplay);
                const employeeMonthData = scheduleData[employeeName]?.[currentDisplayMonth] || {};
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    const shift = employeeMonthData[day] || "";
                    const tdShift = createElement('td', {
                        textContent: shift, className: 'shift-cell',
                        dataset: { employee: employeeName, month: currentDisplayMonth.toString(), day: day.toString(), colIndex: (day - 1).toString() }
                    });
                    applyShiftCellStyles(tdShift, shift);
                    if (selectedCells.some(sc => sc.employee === employeeName && sc.month === currentDisplayMonth && sc.day === day)) {
                        tdShift.classList.add('cell-selected');
                    }
                    employeeRow.appendChild(tdShift);
                }
            } else if (viewType === 'annual') {
                let currentAnnualColIndex = 0;
                for (let m = 1; m <= 12; m++) {
                    const employeeMonthData = scheduleData[employeeName]?.[m] || {};
                    const daysInThisMonth = getDaysInMonth(m, yearToDisplay);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = employeeMonthData[day] || "";
                        const tdShift = createElement('td', {
                            textContent: shift, className: 'shift-cell',
                            dataset: { employee: employeeName, month: m.toString(), day: day.toString(), colIndex: currentAnnualColIndex.toString() }
                        });
                        applyShiftCellStyles(tdShift, shift);
                         if (selectedCells.some(sc => sc.employee === employeeName && sc.month === m && sc.day === day)) {
                            tdShift.classList.add('cell-selected');
                        }
                        employeeRow.appendChild(tdShift);
                        currentAnnualColIndex++;
                    }
                }
            }
            return employeeRow;
        }

        function renderMonthlyScheduleTable(month, year) {
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            const headerRow = buildScheduleTableHeader('monthly', month, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) {
                renderAddEmployeeButtonInTable();
                enableControls(false);
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;
                domCache.noDataMessage.classList.remove('hidden-by-default');
                return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'monthly', month, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable();
            highlightActiveMonthTab();
            enableControls(true);
        }

        function renderAnnualScheduleTable(year) {
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            const headerRow = buildScheduleTableHeader('annual', null, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) {
                 renderAddEmployeeButtonInTable();
                 enableControls(false);
                 if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;
                 domCache.noDataMessage.classList.remove('hidden-by-default');
                 return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'annual', null, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable();
            enableControls(true);
        }

        function renderAddEmployeeButtonInTable() {
            const existingAddRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
            if (existingAddRow) existingAddRow.remove();

            const addEmployeeRow = createElement('tr', { className: 'add-employee-row-reformed' });
            const buttonCell = createElement('td', { className: 'sticky-col add-employee-cell-reformed' });
            const buttonVisual = createElement('button', {
                className: 'add-employee-button-visual', title: 'Añadir nuevo empleado'
            });
            const addIcon = createElement('i', { className: 'fas fa-user-plus' });
            const buttonText = createElement('span', { textContent: 'Añadir Empleado' });

            buttonVisual.appendChild(addIcon); buttonVisual.appendChild(buttonText);
            buttonVisual.addEventListener('click', showAddEmployeeModal);
            buttonCell.appendChild(buttonVisual);
            addEmployeeRow.appendChild(buttonCell);

            let numberOfDayCells = 0;
            const headerRow = domCache.scheduleTableHead.querySelector('tr');
            if (headerRow && headerRow.cells.length > 1) {
                numberOfDayCells = headerRow.cells.length - 1;
            }
            for (let i = 0; i < numberOfDayCells; i++) {
                addEmployeeRow.appendChild(createElement('td', { className: 'add-employee-empty-cell-reformed' }));
            }
            domCache.scheduleTableBody.appendChild(addEmployeeRow);
        }

        // --- DRAG & DROP DE EMPLEADOS ---
        function handleDragStart(event) {
            if (event.target.classList.contains('employee-name-display')) {
                const targetRow = event.target.closest('.draggable-row');
                if (targetRow && targetRow.dataset.rowIndex) {
                    draggedRow = targetRow;
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => draggedRow.classList.add('dragging'), 0);
                }
            } else {
                event.preventDefault();
            }
        }
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable-row:not(.dragging):not(.add-employee-row-reformed)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        function handleDragOver(event) {
            event.preventDefault();
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
            removeDragOverIndicator();
            dragOverIndicator = createElement('tr', {className: 'drag-over-indicator-row'}, [
                createElement('td', {attributes: {colspan: "100%"}}, [
                     createElement('div', {className: 'drag-over-indicator'})
                ])
            ]);
            const addRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
            if (afterElement == null) {
                if (addRow) domCache.scheduleTableBody.insertBefore(dragOverIndicator, addRow);
                else domCache.scheduleTableBody.appendChild(dragOverIndicator);
            } else {
                domCache.scheduleTableBody.insertBefore(dragOverIndicator, afterElement);
            }
        }
        function handleDragLeave(event) {
            if (!domCache.scheduleTableBody.contains(event.relatedTarget)) {
                removeDragOverIndicator();
            }
        }
        function removeDragOverIndicator() {
            if (dragOverIndicator && dragOverIndicator.parentElement) {
                dragOverIndicator.parentElement.removeChild(dragOverIndicator);
            }
            dragOverIndicator = null;
        }
        function handleDrop(event) {
            event.preventDefault();
            removeDragOverIndicator();
            if (!draggedRow) return;

            saveStateForUndo("Empleados reordenados.");

            const originalIndex = parseInt(draggedRow.dataset.rowIndex);
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
            let newIndex;
            if (afterElement) {
                newIndex = parseInt(afterElement.dataset.rowIndex);
            } else {
                newIndex = employeeNamesOrdered.length;
            }

            if (originalIndex === newIndex || (originalIndex < newIndex && originalIndex === newIndex -1) || (originalIndex > newIndex && originalIndex === newIndex) ) {
                 if(draggedRow) draggedRow.classList.remove('dragging');
                 draggedRow = null;
                 return;
            }

            const [draggedEmployeeName] = employeeNamesOrdered.splice(originalIndex, 1);

            if (originalIndex < newIndex) {
                employeeNamesOrdered.splice(newIndex - 1, 0, draggedEmployeeName);
            } else {
                employeeNamesOrdered.splice(newIndex, 0, draggedEmployeeName);
            }

            handleViewChange();
            if(draggedRow) draggedRow.classList.remove('dragging');
            draggedRow = null;
        }

        function handleDragEnd(event) {
            if(draggedRow) draggedRow.classList.remove('dragging');
            removeDragOverIndicator();
            draggedRow = null;
        }

        // --- EDICIÓN DE CELDAS Y SELECCIÓN MÚLTIPLE ---
        function editCellOnLongPress(cellInfo) {
            const shiftCell = cellInfo.tdElement;
            const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";

            if (SHIFT_TYPES.includes(currentValue)) {
                 return;
            }

            cellsBeingEditedViaEventModal = [{
                tdElement: shiftCell,
                employee: cellInfo.employee,
                month: cellInfo.month,
                day: cellInfo.day,
                originalValue: currentValue
            }];
            isSingleCellEditViaModal = true;
            const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
            showCustomEventModal(modalTitle, currentValue);
            clearSelection(false);
        }

        function getCellInfoFromElement(tdElement) {
            if (!tdElement || !tdElement.dataset.employee) return null;
            return {
                employee: tdElement.dataset.employee,
                month: parseInt(tdElement.dataset.month),
                day: parseInt(tdElement.dataset.day),
                tdElement: tdElement,
                rowIndex: parseInt(tdElement.parentElement.dataset.rowIndex),
                colIndex: parseInt(tdElement.dataset.colIndex)
            };
        }
        function processCellClick(cellInfo, isShiftKey, isCtrlOrMetaKey, isTap = false) {
            if (isShiftKey && lastSelectedCellInfo) {
                clearSelection(false);
                const minRow = Math.min(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const maxRow = Math.max(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const minCol = Math.min(lastSelectedCellInfo.colIndex, cellInfo.colIndex);
                const maxCol = Math.max(lastSelectedCellInfo.colIndex, cellInfo.colIndex);

                const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
                allCellsInTable.forEach(cellElement => {
                    const cellIterInfo = getCellInfoFromElement(cellElement);
                    if (cellIterInfo &&
                        cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol) {
                        if (!selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement)) {
                            selectedCells.push(cellIterInfo);
                            cellIterInfo.tdElement.classList.add('cell-selected');
                        }
                    }
                });
            } else if (isCtrlOrMetaKey || isTap) {
                toggleCellSelection(cellInfo);
                lastSelectedCellInfo = cellInfo;
            } else {
                if (!selectedCells.some(sc => sc.tdElement === cellInfo.tdElement)) {
                    clearSelection(false);
                    toggleCellSelection(cellInfo);
                } else if (selectedCells.length > 1) {
                    clearSelection(false);
                    toggleCellSelection(cellInfo);
                }
                lastSelectedCellInfo = cellInfo;
            }
            updateMultiselectToolbar();
        }

        function toggleCellSelection(cellInfo) {
            const existingIndex = selectedCells.findIndex(sc => sc.tdElement === cellInfo.tdElement);
            if (existingIndex > -1) {
                selectedCells.splice(existingIndex, 1);
                cellInfo.tdElement.classList.remove('cell-selected');
            } else {
                selectedCells.push(cellInfo);
                cellInfo.tdElement.classList.add('cell-selected');
            }
        }
        function clearSelection(hideToolbar = true) {
            selectedCells.forEach(cell => cell.tdElement.classList.remove('cell-selected'));
            selectedCells = [];
            lastSelectedCellInfo = null;
            if (hideToolbar) updateMultiselectToolbar();
        }
        function setupMultiselectToolbar() {
            domCache.multiselectToolbar.innerHTML = '';
            SHIFT_TYPES.forEach(shift => {
                const button = createElement('button', {
                    textContent: shift, title: `Asignar ${SHIFT_TYPE_FULL_NAMES[shift]} (${shift}) a selección`
                });
                button.addEventListener('click', () => { applyShiftToSelection(shift); });
                domCache.multiselectToolbar.appendChild(button);
            });
            const otherButton = createElement('button', {
                textContent: 'Otro', title: 'Asignar "Otro" (vacío) a selección', className: 'other-selection'
            });
            otherButton.addEventListener('click', () => { applyShiftToSelection(''); });
            domCache.multiselectToolbar.appendChild(otherButton);
        }
        function updateMultiselectToolbar() {
            domCache.multiselectToolbar.classList.toggle('hidden-by-default', selectedCells.length === 0);
        }
        function applyShiftToSelection(newShift) {
            if (selectedCells.length === 0) return;

            if (newShift === '') {
                cellsBeingEditedViaEventModal = selectedCells.map(sc => ({
                    tdElement: sc.tdElement,
                    employee: sc.employee,
                    month: sc.month,
                    day: sc.day,
                    originalValue: scheduleData[sc.employee]?.[sc.month]?.[sc.day] || ""
                }));
                isSingleCellEditViaModal = false;
                let modalTitle;
                if (selectedCells.length === 1) {
                    const sc = selectedCells[0];
                    modalTitle = `Establecer Evento: ${sc.employee} - ${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}`;
                } else {
                    modalTitle = `Establecer Evento para ${selectedCells.length} Celdas`;
                }
                showCustomEventModal(modalTitle, "");
                return;
            }

            let changesMadeCount = 0;
            let undoDescription = `Turno de ${selectedCells.length} celda(s) cambiado a '${newShift || "Vacío"}'.`;
            if (selectedCells.length === 1) {
                 const sc = selectedCells[0];
                 const originalShift = scheduleData[sc.employee]?.[sc.month]?.[sc.day] || "";
                 undoDescription = `Turno de ${sc.employee} (${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}) cambiado de '${originalShift || "Vacío"}' a '${newShift || "Vacío"}'.`;
            }

            let needsStateSave = selectedCells.some(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                return originalShift !== newShift;
            });

            if (needsStateSave) {
                saveStateForUndo(undoDescription);
            }

            selectedCells.forEach(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                if (originalShift !== newShift) {
                    updateShift(cellInfo.tdElement, cellInfo.employee, cellInfo.month, cellInfo.day, newShift, originalShift, false);
                    changesMadeCount++;
                }
            });

            if (changesMadeCount > 0) {
            }
			initializeAndRenderNewStatistics();
        }

        function updateShift(td, employee, month, day, newShift, originalShift, logIndividualChange = true) {
            if (originalShift !== newShift && logIndividualChange) {
                 const originalShiftDisplay = SHIFT_TYPE_FULL_NAMES[originalShift] || (originalShift === "" ? "Vacío" : (originalShift || "Vacío"));
                 const newShiftDisplay = SHIFT_TYPE_FULL_NAMES[newShift] || (newShift === "" ? "Vacío" : (newShift || "Vacío"));
                 saveStateForUndo(`Turno de ${employee} (${day}/${SHORT_MONTH_NAMES[month-1]}) cambiado de '${originalShiftDisplay}' a '${newShiftDisplay}'.`);
            }

            if (!scheduleData[employee]) scheduleData[employee] = {};
            if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
            scheduleData[employee][month][day] = newShift;
            td.textContent = newShift;
            applyShiftCellStyles(td, newShift);
			initializeAndRenderNewStatistics();
        }

		function getSvgString(type) {
				const yearToRender = yearOfSchedule;
				let svgElements = [];
				let svgWidth = 0, svgHeight = 0;

				const padding = 20, logoRenderWidth = 200, logoRenderHeight = 75, logoBottomMargin = 20;
				const employeeColWidth = 120, cellHeight = 30, headerHeight = 45;
				const cellFontSize = 10, headerFontSize = 9, weekdayFontSize = 8, titleFontSize = 16;
				const monthTitleSpacing = 30, tableSpacing = 25, textYAdjust = cellFontSize * 0.35;

				let currentY = padding;
				currentY += logoRenderHeight + logoBottomMargin;

				if (type === 'monthlyAnnual') {
						if (currentViewMode === 'monthly') {
								const monthToRender = currentSelectedMonth;
								const titleText = `Horario para ${MONTH_NAMES[monthToRender - 1]} ${yearToRender}`;
								const svgCellWidthMonthly = 45;
								const daysInSelectedMonth = getDaysInMonth(monthToRender, yearToRender);

								svgWidth = padding * 2 + employeeColWidth + (daysInSelectedMonth * svgCellWidthMonthly);
								const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
								svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

								const titleY = currentY + titleFontSize / 2 + 5;
								svgElements.push(`<text x="${svgWidth / 2}" y="${titleY}" font-family="Inter, sans-serif" font-size="${titleFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${titleText}</text>`);
								currentY = titleY + titleFontSize / 2 + monthTitleSpacing - titleFontSize / 2 ;

								let tableHeaderX = padding;
								svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${employeeColWidth}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
								svgElements.push(`<text x="${tableHeaderX + employeeColWidth / 2}" y="${currentY + headerHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">Empleado</text>`);
								tableHeaderX += employeeColWidth;

								for (let day = 1; day <= daysInSelectedMonth; day++) {
										svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthMonthly}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
										const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
										const dayNumberY = currentY + headerHeight * 0.38 + textYAdjust * 0.5;
										const weekDayY = currentY + headerHeight * 0.72 + textYAdjust * 0.5;
										svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly / 2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${day}</text>`);
										svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly / 2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${weekdayFontSize}px" font-weight="bold" text-anchor="middle" fill="#6b7280" dominant-baseline="middle">${weekDayInitial}</text>`);
										tableHeaderX += svgCellWidthMonthly;
								}
								currentY += headerHeight;

								employeeNamesOrdered.forEach((empName, rowIndex) => {
										const rowY = currentY + rowIndex * cellHeight;
										let currentCellX = padding;
										svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`);
										svgElements.push(`<text x="${currentCellX + employeeColWidth / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
										currentCellX += employeeColWidth;

										const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
										for (let day = 1; day <= daysInSelectedMonth; day++) {
												const shift = employeeMonthData[day] || "";
												let displayShiftInPdfCell = shift;

												if (type === 'monthlyAnnual') {
														if (shift === 'M2') displayShiftInPdfCell = 'M';
														else if (shift === 'T2') displayShiftInPdfCell = 'T';
														else if (shift === 'N2') displayShiftInPdfCell = 'N';
												}

												const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
												svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthMonthly}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#e0e0e0" />`);

												let fontWeightForSvgMonthly = "normal";
												if (shift && shift.trim() !== "") {
														fontWeightForSvgMonthly = "bold";
												}

												if (displayShiftInPdfCell) {
														svgElements.push(`<text x="${currentCellX + svgCellWidthMonthly / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="${fontWeightForSvgMonthly}" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${displayShiftInPdfCell}</text>`);
												}
												currentCellX += svgCellWidthMonthly;
										}
								});
								svgHeight = currentY + (employeeNamesOrdered.length * cellHeight) + padding;
								svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);

						} else { // Annual view
								const svgCellWidthAnnual = 35;
								let maxDaysInMonth = 0;
								for (let m = 1; m <= 12; m++) maxDaysInMonth = Math.max(maxDaysInMonth, getDaysInMonth(m, yearToRender));

								svgWidth = padding * 2 + employeeColWidth + (maxDaysInMonth * svgCellWidthAnnual);
								const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
								svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

								let currentGlobalY = currentY;
								for (let monthToRender = 1; monthToRender <= 12; monthToRender++) {
										const monthTitleText = `${MONTH_NAMES[monthToRender - 1]} ${yearToRender}`;
										const titleY = currentGlobalY + titleFontSize / 2 + 5;
										svgElements.push(`<text x="${padding + employeeColWidth + (maxDaysInMonth * svgCellWidthAnnual) / 2}" y="${titleY}" font-family="Inter, sans-serif" font-size="${titleFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${monthTitleText}</text>`);
										currentGlobalY = titleY + titleFontSize / 2 + (monthTitleSpacing - titleFontSize / 2);

										let tableHeaderX = padding;
										svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${employeeColWidth}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
										svgElements.push(`<text x="${tableHeaderX + employeeColWidth / 2}" y="${currentGlobalY + headerHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">Empleado</text>`);
										tableHeaderX += employeeColWidth;

										const daysInCurrentMonth = getDaysInMonth(monthToRender, yearToRender);
										for (let day = 1; day <= daysInCurrentMonth; day++) {
												svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0" />`);
												const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
												const dayNumberY = currentGlobalY + headerHeight * 0.38 + textYAdjust * 0.7;
												const weekDayY = currentGlobalY + headerHeight * 0.72 + textYAdjust * 0.7;
												svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual / 2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${headerFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${day}</text>`);
												svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual / 2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${weekdayFontSize}px" font-weight="bold" text-anchor="middle" fill="#6b7280" dominant-baseline="middle">${weekDayInitial}</text>`);
												tableHeaderX += svgCellWidthAnnual;
										}
										for (let day = daysInCurrentMonth + 1; day <= maxDaysInMonth; day++) {
												svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#fdfdff" stroke="#e0e0e0" />`);
												tableHeaderX += svgCellWidthAnnual;
										}
										currentGlobalY += headerHeight;

										employeeNamesOrdered.forEach((empName, rowIndex) => {
												const rowY = currentGlobalY + rowIndex * cellHeight;
												let currentCellX = padding;
												svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`);
												svgElements.push(`<text x="${currentCellX + employeeColWidth / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
												currentCellX += employeeColWidth;

												const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
												for (let day = 1; day <= daysInCurrentMonth; day++) {
														const shift = employeeMonthData[day] || "";
														let displayShiftInPdfCell = shift;

														if (type === 'monthlyAnnual') {
															 if (shift === 'M2') displayShiftInPdfCell = 'M';
															 else if (shift === 'T2') displayShiftInPdfCell = 'T';
															 else if (shift === 'N2') displayShiftInPdfCell = 'N';
														}

														const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
														svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#e0e0e0" />`);
														
														let fontWeightForSvgAnnual = "normal";
														if (shift && shift.trim() !== "") {
																fontWeightForSvgAnnual = "bold";
														}

														if (displayShiftInPdfCell) {
																svgElements.push(`<text x="${currentCellX + svgCellWidthAnnual / 2}" y="${rowY + cellHeight / 2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="${fontWeightForSvgAnnual}" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${displayShiftInPdfCell}</text>`);
														}
														currentCellX += svgCellWidthAnnual;
												}
												for (let day = daysInCurrentMonth + 1; day <= maxDaysInMonth; day++) {
														svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#e0e0e0" />`);
														currentCellX += svgCellWidthAnnual;
												}
										});
										currentGlobalY += (employeeNamesOrdered.length * cellHeight) + tableSpacing;
								}
								svgHeight = currentGlobalY - tableSpacing + padding / 2;
								svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);
						}
				} else if (type === 'weekly') {
						const monthToRender = currentSelectedMonth;
						const weeks = getWeeksForMonth(yearToRender, monthToRender);
						if (weeks.length === 0) return '';

						const dayHeaderHeightWeekly = 40, cellWidthWeekly = 90;
						const titleHeightWeekly = 30, weekTitleHeight = 25;
						const dateFontSizeWeekly = 10, dayNameFontSizeWeekly = 8;
						const titleFontSizeWeekly = 16, weekTitleFontSizeWeekly = 12;

						svgWidth = padding * 2 + employeeColWidth + (7 * cellWidthWeekly);
						const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
						svgElements.push(`<g transform="translate(${logoGroupX}, ${padding})">${SVG_FINAL_LOGO_MARKUP}</g>`);

						let currentGlobalY = currentY;
						const mainTitleY = currentGlobalY + titleFontSizeWeekly / 2 + 5;
						svgElements.push(`<text x="${svgWidth / 2}" y="${mainTitleY}" font-family="Inter, sans-serif" font-size="${titleFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">Horario Semanal - ${MONTH_NAMES[monthToRender - 1]} ${yearToRender}</text>`);
						currentGlobalY = mainTitleY + titleFontSizeWeekly / 2 + tableSpacing / 2;

						weeks.forEach((week, weekIndex) => {
								const firstDayOfWeek = week[0], lastDayOfWeek = week[week.length-1];
								const weekTitle = `Semana ${weekIndex + 1}: ${firstDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short'})} - ${lastDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short', year:'numeric'})}`;
								const weekTitleYPos = currentGlobalY + weekTitleHeight / 2;
								svgElements.push(`<text x="${svgWidth / 2}" y="${weekTitleYPos}" font-family="Inter, sans-serif" font-size="${weekTitleFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#374151" dominant-baseline="middle">${weekTitle}</text>`);
								currentGlobalY = weekTitleYPos + weekTitleHeight / 2;

								let tableHeaderX = padding;
								svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${employeeColWidth}" height="${dayHeaderHeightWeekly}" fill="#f3f4f6" stroke="#d1d5db"/>`);
								svgElements.push(`<text x="${tableHeaderX + employeeColWidth/2}" y="${currentGlobalY + dayHeaderHeightWeekly/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${dateFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">Empleado</text>`);
								tableHeaderX += employeeColWidth;

								week.forEach(dateObj => {
										svgElements.push(`<rect x="${tableHeaderX}" y="${currentGlobalY}" width="${cellWidthWeekly}" height="${dayHeaderHeightWeekly}" fill="#f3f4f6" stroke="#d1d5db"/>`);
										const dayStr = dateObj.toLocaleDateString('es-ES', { day: '2-digit' });
										const monthStr = SHORT_MONTH_NAMES[dateObj.getMonth()];
										const dayNameStr = WEEK_DAY_NAMES[dateObj.getDay()].substring(0,3);
										const dayNumberY = currentGlobalY + dayHeaderHeightWeekly * 0.38 + textYAdjust * 0.7;
										const weekDayY = currentGlobalY + dayHeaderHeightWeekly * 0.72 + textYAdjust * 0.7;
										svgElements.push(`<text x="${tableHeaderX + cellWidthWeekly/2}" y="${dayNumberY}" font-family="Inter, sans-serif" font-size="${dateFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${dayStr} ${monthStr}</text>`);
										svgElements.push(`<text x="${tableHeaderX + cellWidthWeekly/2}" y="${weekDayY}" font-family="Inter, sans-serif" font-size="${dayNameFontSizeWeekly}px" font-weight="bold" text-anchor="middle" fill="#4b5563" dominant-baseline="middle">${dayNameStr}</text>`);
										tableHeaderX += cellWidthWeekly;
								});
								currentGlobalY += dayHeaderHeightWeekly;

								employeeNamesOrdered.forEach((empName, rowIndex) => {
										const rowY = currentGlobalY + rowIndex * cellHeight;
										let currentCellX = padding;
										svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#d1d5db"/>`);
										svgElements.push(`<text x="${currentCellX + employeeColWidth/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
										currentCellX += employeeColWidth;

										week.forEach(dateObj => {
												const day = dateObj.getDate(); const month = dateObj.getMonth() + 1;
												let shift = scheduleData[empName]?.[month]?.[day] || "";
												const shiftTimeConfig = currentUserShiftTimes[shift];
												let displayShift = shift;

												if (shiftTimeConfig && (shift === 'M' || shift === 'T' || shift === 'N' || shift === 'M2' || shift === 'T2' || shift === 'N2')) {
														displayShift = `${formatTimeForInput(shiftTimeConfig.start[0], shiftTimeConfig.start[1])}-${formatTimeForInput(shiftTimeConfig.end[0], shiftTimeConfig.end[1])}`;
												} else if (shift === 'B') {
														displayShift = SHIFT_TYPE_FULL_NAMES['B'];
												}

												const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
												svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${cellWidthWeekly}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#d1d5db"/>`);
												
												let fontWeightForSvgWeekly = "normal";
												if (shift && shift.trim() !== "") {
														fontWeightForSvgWeekly = "bold";
												}

												if (displayShift) {
														svgElements.push(`<text x="${currentCellX + cellWidthWeekly/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize}px" font-weight="${fontWeightForSvgWeekly}" text-anchor="middle" fill="${colorConf.hexText || '#000000'}" dominant-baseline="middle">${displayShift}</text>`);
												}
												currentCellX += cellWidthWeekly;
										});
								});
								currentGlobalY += (employeeNamesOrdered.length * cellHeight) + tableSpacing;
						});
						 svgHeight = currentGlobalY - tableSpacing + padding / 2;
						 svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);
				}
				return `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="font-family: 'Inter', sans-serif;">${svgElements.join('')}</svg>`;
		}

        function getWeeksForMonth(year, month) {
            const weeks = [];
            const firstDateOfMonth = new Date(year, month - 1, 1);
            const lastDateOfMonth = new Date(year, month, 0);

            let currentDate = new Date(firstDateOfMonth);
            let dayOfWeek = currentDate.getDay(); 
            let diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; 
            currentDate.setDate(firstDateOfMonth.getDate() + diffToMonday);

            while (currentDate <= lastDateOfMonth || (weeks.length > 0 && weeks[weeks.length-1][6] >= firstDateOfMonth && weeks[weeks.length-1][0] <= lastDateOfMonth) ) {
                const week = [];
                for (let i = 0; i < 7; i++) {
                    week.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                if (week.some(d => d.getFullYear() === year && d.getMonth() === month - 1) ||
                   (weeks.length === 0 && week.some(d => d.getTime() === firstDateOfMonth.getTime())) ) {
                     weeks.push(week);
                 } else if (weeks.length > 0 && week[0] > lastDateOfMonth) { 
                     break;
                 }

                if (weeks.length > 6 && currentDate > lastDateOfMonth) break; 
            }
            return weeks;
        }


        // --- EXPORTACIÓN A CALENDAR (.ics) ---
        // REEMPLAZA TU FUNCIÓN exportToCalendar EXISTENTE CON ESTA VERSIÓN ACTUALIZADA:
        function exportToCalendar(selectedEmployeeForCalendar) {
            let icalFilenameBase = generateDefaultFilename('calendar', selectedEmployeeForCalendar);
            const firstDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth - 1, 1);
            const lastDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth, 0);
            let icalContent = [
                'BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//NefiBadillo//GestorHorariosLaborales//ES',
                `X-WR-CALNAME:Horario ${selectedEmployeeForCalendar} - ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`
            ];
            const empName = selectedEmployeeForCalendar;
            if (!scheduleData[empName]) { showToast(`No hay datos para ${empName}.`, 'error'); return; }
            let currentDateIter = new Date(firstDayOfMonth);
            while(currentDateIter <= lastDayOfMonth) {
                const day = currentDateIter.getDate(), currentIterMonth = currentDateIter.getMonth() + 1, currentIterYear = currentDateIter.getFullYear();
                let shiftType = scheduleData[empName]?.[currentIterMonth]?.[day];
                if (shiftType === undefined || shiftType === null) shiftType = ""; 
                if (shiftType !== undefined) { 
                    const shiftTimeConfig = currentUserShiftTimes[shiftType];
                    const isKnownShift = SHIFT_TYPE_FULL_NAMES[shiftType]; // Esto funcionará para "B"
                    if (isKnownShift || (shiftType && !isKnownShift) || shiftType === "") { 
                        const dtStamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15) + 'Z';
                        const uidSuffix = shiftType || 'otro'; 
                        const uid = `${formatDateForICalAllDay(currentDateIter)}-${empName.replace(/\s+/g, '')}-${uidSuffix}@gestorhorarios.com`;
                        icalContent.push('BEGIN:VEVENT', `UID:${uid}`, `DTSTAMP:${dtStamp}`);
                        let summaryText = shiftType === "" ? `Otro - ${empName}` : (isKnownShift ? `Turno ${SHIFT_TYPE_FULL_NAMES[shiftType]} (${shiftType}) - ${empName}` : `${shiftType} - ${empName}`);
                        icalContent.push(`SUMMARY:${summaryText}`, `DESCRIPTION:Horario laboral: ${summaryText}.`, `LOCATION:Gran Hotel Miramar`, `STATUS:CONFIRMED`);
                        
                        // MODIFICACIÓN AQUÍ: Tratar "B" como evento de día completo
                        if (!shiftTimeConfig || shiftType === 'L' || shiftType === 'V' || shiftType === 'B' || shiftType === "") { 
                            const eventDate = new Date(currentIterYear, currentIterMonth - 1, day);
                            const startDateAllDay = formatDateForICalAllDay(eventDate);
                            eventDate.setDate(eventDate.getDate() + 1); 
                            const endDateAllDay = formatDateForICalAllDay(eventDate);
                            icalContent.push(`DTSTART;VALUE=DATE:${startDateAllDay}`, `DTEND;VALUE=DATE:${endDateAllDay}`, `TRANSP:OPAQUE`);
                        } else { 
                            let startDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.start[0], shiftTimeConfig.start[1]);
                            let endDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.end[0], shiftTimeConfig.end[1]);
                            if (shiftTimeConfig.nextDayEnd) endDateEvent.setDate(endDateEvent.getDate() + 1);
                            icalContent.push(`DTSTART;TZID=Europe/Madrid:${formatForICalTimezone(startDateEvent)}`, `DTEND;TZID=Europe/Madrid:${formatForICalTimezone(endDateEvent)}`, `TRANSP:OPAQUE`);
                        }
                        icalContent.push('END:VEVENT');
                    }
                }
                currentDateIter.setDate(currentDateIter.getDate() + 1);
            }
            icalContent.push('END:VCALENDAR');
            if (icalContent.length <= 4) { 
                 showToast(`No hay eventos programados para ${selectedEmployeeForCalendar} en ${MONTH_NAMES[currentSelectedMonth - 1]}.`, 'info'); return;
            }
            const blob = new Blob([icalContent.join('\r\n')], { type: 'text/calendar;charset=utf-8;' });
            const link = createElement("a", { attributes: { href: URL.createObjectURL(blob), download: `${icalFilenameBase}.ics` }, style: { visibility: 'hidden' } });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Archivo Calendar (.ics) generado para ${selectedEmployeeForCalendar}.`, 'success');
        }


        function showExportToCalendarModal() {
            if (currentViewMode !== 'monthly' || !isDataLoadedForStats()) {
                showToast('Exportación a Calendar: vista mensual y datos cargados requeridos.', 'warning'); return;
            }
            if (employeeNamesOrdered.length === 0) {
                showToast('No hay empleados para seleccionar.', 'info'); return;
            }
            populateEmployeeSelects(domCache.modalCalendarEmployeeSelect);
            showModal(domCache.exportCalendarModal, domCache.modalCalendarEmployeeSelect);
        }

        function updateCalendarExportButtonsState() {
            const dataExistsAndMonthlyView = isDataLoadedForStats() && currentViewMode === 'monthly';
            if(domCache.exportMonthCalendarButton) domCache.exportMonthCalendarButton.disabled = !dataExistsAndMonthlyView;
            if (domCache.downloadWeeklySvgButton) {
                 domCache.downloadWeeklySvgButton.disabled = !dataExistsAndMonthlyView;
            }
        }

        const formatForICalTimezone = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            const H = String(date.getHours()).padStart(2, '0'), M = String(date.getMinutes()).padStart(2, '0'), S = String(date.getSeconds()).padStart(2, '0');
            return `${y}${m}${d}T${H}${M}${S}`;
        };

        const formatDateForICalAllDay = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            return `${y}${m}${d}`;
        };

        function showAddEmployeeModal() {
            if(domCache.modalEmployeeNameInput) domCache.modalEmployeeNameInput.value = '';
            showModal(domCache.addEmployeeModal, domCache.modalEmployeeNameInput);
        }

		function handleAddEmployeeFromModal() {
			const newName = domCache.modalEmployeeNameInput.value.trim();
			if (!newName) { 
				showToast('Introduce un nombre.', 'error'); 
				domCache.modalEmployeeNameInput.focus(); 
				return; 
			}
			if (newName.includes(',')) {
				showToast('El nombre del empleado no puede contener comas (,).', 'error');
				domCache.modalEmployeeNameInput.focus();
				return;
			}
			if (employeeNamesOrdered.includes(newName)) { 
				showToast(`"${newName}" ya existe.`, 'error'); 
				domCache.modalEmployeeNameInput.focus(); 
				return; 
			}

			saveStateForUndo(`Empleado "${newName}" añadido.`); 
			employeeNamesOrdered.push(newName);
			if (!scheduleData[newName]) {
				scheduleData[newName] = {};
				for (let m = 1; m <= 12; m++) scheduleData[newName][m] = {};
			}
			hideModal(domCache.addEmployeeModal);
			handleViewChange(); 
			initializeAndRenderNewStatistics();   // <--- AÑADIDO
			showToast(`Empleado "${newName}" añadido.`, 'success');
			enableControls(true); 
		}

        function promptDeleteEmployee(employeeName) {
            if (employeeNamesOrdered.length === 1) {
                showToast("No se puede eliminar al último empleado. Debe existir al menos un empleado en el horario.", 'warning');
                return;
            }

            employeeToDeleteName = employeeName;
            if(domCache.employeeNameToDeleteSpan) domCache.employeeNameToDeleteSpan.textContent = employeeName;
            if(domCache.modalConfirmDeleteEmployee) domCache.modalConfirmDeleteEmployee.disabled = true;
            let countdown = 5;
            if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = `Botón activo en ${countdown}s...`;
            if (deleteCountdownInterval) clearInterval(deleteCountdownInterval);
            deleteCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = `Botón activo en ${countdown}s...`;
                } else {
                    clearInterval(deleteCountdownInterval);
                    if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = '¡Botón de eliminar activo!';
                    if(domCache.modalConfirmDeleteEmployee) domCache.modalConfirmDeleteEmployee.disabled = false;
                }
            }, 1000);
            showModal(domCache.deleteEmployeeModal);
        }

		function confirmEmployeeDeletion() {
			if (employeeToDeleteName) {
				if (employeeNamesOrdered.length === 1 && employeeNamesOrdered[0] === employeeToDeleteName) {
					showToast("Error: No se puede eliminar al último empleado.", 'error');
					hideModal(domCache.deleteEmployeeModal, () => {
						if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
					});
					return;
				}

				saveStateForUndo(`Empleado "${employeeToDeleteName}" eliminado.`); 

				const index = employeeNamesOrdered.indexOf(employeeToDeleteName);
				if (index > -1) employeeNamesOrdered.splice(index, 1);
				delete scheduleData[employeeToDeleteName];

				handleViewChange(); 
				initializeAndRenderNewStatistics();

				showToast(`Empleado "${employeeToDeleteName}" eliminado.`, 'success');
				if (!isDataLoadedForStats()) { 
					resetToInitialState(true); 
				}
			}
			hideModal(domCache.deleteEmployeeModal, () => {
				if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
			});
		}

        function toggleAutosave(enabled) {
            isAutosaveEnabled = enabled;
            localStorage.setItem(LOCAL_STORAGE_KEY_AUTOSAVE, isAutosaveEnabled.toString());
            if (domCache.autosaveToggle) domCache.autosaveToggle.checked = isAutosaveEnabled;

            if (isAutosaveEnabled) {
                if (autosaveIntervalId) clearInterval(autosaveIntervalId);
                autosaveIntervalId = setInterval(() => {
                    if (hasUnsavedChanges && isDataLoadedForSave()) {
                        saveScheduleToLocalStorage(false); 
                        showToast('Progreso local autoguardado.', 'info', 2000);
                    }
                }, AUTOSAVE_INTERVAL_MS);
                showToast('Autoguardado local activado.', 'success');
            } else {
                if (autosaveIntervalId) {
                    clearInterval(autosaveIntervalId);
                    autosaveIntervalId = null;
                }
                showToast('Autoguardado local desactivado.', 'info');
            }
        }
        // ---------------------------------------------------------------------------------
        // --- NUEVA SECCIÓN DE ESTADÍSTICAS CON CHART.JS (Adaptación del Prototipo) ---
        // ---------------------------------------------------------------------------------

        // --- Constantes y Variables Globales para Nuevas Estadísticas ---
        const SHIFT_ICONS_PROTOTYPE = {
            M: 'fa-sun', T: 'fa-cloud-sun', N: 'fa-moon',
            L: 'fa-bed', V: 'fa-plane-departure', B: 'fa-briefcase-medical',
            Otro: 'fa-question-circle', 
            totalWorkDays: 'fa-briefcase', weekendsOff: 'fa-umbrella-beach'
        };

        let statsChartInstances = {}; 
        let currentStatsEmployeeData = []; 
        let currentSelectedPeriodForMainStats = 'all'; 
        let currentSelectedEmployeeForDetails = null; 
        let currentSelectedPeriodForDetailsStats = 'all'; 
			let hoveredEmployeeStatsIndex = -1;
		let currentSelectedPeriodForGeneralStats = 'all';

        // --- Funciones de Ayuda y Utilitarias para Nuevas Estadísticas ---

        /**
         * Obtiene el color de fondo de la configuración global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno (ej. 'M', 'T', 'empty').
         * @returns {string} Color hexadecimal o RGBA para Chart.js.
         */
        function getShiftBackgroundColorForChart(shiftType) {
			if (shiftType === 'totalWorkDays') return 'rgba(20, 184, 166, 0.3)'; // Verde con transparencia
			if (shiftType === 'weekendsOff') return 'rgba(96, 165, 250, 0.3)'; 
            const key = shiftType === 'Otro' ? 'empty' : shiftType; 
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexBg) {
                let hex = currentShiftColors[key].hexBg;
                if (hex.startsWith('#')) hex = hex.substring(1);
                if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, 0.7)`; 
            }
            return 'rgba(200, 200, 200, 0.7)'; 
        }

        /**
         * Obtiene el color de borde de la configuración global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno.
         * @returns {string} Color hexadecimal para Chart.js.
         */
        function getShiftBorderColorForChart(shiftType) {
            const key = shiftType === 'Otro' ? 'empty' : shiftType;
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexBg) {
                return currentShiftColors[key].hexBg; 
            }
            return 'rgb(150, 150, 150)'; 
        }

        /**
         * Obtiene el color de texto de la configuración global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno.
         * @returns {string} Color hexadecimal.
         */
        function getShiftTextColor(shiftType) {
            const key = shiftType === 'Otro' ? 'empty' : shiftType;
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexText) {
                return currentShiftColors[key].hexText;
            }
            return '#374151'; 
        }

        // --- Funciones de Cálculo de Estadísticas (Adaptación) ---

        /**
         * Calcula las estadísticas para todos los empleados basado en `scheduleData`.
         */
        function calculateAllEmployeeStatsForNewUI() {
            // (Log opcional para ver el scheduleData con el que EMPIEZA esta función)
            console.log("[VERIFICACIÓN 1] calculateAllEmployeeStatsForNewUI - ENTRANDO con scheduleData:", JSON.parse(JSON.stringify(scheduleData)));
            console.log("[VERIFICACIÓN 1] calculateAllEmployeeStatsForNewUI - ENTRANDO con employeeNamesOrdered:", JSON.parse(JSON.stringify(employeeNamesOrdered)));

            currentStatsEmployeeData = []; // Correcto: se limpia para recalcular.
            if (!isDataLoadedForStats()) { 
                console.warn("calculateAllEmployeeStatsForNewUI: No hay datos de horario cargados al inicio del cálculo.");
                return;
            }

            employeeNamesOrdered.forEach(empName => {
                let stats = { 
                    name: empName, 
                    M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, 
                    totalWorkDays: 0, weekendsOff: 0
                    // No es necesario M2, T2, N2 aquí si se agregan a M, T, N
                };

                if (!scheduleData[empName]) { // Comprueba el scheduleData actual
                    currentStatsEmployeeData.push(stats); 
                    return; // Pasa al siguiente empleado si este no tiene datos
                }

                for (let month = 1; month <= 12; month++) { // Itera todos los meses
                    if (!scheduleData[empName][month]) continue; // Si no hay datos para este mes, pasa al siguiente

                    const daysInThisMonth = getDaysInMonth(month, yearOfSchedule); 
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = scheduleData[empName][month][day]; // Lee del scheduleData actual
                        if (shift !== undefined && shift !== null && shift !== "") {
                            let effectiveShift = shift; 
                            let workShift = false;     

                            if (shift === 'M' || shift === 'M2') {
                                effectiveShift = 'M';
                                workShift = true;
                            } else if (shift === 'T' || shift === 'T2') {
                                effectiveShift = 'T';
                                workShift = true;
                            } else if (shift === 'N' || shift === 'N2') {
                                effectiveShift = 'N';
                                workShift = true;
                            } else if (shift === 'L') {
                                effectiveShift = 'L';
                            } else if (shift === 'V') {
                                effectiveShift = 'V';
                            } else if (shift === 'B') {
                                effectiveShift = 'B';
                            } else { 
                                effectiveShift = 'Otro';
                                workShift = true; 
                            }

                            if (stats.hasOwnProperty(effectiveShift)) {
                                stats[effectiveShift]++;
                            }

                            if (workShift) {
                                stats.totalWorkDays++;
                            }

                            const currentDate = new Date(yearOfSchedule, month - 1, day);
                            if (currentDate.getDay() === 6) { // Sábado
                                const nextDayDate = new Date(yearOfSchedule, month - 1, day + 1);
                                if (nextDayDate.getMonth() === month - 1) { 
                                    const satShift = scheduleData[empName][month][day]; 
                                    const sunShift = scheduleData[empName][month][day + 1]; 

                                    const isSatFree = (satShift === "L" || satShift === "V" || satShift === "B" || satShift === "");
                                    const isSunFree = (sunShift === "L" || sunShift === "V" || sunShift === "B" || sunShift === "");

                                    if (isSatFree && isSunFree) {
                                        stats.weekendsOff++;
                                    }
                                }
                            }
                        }
                    }
                }
                currentStatsEmployeeData.push(stats);
            });
            // (Log opcional para ver el currentStatsEmployeeData que PRODUCE esta función)
            console.log("[VERIFICACIÓN 2] calculateAllEmployeeStatsForNewUI - SALIENDO con currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
        }

        // --- Renderizado de la Tabla Principal de Estadísticas ---
        function createNewStatsTableHeader() {
            const thead = domCache.statsTableHead; 
            if (!thead) {
                console.error("Elemento thead para la nueva tabla de estadísticas no encontrado en domCache.");
                return;
            }
            thead.innerHTML = ''; 
            const tr = document.createElement('tr');

            let headerHTML = '<th>Empleado</th>';
            const shiftOrderForTable = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro', 'totalWorkDays', 'weekendsOff'];

            shiftOrderForTable.forEach(key => {
                const iconClass = SHIFT_ICONS_PROTOTYPE[key] || 'fa-circle-question';
                const iconColor = getShiftTextColor(key); 
                let displayName = key;
                if (key === 'totalWorkDays') displayName = 'Días Trab.';
                else if (key === 'weekendsOff') displayName = 'FDS Lib.';
                else if (SHIFT_TYPE_FULL_NAMES[key]) displayName = SHIFT_TYPE_FULL_NAMES[key].substring(0,3); 

                headerHTML += `<th><i class="fas ${iconClass}" style="color: ${iconColor};"></i>${displayName}</th>`;
            });
            tr.innerHTML = headerHTML;
            thead.appendChild(tr);
        }

        function renderNewStatsTable() {
            const tbody = domCache.statsTableBody;
            const paginationInfo = domCache.paginationInfo;

            if (!tbody) {
                console.error("Elemento tbody para la nueva tabla de estadísticas no encontrado en domCache.");
                return;
            }
            tbody.innerHTML = '';

            if (!currentStatsEmployeeData || currentStatsEmployeeData.length === 0 && currentSelectedPeriodForMainStats === 'all') { // Modificado para chequear también si es 'all'
                tbody.innerHTML = '<tr><td colspan="10" class="text-center p-4 text-gray-500">No hay datos de empleados para mostrar.</td></tr>';
                if (paginationInfo) paginationInfo.textContent = 'Mostrando 0 empleados';
                return;
            }

            let dataToRender;
            if (currentSelectedPeriodForMainStats === 'all') {
                // Log para ver qué currentStatsEmployeeData se usa para "Año Completo"
                console.log("[VERIFICACIÓN 3] renderNewStatsTable ('Año Completo') - Usando currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
                dataToRender = currentStatsEmployeeData;
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForMainStats);
                dataToRender = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let effectiveShift = shift;
                                let workShift = false;

                                if (shift === 'M' || shift === 'M2') { effectiveShift = 'M'; workShift = true; }
                                else if (shift === 'T' || shift === 'T2') { effectiveShift = 'T'; workShift = true; }
                                else if (shift === 'N' || shift === 'N2') { effectiveShift = 'N'; workShift = true; }
                                else if (shift === 'L') { effectiveShift = 'L'; }
                                else if (shift === 'V') { effectiveShift = 'V'; }
                                else if (shift === 'B') { effectiveShift = 'B'; }
                                else { effectiveShift = 'Otro'; workShift = true; }

                                if (monthlyStats.hasOwnProperty(effectiveShift)) {
                                    monthlyStats[effectiveShift]++;
                                }
                                if (workShift) {
                                    monthlyStats.totalWorkDays++;
                                }

                                const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                                if (currentDate.getDay() === 6) { 
                                    const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                                    if (nextDayDate.getMonth() === selectedMonthNum - 1) { 
                                        const satShiftOriginal = scheduleData[empName][selectedMonthNum][day];
                                        const sunShiftOriginal = scheduleData[empName][selectedMonthNum][day + 1];

                                        const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "");
                                        const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "");

                                        if (isSatFree && isSunFree) {
                                            monthlyStats.weekendsOff++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
                 if (dataToRender.length === 0) { // Si después de filtrar por mes no hay datos
                    tbody.innerHTML = `<tr><td colspan="10" class="text-center p-4 text-gray-500">No hay datos para ${MONTH_NAMES[selectedMonthNum-1]} ${yearOfSchedule}.</td></tr>`;
                    if (paginationInfo) paginationInfo.textContent = 'Mostrando 0 empleados';
                    return;
                }
            }

            dataToRender.forEach(emp => {
                const tr = document.createElement('tr');
                tr.dataset.employeeName = emp.name;

                let cellsHTML = `<td class="employee-name-cell">${emp.name}</td>`;
                const turnosYMetricas = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro', 'totalWorkDays', 'weekendsOff'];

                turnosYMetricas.forEach(st => {
                    const value = emp[st] || 0;
                    const bgColor = getShiftBackgroundColorForChart(st);
                    const textColor = getShiftTextColor(st);
                    const fullShiftName = SHIFT_TYPE_FULL_NAMES[st] || (st === 'totalWorkDays' ? 'Días Trabajados' : (st === 'weekendsOff' ? 'FDS Libres' : st));

                    cellsHTML += `<td style="background-color: ${bgColor}; color: ${textColor}; font-weight: 500;" title="${value} ${fullShiftName.toLowerCase()}">${value}</td>`;
                });
                tr.innerHTML = cellsHTML;
                tbody.appendChild(tr);

                tr.addEventListener('click', function() {
                    const employeeName = this.dataset.employeeName;
                    const fullEmployeeData = currentStatsEmployeeData.find(e => e.name === employeeName); // Usa los datos anuales para encontrar al empleado
                    if (fullEmployeeData) {
                        currentSelectedEmployeeForDetails = employeeName;
                        // Sincroniza el dropdown de detalles con el período principal actual
                        const mainFilterValue = domCache.selectedMonthText.dataset.currentMonthValue || 'all';
                        const mainFilterText = domCache.selectedMonthText.textContent;

                        if (domCache.detailsSelectedMonthText) {
                            domCache.detailsSelectedMonthText.textContent = mainFilterText;
                            domCache.detailsSelectedMonthText.dataset.currentMonthValue = mainFilterValue;
                        }
                        currentSelectedPeriodForDetailsStats = mainFilterValue;

                        if (domCache.detailsMonthDropdownOptions) {
                            domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                a.classList.toggle('active', a.dataset.month === mainFilterValue);
                            });
                        }
                        showIndividualEmployeeCharts(fullEmployeeData, mainFilterValue); // Pasa el período correcto
                    } else {
                        console.error("Datos del empleado no encontrados para:", employeeName, "en currentStatsEmployeeData:", currentStatsEmployeeData);
                        showToast(`No se pudieron cargar los detalles para ${employeeName}.`, 'error');
                    }
                });
            });

            if (paginationInfo) {
                paginationInfo.textContent = `Mostrando ${dataToRender.length} empleados`;
            }
        }

        // --- Manejo de Filtros de Mes/Año para Nuevas Estadísticas ---
        function populateNewStatsMonthFilterDropdown(dropdownOptionsId, buttonId, textElementId, contextType = 'main') { // 'main', 'details', 'general'
            const dropdownContent = document.getElementById(dropdownOptionsId);
            if (!dropdownContent) {
                console.error(`Dropdown content con ID '${dropdownOptionsId}' no encontrado.`);
                return;
            }
            dropdownContent.innerHTML = ''; // Limpiar opciones existentes

            let currentActiveMonth;
            if (contextType === 'details') {
                currentActiveMonth = currentSelectedPeriodForDetailsStats;
            } else if (contextType === 'general') {
                currentActiveMonth = currentSelectedPeriodForGeneralStats;
            } else { // 'main'
                currentActiveMonth = currentSelectedPeriodForMainStats;
            }

            // Opción "Año Completo"
            const allYearOption = document.createElement('a');
            allYearOption.href = "#";
            allYearOption.textContent = "Año Completo";
            allYearOption.dataset.month = "all";
            if (currentActiveMonth === 'all') {
                allYearOption.classList.add('active');
            }
            allYearOption.addEventListener('click', (e) => handleNewStatsMonthFilterClick(e, buttonId, textElementId, contextType));
            dropdownContent.appendChild(allYearOption);

            // Opciones para cada mes
            MONTH_NAMES.forEach((month, index) => {
                const option = document.createElement('a');
                option.href = "#";
                option.textContent = month;
                option.dataset.month = (index + 1).toString();
                if (currentActiveMonth === (index + 1).toString()) {
                    option.classList.add('active');
                }
                option.addEventListener('click', (e) => handleNewStatsMonthFilterClick(e, buttonId, textElementId, contextType));
                dropdownContent.appendChild(option);
            });
        }

        function handleNewStatsMonthFilterClick(event, buttonId, textElementId, contextType) { // contextType ahora es 'main', 'details', o 'general'
             
   event.preventDefault();
                const selectedLink = event.currentTarget;
                const newSelectedMonth = selectedLink.dataset.month;
                const textElement = document.getElementById(textElementId);

                if (textElement) {
                        textElement.textContent = selectedLink.textContent;
                        textElement.dataset.currentMonthValue = newSelectedMonth;
                }

                const dropdownOptionsContainer = document.getElementById(buttonId).nextElementSibling;
                if (dropdownOptionsContainer) {
                        dropdownOptionsContainer.querySelectorAll('a').forEach(a => a.classList.remove('active'));
                }
                selectedLink.classList.add('active');
                toggleNewStatsMonthDropdown(false, buttonId); // Cierra el dropdown

                if (contextType === 'details') {
                        currentSelectedPeriodForDetailsStats = newSelectedMonth;
                        if (currentSelectedEmployeeForDetails) {
                                const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                                if (employeeData) {
                                        showIndividualEmployeeCharts(employeeData, currentSelectedPeriodForDetailsStats);
                                }
                        }
                } else if (contextType === 'general') { 
                        // PUNTO DE VERIFICACIÓN 1: ¿Se actualiza currentSelectedPeriodForGeneralStats?
                        currentSelectedPeriodForGeneralStats = newSelectedMonth; 

                        // PUNTO DE VERIFICACIÓN 2: ¿Se llama a renderGeneralPlantillaStatsCharts si la sección está visible?
                        if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                                renderGeneralPlantillaStatsCharts(); 
                        }
                } else { // 'main' context (dropdown principal de la tabla de estadísticas)
                        currentSelectedPeriodForMainStats = newSelectedMonth;
                        renderNewStatsTable(); 

                        if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                                currentSelectedPeriodForGeneralStats = newSelectedMonth; 
                                
                                if(domCache.generalStatsSelectedMonthText) { 
                                        domCache.generalStatsSelectedMonthText.textContent = selectedLink.textContent; 
                                        domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = newSelectedMonth;
                                }
                                if(domCache.generalStatsMonthDropdownOptions) {
                                         domCache.generalStatsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                                a.classList.toggle('active', a.dataset.month === newSelectedMonth);
                                        });
                                }
                                renderGeneralPlantillaStatsCharts();
                        }

                        if (domCache.individualChartsSection && !domCache.individualChartsSection.classList.contains('hidden') && currentSelectedEmployeeForDetails) {
                                const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                                if (employeeData) {
                                        if (domCache.detailsSelectedMonthText) {
                                                domCache.detailsSelectedMonthText.textContent = selectedLink.textContent; 
                                                domCache.detailsSelectedMonthText.dataset.currentMonthValue = newSelectedMonth;
                                        }
                                        currentSelectedPeriodForDetailsStats = newSelectedMonth; 
                                        if (domCache.detailsMonthDropdownOptions) {
                                                domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                                        a.classList.toggle('active', a.dataset.month === newSelectedMonth);
                                                });
                                        }
                                        showIndividualEmployeeCharts(employeeData, newSelectedMonth);
                                }
                        }
                }
        }

        function toggleNewStatsMonthDropdown(forceShow, buttonId) {
            const buttonElement = document.getElementById(buttonId);
            if (!buttonElement) return;
            const dropdownContent = buttonElement.nextElementSibling;
            if (!dropdownContent) return;
            const icon = buttonElement.querySelector('i');

            const isCurrentlyShown = dropdownContent.classList.contains('show');

            if (forceShow === true || (!isCurrentlyShown && forceShow !== false)) {
                dropdownContent.classList.add('show');
                if (icon) icon.classList.add('rotate-180');
            } else if (forceShow === false || isCurrentlyShown) {
                dropdownContent.classList.remove('show');
                if (icon) icon.classList.remove('rotate-180');
            }
        }

        // --- Lógica para Mostrar/Ocultar Secciones de Estadísticas ---
		function showIndividualEmployeeCharts(employeeData, monthContextForCharts) {
			// Asegúrate de que los elementos del DOM estén cacheados y existan
			if (!domCache.individualChartsSection || !domCache.mainStatsTableSection ||
				!domCache.generalPlantillaStatsSection || !domCache.donutChartWrapper ||
				!domCache.calendarHeatmapWrapper || !domCache.donutCalendarGrid ||
				!domCache.selectedMonthYearDisplayDetails || !domCache.selectedEmployeeName) {
				console.error("Error: Faltan elementos del DOM cacheados para la vista individual de estadísticas.");
				return;
			}

			// Actualizar cabecera de la sección
			domCache.selectedMonthYearDisplayDetails.textContent = monthContextForCharts === 'all' ?
				`Año ${yearOfSchedule}` :
				`${MONTH_NAMES[parseInt(monthContextForCharts) - 1]} ${yearOfSchedule}`;
			domCache.selectedEmployeeName.textContent = employeeData.name;

			// Mostrar la sección de detalles individuales y ocultar las otras
			domCache.individualChartsSection.classList.remove('hidden');
			domCache.mainStatsTableSection.classList.add('hidden');
			domCache.generalPlantillaStatsSection.classList.add('hidden');

			// Lógica para mostrar/ocultar calendario y ajustar layout del grid
			if (monthContextForCharts === 'all') {
				// VISTA ANUAL: Ocultar calendario, donut ocupa todo el ancho del grid
				domCache.calendarHeatmapWrapper.classList.add('hidden'); // Oculta el contenedor del calendario

				// Hacer que el donut ocupe las dos columnas del grid (si el grid es de 2 columnas)
				// o asegurarse de que el grid se ajuste a una sola columna.
				domCache.donutChartWrapper.classList.remove('md:col-span-1');
				domCache.donutChartWrapper.classList.add('md:col-span-2'); // Que ocupe 2 columnas

				domCache.donutCalendarGrid.classList.remove('md:grid-cols-2');
				domCache.donutCalendarGrid.classList.add('md:grid-cols-1'); // El grid ahora es de 1 columna

			} else {
				// VISTA MENSUAL: Mostrar calendario, donut y calendario comparten espacio
				domCache.calendarHeatmapWrapper.classList.remove('hidden'); // Muestra el contenedor del calendario

				// Restaurar para que cada uno ocupe una columna
				domCache.donutChartWrapper.classList.remove('md:col-span-2');
				domCache.donutChartWrapper.classList.add('md:col-span-1'); // Ocupa 1 columna

				domCache.calendarHeatmapWrapper.classList.remove('md:col-span-2'); // Asegurar por si acaso
				domCache.calendarHeatmapWrapper.classList.add('md:col-span-1'); // Ocupa 1 columna

				domCache.donutCalendarGrid.classList.remove('md:grid-cols-1');
				domCache.donutCalendarGrid.classList.add('md:grid-cols-2'); // El grid vuelve a ser de 2 columnas
			}

			// Renderizar los gráficos (después de que el DOM esté visible y ajustado)
			requestAnimationFrame(() => {
				renderDonutChartForEmployee(employeeData, monthContextForCharts);

				// Solo renderizar el calendario si NO es "Año Completo" (vista mensual)
				if (monthContextForCharts !== 'all') {
					renderMiniCalendarHeatmapForEmployee(employeeData, monthContextForCharts);
				}
				// Los KPIs siempre se renderizan si la sección individual está visible
				renderKpiSummaryCardsForEmployee(employeeData, monthContextForCharts);
			});
		}

        function showGeneralPlantillaStatsCharts() {
            if (!domCache.generalPlantillaStatsSection || !domCache.mainStatsTableSection || !domCache.individualChartsSection) {
                console.error("Alguna sección de estadísticas no está en domCache para showGeneralPlantillaStatsCharts.");
                return;
            }
            domCache.generalPlantillaStatsSection.classList.remove('hidden');
            domCache.mainStatsTableSection.classList.add('hidden');
            domCache.individualChartsSection.classList.add('hidden');

            currentSelectedPeriodForGeneralStats = currentSelectedPeriodForMainStats;

            if (domCache.generalStatsSelectedMonthText && domCache.selectedMonthText) { 
                domCache.generalStatsSelectedMonthText.textContent = domCache.selectedMonthText.textContent; 
                domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForGeneralStats;
            }
            
            if (domCache.generalStatsMonthDropdownOptions && domCache.generalStatsMonthDropdownBtn && domCache.generalStatsSelectedMonthText) {
                 populateNewStatsMonthFilterDropdown(
                     'general-stats-month-dropdown-options',
                     'general-stats-month-dropdown-btn',
                     'general-stats-selected-month-text',
                     'general'
                 );
            }

            requestAnimationFrame(() => {
                renderGeneralStackedBarChart(); 
                renderGeneralGroupedBarChart(); 
            });
        }


        function renderDonutChartForEmployee(empData, monthContext) {
            const canvasElement = domCache.donutChartCanvas;
            const messageDiv = domCache.donutChartMessage;
            if (!canvasElement || !messageDiv) {
                console.error("Elementos para Donut Chart no encontrados.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'employeeDonutChart';

            // Destruir instancia previa del gráfico si existe
            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }
            messageDiv.textContent = ''; // Limpiar mensajes previos

            // Inicializa dataForChart para las categorías consolidadas
            let dataForChart = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };

            if (monthContext !== 'all') {
                // --- Lógica para contexto mensual ---
                const selectedMonthNum = parseInt(monthContext);
                // Reiniciamos dataForChart para el cálculo mensual específico
                dataForChart = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };

                if (scheduleData[empData.name] && scheduleData[empData.name][selectedMonthNum]) {
                    const monthSchedule = scheduleData[empData.name][selectedMonthNum];
                    const daysInMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);

                    for (let day = 1; day <= daysInMonth; day++) {
                        const shift = monthSchedule[day];
                        if (shift && shift !== "") { // Solo procesar si hay un turno asignado
                            if (shift === 'M' || shift === 'M2') {
                                dataForChart.M = (dataForChart.M || 0) + 1;
                            } else if (shift === 'T' || shift === 'T2') {
                                dataForChart.T = (dataForChart.T || 0) + 1;
                            } else if (shift === 'N' || shift === 'N2') {
                                dataForChart.N = (dataForChart.N || 0) + 1;
                            } else if (SHIFT_TYPES.includes(shift)) { // Para L, V, B directos
                                dataForChart[shift] = (dataForChart[shift] || 0) + 1;
                            } else { // Turnos personalizados o no estándar que no son L, V, B
                                dataForChart.Otro = (dataForChart.Otro || 0) + 1;
                            }
                        }
                    }
                }
            } else {
                // --- Lógica para contexto anual ('all') ---
                // Se asume que empData (proveniente de calculateAllEmployeeStatsForNewUI)
                // contiene los conteos anuales separados para M, M2, T, T2, N, N2.
                dataForChart.M = (empData.M || 0) + (empData.M2 || 0);
                dataForChart.T = (empData.T || 0) + (empData.T2 || 0);
                dataForChart.N = (empData.N || 0) + (empData.N2 || 0);
                dataForChart.L = empData.L || 0;
                dataForChart.V = empData.V || 0;
                dataForChart.B = empData.B || 0;
                dataForChart.Otro = empData.Otro || 0;
            }

            // Preparar datos para Chart.js
            const shiftTypesForDonutDisplay = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro'];
            const labelsForDonut = [];
            const dataCountsForDonut = [];
            const backgroundColorsForDonut = [];

            shiftTypesForDonutDisplay.forEach(st => {
                const count = dataForChart[st] || 0;
                if (count > 0) { // Solo añadir al gráfico si hay conteo
                    labelsForDonut.push(SHIFT_TYPE_FULL_NAMES[st] || st); // Usar nombre completo si está disponible
                    dataCountsForDonut.push(count);
                    backgroundColorsForDonut.push(getShiftBackgroundColorForChart(st));
                }
            });

            // Manejar caso sin datos
            if (dataCountsForDonut.length === 0) {
                messageDiv.textContent = 'Sin datos de turnos para mostrar en este período.';
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); // Limpiar canvas
                delete statsChartInstances[chartId]; // Eliminar referencia a instancia inexistente
                return;
            }

            // Crear nueva instancia de Chart.js
            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labelsForDonut,
                    datasets: [{
                        label: 'Proporción de Turnos',
                        data: dataCountsForDonut,
                        backgroundColor: backgroundColorsForDonut,
                        hoverOffset: 6,
                        borderColor: '#fff', // Borde blanco entre segmentos
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    cutout: '60%', // Tamaño del agujero central
                    plugins: {
                        legend: {
                            position: 'bottom', // Posición de la leyenda
                            labels: {
                                font: { size: 10, weight: '500' },
                                padding: 8,
                                boxWidth: 12,
                                boxHeight: 12
                            }
                        },
                        tooltip: {
                            titleFont: { size: 13, weight: 'bold' },
                            bodyFont: { size: 12 },
                            callbacks: {
                                title: (tooltipItems) => tooltipItems[0].label,
                                label: (context) => {
                                    let value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `Cantidad: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderMiniCalendarHeatmapForEmployee(empData, monthContext) {
            const container = domCache.miniCalendarHeatmapContainer; 
            const titleElement = domCache.calendarHeatmapTitle; 
            if (!container || !titleElement) { 
                console.error("Elementos para Mini Calendar no encontrados en domCache:", domCache);
                // Comprueba si los IDs 'mini-calendar-heatmap-container' y 'calendar-heatmap-title' 
                // están correctamente definidos en tu HTML y cacheados en domCache.
                return; 
            }
            container.innerHTML = '';

            const displayMonth = (monthContext === 'all' || monthContext === undefined) ? new Date().getMonth() : parseInt(monthContext) - 1;
            const displayYear = yearOfSchedule;

            titleElement.textContent = `Calendario para ${MONTH_NAMES[displayMonth]} ${displayYear}`;
    
            const CALENDAR_HEADERS_MONDAY_START = ["L", "M", "X", "J", "V", "S", "D"]; 
    
            CALENDAR_HEADERS_MONDAY_START.forEach(dayName => {
                const dayHeader = createElement('div', { className: 'calendar-header-day', textContent: dayName });
                container.appendChild(dayHeader);
            });

            const firstDayOfMonth = new Date(displayYear, displayMonth, 1);
            const daysInMonth = getDaysInMonth(displayMonth + 1, displayYear); 
    
            let firstDayOfWeek = firstDayOfMonth.getDay(); 
            firstDayOfWeek = (firstDayOfWeek === 0) ? 6 : firstDayOfWeek - 1; 

            for (let i = 0; i < firstDayOfWeek; i++) {
                container.appendChild(createElement('div', { className: 'calendar-day empty' }));
            }

            for (let dayNum = 1; dayNum <= daysInMonth; dayNum++) {
                const dayCell = createElement('div', { className: 'calendar-day border', textContent: dayNum });
                const shift = scheduleData[empData.name]?.[displayMonth + 1]?.[dayNum] || ""; 
                const shiftKeyForColor = shift === "" ? 'empty' : shift;
                // Asegúrate de que currentShiftColors y SHIFT_TYPE_FULL_NAMES estén accesibles y correctos
                const colorConf = currentShiftColors[shiftKeyForColor] || currentShiftColors.empty;

                dayCell.style.backgroundColor = colorConf.hexBg;
                dayCell.style.color = colorConf.hexText;
                dayCell.title = `Día ${dayNum}: ${shift ? (SHIFT_TYPE_FULL_NAMES[shift] || shift) : 'Vacío'}`;
                container.appendChild(dayCell);
            }
        }	

        function renderKpiSummaryCardsForEmployee(empData, monthContext) {
            const container = domCache.kpiSummaryCardContainer; 
            if (!container) { console.error("Contenedor KPI no encontrado."); return; }
            container.innerHTML = '';

            let dataForKPIs = { ...empData };
            if (monthContext !== 'all') {
                const selectedMonthNum = parseInt(monthContext);
                dataForKPIs = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0, M2:0, T2:0, N2:0 };
                if (scheduleData[empData.name] && scheduleData[empData.name][selectedMonthNum]) {
                    const monthSchedule = scheduleData[empData.name][selectedMonthNum];
                    const daysInMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                    for (let day = 1; day <= daysInMonth; day++) {
                        const shift = monthSchedule[day];
                        if (shift && SHIFT_TYPES.includes(shift)) {
                            dataForKPIs[shift] = (dataForKPIs[shift] || 0) + 1;
                            if (['M', 'M2', 'T', 'T2', 'N', 'N2'].includes(shift)) dataForKPIs.totalWorkDays++;
                        } else if (shift && shift !== "") {
                            dataForKPIs.Otro = (dataForKPIs.Otro || 0) + 1;
                            dataForKPIs.totalWorkDays++;
                        }
                        const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                        if (currentDate.getDay() === 6) { 
                            const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                            if (nextDayDate.getMonth() === selectedMonthNum - 1) {
                                const satShift = scheduleData[empData.name][selectedMonthNum][day];
                                const sunShift = scheduleData[empData.name][selectedMonthNum][day + 1];
                                if ((satShift === "L" || satShift === "V" || satShift === "B" || satShift === "") &&
                                    (sunShift === "L" || sunShift === "V" || sunShift === "B" || sunShift === "")) {
                                    dataForKPIs.weekendsOff = (dataForKPIs.weekendsOff || 0) + 1;
                                }
                            }
                        }
                    }
                }
            }

            const kpiMetrics = [
                { key: 'M', label: 'Mañanas' }, { key: 'T', label: 'Tardes' }, { key: 'N', label: 'Noches' },
                { key: 'L', label: 'Libres' }, { key: 'V', label: 'Vacaciones' }, { key: 'B', label: 'Bajas' },
                { key: 'Otro', label: 'Otros' },
                { key: 'totalWorkDays', label: 'Días Trab.' }, { key: 'weekendsOff', label: 'FDS Libres' }
            ];

            kpiMetrics.forEach(metric => {
                const card = createElement('div', { className: 'kpi-card' });
                const value = dataForKPIs[metric.key] || 0;
                const textColor = getShiftTextColor(metric.key); 
                card.innerHTML = `
                    <div class="kpi-value" style="color: ${textColor};">${value}</div>
                    <div class="kpi-label">${metric.label}</div>
                `;
                container.appendChild(card);
            });
        }

        // --- Renderizado de Gráficos Generales de Plantilla ---
        function renderGeneralStackedBarChart() {
            const canvasElement = domCache.generalStackedBarCanvas;
            if (!canvasElement) {
                console.error("Canvas 'generalStackedBarCanvas' no encontrado en domCache.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'generalStackedBar';

            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }

            let dataForGeneralCharts;
            if (currentSelectedPeriodForGeneralStats === 'all') {
                // Log para ver qué currentStatsEmployeeData se usa para "Año Completo"
                console.log("[VERIFICACIÓN 3] renderGeneralStackedBarChart ('Año Completo') - Usando currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
                dataForGeneralCharts = currentStatsEmployeeData; // Datos anuales ya agregados
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForGeneralStats); 
                dataForGeneralCharts = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let effectiveShift = shift;
                                if (shift === 'M' || shift === 'M2') { effectiveShift = 'M'; }
                                else if (shift === 'T' || shift === 'T2') { effectiveShift = 'T'; }
                                else if (shift === 'N' || shift === 'N2') { effectiveShift = 'N'; }
                                else if (shift === 'L') { effectiveShift = 'L'; }
                                else if (shift === 'V') { effectiveShift = 'V'; }
                                else if (shift === 'B') { effectiveShift = 'B'; }
                                else if (!SHIFT_TYPES.includes(shift)) { 
                                    effectiveShift = 'Otro';
                                }

                                if (monthlyStats.hasOwnProperty(effectiveShift)) {
                                    monthlyStats[effectiveShift]++;
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
            }

            const employeeNames = dataForGeneralCharts.map(emp => emp.name);
            const shiftTypesToStack = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro']; 

            const datasets = shiftTypesToStack.map(shiftType => {
                return {
                    label: SHIFT_TYPE_FULL_NAMES[shiftType] || shiftType,
                    data: dataForGeneralCharts.map(emp => emp[shiftType] || 0),
                    backgroundColor: getShiftBackgroundColorForChart(shiftType),
                    borderColor: getShiftBorderColorForChart(shiftType),
                    borderWidth: 1
                };
            });

            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'bar',
                data: { labels: employeeNames, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, chartElement) => {
                        hoveredEmployeeStatsIndex = chartElement[0] ? chartElement[0].index : -1;
                        if (statsChartInstances[chartId]) statsChartInstances[chartId].update('none');
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                font: {
                                    size: 10,
                                    weight: (context) => (context.index === hoveredEmployeeStatsIndex ? 'bold' : 'normal')
                                },
                                color: (context) => (context.index === hoveredEmployeeStatsIndex ? '#4f46e5' : '#374151'),
                                autoSkip: true, maxRotation: 45, minRotation: 30
                            }
                        },
                        y: { stacked: true, beginAtZero: true, ticks: { precision: 0, font: { size: 10 } } }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false } }
                }
            });
        }


        function renderGeneralGroupedBarChart() {
            const canvasElement = domCache.generalGroupedBarCanvas;
            if (!canvasElement) {
                console.error("Canvas 'generalGroupedBarCanvas' no encontrado en domCache.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'generalGroupedBar';
  
            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }
  
            let dataForGeneralCharts;
            // ***** CORRECCIÓN CRUCIAL AQUÍ: Usar currentSelectedPeriodForGeneralStats *****
            if (currentSelectedPeriodForGeneralStats === 'all') {
                dataForGeneralCharts = currentStatsEmployeeData; // Usa datos anuales ya agregados
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForGeneralStats); // Usar la variable correcta
                dataForGeneralCharts = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, totalWorkDays: 0, weekendsOff: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let workShift = false;
                                // Agregación de M2, T2, N2 para contar días trabajados
                                if (shift === 'M' || shift === 'M2') { workShift = true; }
                                else if (shift === 'T' || shift === 'T2') { workShift = true; }
                                else if (shift === 'N' || shift === 'N2') { workShift = true; }
                                else if (!['L', 'V', 'B', ''].includes(shift)) { 
                                    workShift = true;
                                }
                                if (workShift) {
                                    monthlyStats.totalWorkDays++;
                                }
  
                                // Lógica para weekendsOff
                                const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                                if (currentDate.getDay() === 6) { 
                                    const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                                    if (nextDayDate.getMonth() === selectedMonthNum - 1) { 
                                        const satShiftOriginal = scheduleData[empName][selectedMonthNum][day];
                                        const sunShiftOriginal = scheduleData[empName][selectedMonthNum][day + 1];
                                        const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "");
                                        const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "");
                                        if (isSatFree && isSunFree) {
                                            monthlyStats.weekendsOff++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
            }
  
            const employeeNames = dataForGeneralCharts.map(emp => emp.name);
            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: employeeNames,
                    datasets: [
                        {
                            label: 'Días Trabajados',
                            data: dataForGeneralCharts.map(emp => emp.totalWorkDays || 0),
                            backgroundColor: getShiftBackgroundColorForChart('totalWorkDays'),
                            borderColor: getShiftBorderColorForChart('totalWorkDays'),
                            borderWidth: 1, barPercentage: 0.7, categoryPercentage: 0.6
                        },
                        {
                            label: 'FDS Libres',
                            data: dataForGeneralCharts.map(emp => emp.weekendsOff || 0),
                            backgroundColor: getShiftBackgroundColorForChart('weekendsOff'),
                            borderColor: getShiftBorderColorForChart('weekendsOff'),
                            borderWidth: 1, barPercentage: 0.7, categoryPercentage: 0.6
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    onHover: (event, chartElement) => {
                        hoveredEmployeeStatsIndex = chartElement[0] ? chartElement[0].index : -1;
                        if (statsChartInstances[chartId]) statsChartInstances[chartId].update('none');
                    },
                    scales: {
                        x: {
                            ticks: {
                                font: {
                                    size: 10,
                                    weight: (context) => (context.index === hoveredEmployeeStatsIndex ? 'bold' : 'normal')
                                },
                                color: (context) => (context.index === hoveredEmployeeStatsIndex ? '#4f46e5' : '#374151'),
                                autoSkip: true, maxRotation: 45, minRotation: 30
                            }
                        },
                        y: { beginAtZero: true, ticks: { precision: 0, font: { size: 10 } } }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false } }
                }
            });
        }

        // --- Inicialización y Event Listeners para Nuevas Estadísticas ---
        function setupNewStatisticsEventListeners() {
            if (domCache.mainMonthDropdownBtn) {
                domCache.mainMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'month-dropdown-btn');
                });
            }

            if (domCache.detailsMonthDropdownBtn) {
                domCache.detailsMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'details-month-dropdown-btn');
                });
            }

            if (domCache.generalStatsMonthDropdownBtn) {
                domCache.generalStatsMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'general-stats-month-dropdown-btn');
                });
            }

            if (domCache.showGeneralStatsBtn) {
                domCache.showGeneralStatsBtn.addEventListener('click', showGeneralPlantillaStatsCharts);
            }

            if (domCache.closeIndividualChartsBtn) {
                domCache.closeIndividualChartsBtn.addEventListener('click', () => {
                    if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
                    if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                    currentSelectedEmployeeForDetails = null; 
                });
            }
            if (domCache.closeGeneralStatsBtn) {
                domCache.closeGeneralStatsBtn.addEventListener('click', () => {
                    if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
                    if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                });
            }

            window.addEventListener('click', function(event) {
                if (domCache.mainMonthDropdownBtn && !domCache.mainMonthDropdownBtn.contains(event.target) &&
                    domCache.mainMonthDropdownOptions && !domCache.mainMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'month-dropdown-btn');
                }
                if (domCache.detailsMonthDropdownBtn && !domCache.detailsMonthDropdownBtn.contains(event.target) &&
                    domCache.detailsMonthDropdownOptions && !domCache.detailsMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'details-month-dropdown-btn');
                }
                if (domCache.generalStatsMonthDropdownBtn && !domCache.generalStatsMonthDropdownBtn.contains(event.target) &&
                    domCache.generalStatsMonthDropdownOptions && !domCache.generalStatsMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'general-stats-month-dropdown-btn');
                }
            });
        }

        function initializeAndRenderNewStatistics() {
            // Primero, verifica si hay datos cargados para mostrar estadísticas.
            // Si no hay datos, muestra un mensaje placeholder y oculta las secciones de estadísticas.
            if (!isDataLoadedForStats()) {
                const placeholder = document.getElementById('stats-placeholder-reformed'); // Asumiendo que tienes este elemento
                if (placeholder) {
                    placeholder.innerHTML = '<p class="text-center text-gray-500 py-8">No hay datos de horario cargados o no hay empleados para mostrar estadísticas. <br>Importa un archivo CSV o aplica una plantilla vacía.</p>';
                    placeholder.classList.remove('hidden');
                }
                // Ocultar las secciones principales de estadísticas si no hay datos
                if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.add('hidden');
                if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
                if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
                // Deshabilitar botones o controles que dependan de datos de estadísticas
                if(domCache.showGeneralStatsBtn) domCache.showGeneralStatsBtn.disabled = true;
                if(domCache.mainMonthDropdownBtn) domCache.mainMonthDropdownBtn.disabled = true;
                if(domCache.detailsMonthDropdownBtn) domCache.detailsMonthDropdownBtn.disabled = true;
                if(domCache.generalStatsMonthDropdownBtn) domCache.generalStatsMonthDropdownBtn.disabled = true;
                return;
            } else {
                // Si hay datos, oculta el placeholder y muestra la sección principal de la tabla de estadísticas.
                const placeholder = document.getElementById('stats-placeholder-reformed');
                if (placeholder) placeholder.classList.add('hidden');
                if (domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                // Habilitar botones
                if(domCache.showGeneralStatsBtn) domCache.showGeneralStatsBtn.disabled = false;
                if(domCache.mainMonthDropdownBtn) domCache.mainMonthDropdownBtn.disabled = false;
                if(domCache.detailsMonthDropdownBtn) domCache.detailsMonthDropdownBtn.disabled = false;
                if(domCache.generalStatsMonthDropdownBtn) domCache.generalStatsMonthDropdownBtn.disabled = false;
            }

            // Calcula las estadísticas anuales para todos los empleados.
            // Esta función debería llenar `currentStatsEmployeeData`.
            calculateAllEmployeeStatsForNewUI();

            // --- LÓGICA PARA ESTABLECER EL MES POR DEFECTO DE LAS ESTADÍSTICAS ---
            // `currentSelectedMonth` es la variable global que indica el mes activo del horario principal.
            // Esta variable ya debería estar inicializada correctamente al cargar la app
            // (ej. al mes actual, al primer mes, o al último mes visto guardado en localStorage).
            
            // Establece el período para la tabla principal de estadísticas al mes activo del horario.
            if (currentSelectedMonth >= 1 && currentSelectedMonth <= 12) {
                currentSelectedPeriodForMainStats = currentSelectedMonth.toString();
            } else {
                // Fallback si currentSelectedMonth no es válido (aunque no debería pasar si la app se inicializa bien)
                console.warn("currentSelectedMonth no es válido al inicializar estadísticas, usando '1' (Enero) como fallback.");
                currentSelectedPeriodForMainStats = '1'; // Enero por defecto
            }

            // Actualiza el texto y el estado activo del dropdown principal de estadísticas.
            if (domCache.selectedMonthText) {
                // Asegurarse de que el índice sea válido para MONTH_NAMES
                const monthIndex = parseInt(currentSelectedPeriodForMainStats) - 1;
                if (monthIndex >= 0 && monthIndex < MONTH_NAMES.length) {
                    domCache.selectedMonthText.textContent = MONTH_NAMES[monthIndex];
                } else {
                    domCache.selectedMonthText.textContent = "Año Completo"; // Fallback si el mes no es válido
                    currentSelectedPeriodForMainStats = 'all'; // Corregir el período si el mes no fue válido
                }
                domCache.selectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForMainStats;
            }
            // --- FIN DE LA LÓGICA PARA ESTABLECER MES POR DEFECTO ---

            // Poblar los dropdowns de mes/año para todas las secciones de estadísticas.
            // La función populateNewStatsMonthFilterDropdown usará las variables 
            // currentSelectedPeriod... para marcar la opción correcta como activa.

            // Dropdown para la tabla principal de estadísticas
            if (domCache.mainMonthDropdownOptions && domCache.mainMonthDropdownBtn && domCache.selectedMonthText) {
                populateNewStatsMonthFilterDropdown('month-dropdown-options', 'month-dropdown-btn', 'selected-month-text', 'main');
            }

            // Dropdown para los detalles individuales del empleado
            // Se inicializa, pero su valor se sincronizará completamente cuando se abra un empleado.
            // Podrías hacer que también tome currentSelectedMonth por defecto aquí si lo deseas.
            currentSelectedPeriodForDetailsStats = currentSelectedPeriodForMainStats; // Sincronizar con el principal inicialmente
            if (domCache.detailsMonthDropdownOptions && domCache.detailsMonthDropdownBtn && domCache.detailsSelectedMonthText) {
                 if (domCache.detailsSelectedMonthText && currentSelectedPeriodForDetailsStats !== 'all') {
                    domCache.detailsSelectedMonthText.textContent = MONTH_NAMES[parseInt(currentSelectedPeriodForDetailsStats) - 1];
                 } else if (domCache.detailsSelectedMonthText) {
                    domCache.detailsSelectedMonthText.textContent = "Año Completo";
                 }
                 if(domCache.detailsSelectedMonthText) domCache.detailsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForDetailsStats;
                populateNewStatsMonthFilterDropdown('details-month-dropdown-options', 'details-month-dropdown-btn', 'details-selected-month-text', 'details');
            }
            
            // Dropdown para las estadísticas generales de la plantilla
            currentSelectedPeriodForGeneralStats = currentSelectedPeriodForMainStats; // Sincronizar con el principal inicialmente
            if (domCache.generalStatsMonthDropdownOptions && domCache.generalStatsMonthDropdownBtn && domCache.generalStatsSelectedMonthText) {
                 if (domCache.generalStatsSelectedMonthText && currentSelectedPeriodForGeneralStats !== 'all') {
                    domCache.generalStatsSelectedMonthText.textContent = MONTH_NAMES[parseInt(currentSelectedPeriodForGeneralStats) - 1];
                 } else if (domCache.generalStatsSelectedMonthText) {
                    domCache.generalStatsSelectedMonthText.textContent = "Año Completo";
                 }
                 if(domCache.generalStatsSelectedMonthText) domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForGeneralStats;
                populateNewStatsMonthFilterDropdown('general-stats-month-dropdown-options', 'general-stats-month-dropdown-btn', 'general-stats-selected-month-text', 'general');
            }

            // Renderiza la cabecera y el cuerpo de la tabla principal de estadísticas.
            // renderNewStatsTable() usará currentSelectedPeriodForMainStats.
            createNewStatsTableHeader();
            renderNewStatsTable(); 

            // Asegúrate de que las vistas de detalles y generales estén ocultas al inicio.
            if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
            if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
        }
		

    </script>
</body>
</html>

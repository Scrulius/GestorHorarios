<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de Horarios Laborales para Gran Hotel Miramar</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìÜ</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Times+New+Roman&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.1/dist/svg2pdf.umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> 
	<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js" referrerpolicy="no-referrer"></script>
	<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        #logo-container svg {
            width: 200px;
            height: auto;
            margin-bottom: 0.75rem;
        }
        .table-container {
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 0 0 0.375rem 0.375rem;
        }
        .sticky-col {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            z-index: 10;
        }
        .draggable-row.bg-white > .sticky-col,
        .draggable-row > .sticky-col.employee-name-cell {
            background-color: #ffffff !important;
        }
        .draggable-row.bg-gray-50 > .sticky-col {
             background-color: #f9fafb !important; /* Tailwind bg-gray-50 */
        }
    
        .sticky-col-header {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
			top: 0; /* ASEG√öRATE DE QUE top: 0; EST√â PRESENTE AQU√ç */
            z-index: 30;
            background-color: #f9fafb; /* gray-50 */
        }
		.sticky-header th:not(.sticky-col-header) {
			position: -webkit-sticky;
			position: sticky;
			top: 0;
			background-color: #f9fafb; /* gray-50 */
			z-index: 20; /* Inferior a .sticky-col-header */
		}

        .shift-cell {
            padding: 0.5rem 0.25rem;
            text-align: center;
            white-space: nowrap;
            font-size: 0.75rem;
            font-weight: 500;
            border-right: 1px solid #f3f4f6; /* gray-100 */
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .shift-cell:last-child {
            border-right: none;
        }
        .cell-selected {
            outline: 2px dashed #4f46e5; /* indigo-600 */
            outline-offset: -2px;
            background-color: #e0e7ff !important; /* indigo-100 */
        }
    
        .hidden-by-default {
            display: none !important;
        }
    
        /* ESTILOS ORIGINALES PARA BOTONES DE ACCI√ìN Y OTROS ELEMENTOS (MANTENIDOS) */
        .action-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border-radius: 0.375rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        }
        .action-button:hover {
            opacity: 0.9;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }
        .action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .action-button:hover .fa-sync-alt {
            animation: fa-spin 1.5s linear infinite;
        }
        @keyframes fa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .notes-textarea {
            min-height: 150px;
            flex-grow: 1;
        }
        .day-header-date { /* Estilo para el n√∫mero del d√≠a en la cabecera */
            display: block;
            font-weight: 600;
        }
        .day-header-weekday { /* Estilo para la letra del d√≠a de la semana en la cabecera */
            display: block;
            font-size: 0.7rem;
            color: #6b7280;
            font-weight: 400;
        }
    
        /* === INICIO: NUEVOS ESTILOS PARA LA BARRA DE NAVEGACI√ìN DEL CALENDARIO === */
        .schedule-navigation-bar {
            background-color: #ffffff;
            border-radius: 0.75rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            padding: 1.25rem; 
            margin-bottom: 1.5rem; 
        }
    
        /* View Toggle Buttons (Nuevos/Actualizados) */
        .view-toggle-button {
            padding: 0.75rem 1.5rem; 
            font-size: 0.875rem; 
            font-weight: 600; 
            border-radius: 0.5rem; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 0.625rem; 
            cursor: pointer;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05);
        }
        .view-toggle-button i {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .view-toggle-button.active {
            background-color: #4f46e5; 
            color: white;
            box-shadow: 0 4px 12px -1px rgba(79, 70, 229, 0.4), 0 2px 8px -1px rgba(79, 70, 229, 0.3);
            transform: translateY(-1px);
        }
        .view-toggle-button.active i {
            transform: scale(1.1);
        }
        .view-toggle-button:not(.active) {
            background-color: #e5e7eb; 
            color: #374151; 
            border: 1px solid #d1d5db; 
        }
        .view-toggle-button:not(.active):hover {
            background-color: #d1d5db; 
            border-color: #9ca3af; 
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 6px 12px -2px rgba(0,0,0,0.1), 0 3px 7px -3px rgba(0,0,0,0.08);
            color: #1f2937;
        }
        .view-toggle-button:not(.active):hover i {
            transform: scale(1.2) rotate(-5deg);
            color: #4f46e5;
        }
        .view-toggle-button:active:not(.active) {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 2px 4px -1px rgba(0,0,0,0.06), 0 1px 2px -1px rgba(0,0,0,0.04);
        }
    
        /* Month Tabs Container (Nuevos/Actualizados) */
        .month-tabs-container { /* Este es el ID que ya usas: #month-tabs-container */
            display: flex;
            flex-wrap: wrap; /* Permitir que los meses se envuelvan */
            gap: 0.5rem;    
            padding-top: 1rem; 
            justify-content: center; /* Meses centrados, incluso en m√∫ltiples l√≠neas */
            /* Ya no necesita overflow-x: auto ni ocultar scrollbars */
        }
    
        /* Individual Month Tabs (Nuevos/Actualizados) */
        .month-tab { /* Esta clase ya la usas para los botones de mes generados por JS */
            padding: 0.625rem 1rem; 
            font-size: 0.875rem; 
            font-weight: 500; 
            color: #374151; 
            background-color: #f9fafb; 
            border: 1px solid #d1d5db; 
            border-radius: 0.375rem; 
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            white-space: nowrap;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.03);
            margin-bottom: 0.5rem; /* Espacio cuando se envuelven */
        }
        .month-tab:hover:not(.active) {
            background-color: #e9e7ff;
            border-color: #a5b4fc;
            color: #4f46e5;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px -1px rgba(0,0,0,0.07), 0 2px 4px -1px rgba(0,0,0,0.04);
        }
        .month-tab.active {
            background-color: #4f46e5;
            color: white;
            border-color: #4338ca;
            font-weight: 600;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 10px -3px rgba(79, 70, 229, 0.35), 0 3px 5px -2px rgba(79, 70, 229, 0.25);
        }
         .month-tab:active:not(.active) {
            transform: translateY(-1px) scale(0.98);
        }
    
        /* Responsive Adjustments para la nueva barra de navegaci√≥n */
        @media (max-width: 767px) { /* md */
            .schedule-navigation-bar {
                padding: 1rem;
            }
            #view-mode-buttons-group { /* ID del div que contiene los botones de vista */
                margin-bottom: 0.75rem;
            }
            .view-toggle-button {
                padding: 0.6rem 1rem;
                font-size: 0.8rem;   
            }
            .view-toggle-button i {
                margin-right: 0.35rem; 
            }
            .month-tabs-container { /* ID #month-tabs-container */
                padding-top: 0.75rem; 
                gap: 0.4rem; 
            }
            .month-tab {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem;    
            }
        }
    
        @media (max-width: 480px) { /* sm o m√°s peque√±o */
            #view-mode-buttons-group { /* ID del div que contiene los botones de vista */
                 flex-direction: column;
                 align-items: stretch;
                 gap: 0.5rem;
            }
            #view-mode-buttons-group .view-toggle-button {
                width: 100%;
                justify-content: center;
                margin-left: 0 !important; /* Para anular el ml-3 del bot√≥n anual en pantallas peque√±as */
            }
            .month-tabs-container { /* ID #month-tabs-container */
                gap: 0.35rem; 
            }
            .month-tab {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
                margin-bottom: 0.35rem; 
            }
        }
        /* === FIN: NUEVOS ESTILOS PARA LA BARRA DE NAVEGACI√ìN DEL CALENDARIO === */
    
        .color-palette-popup {
            position: fixed;
            background-color: white;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
            padding: 0.75rem;
            z-index: 1050;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.375rem;
            width: auto;
            min-width: 260px;
        }
        .palette-color-swatch {
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.25rem;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s ease-in-out, border-color 0.1s;
        }
        .palette-color-swatch:hover {
            transform: scale(1.1);
            border-color: #4f46e5;
        }
        .legend-item-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }
        .legend-color-swatch {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
            border: 1px solid #9ca3af;
            cursor: pointer;
            transition: transform 0.1s;
            flex-shrink: 0;
        }
        .legend-color-swatch:hover {
            transform: scale(1.15);
        }
        .legend-time-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-left: 0.5rem;
        }
        .legend-time-inputs input[type="time"] {
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.25rem 0.375rem;
            font-size: 0.75rem;
            width: 75px;
        }
        .legend-item-flash .legend-color-swatch {
            animation: swatch-flash 0.7s ease-out;
        }
        .legend-item-flash .legend-time-inputs input {
            animation: input-flash 0.7s ease-out;
        }
        @keyframes swatch-flash {
            0%, 100% { transform: scale(1); box-shadow: none; }
            50% { transform: scale(1.15); box-shadow: 0 0 10px rgba(79, 70, 229, 0.6); }
        }
        @keyframes input-flash {
            0%, 100% { border-color: #d1d5db; }
            50% { border-color: #4f46e5;  box-shadow: 0 0 5px rgba(79, 70, 229, 0.4);}
        }
    
        #history-section, #notes-section, #legend-section { 
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 7px 20px -4px rgba(0,0,0,0.06), 0 4px 8px -3px rgba(0,0,0,0.04);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }
    
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.75rem;
            display: flex;
            align-items: center;
        }
        .section-title i {
            margin-right: 0.75rem;
            color: #4f46e5;
        }
        #legend-section .section-title { /* Si a√∫n usas #legend-section en alg√∫n modal, por ejemplo */
            flex-grow: 1;
        }
        #legend-section .flex-shrink-0 {
            margin-left: auto;
        }
    
        #change-history-list-container {
            flex-grow: 1;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            background-color: #f9fafb;
            min-height: 150px;
            max-height: 250px;
        }
        #change-history-list li {
            padding: 0.375rem 0.25rem;
            font-size: 0.8rem;
            color: #4b5563;
            border-bottom: 1px solid #f3f4f6;
        }
        #change-history-list li:last-child {
            border-bottom: none;
        }
        #change-history-list li .history-time {
            font-weight: 500;
            color: #1f2937;
            margin-right: 0.375rem;
        }
        #multiselect-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #374151;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            z-index: 100;
            gap: 0.5rem;
        }
        #multiselect-toolbar:not(.hidden-by-default) {
            display: flex;
        }
        #multiselect-toolbar.hidden-by-default {
             display: none !important;
        }
        #multiselect-toolbar button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 0.75rem;
            border: none;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #multiselect-toolbar button:hover {
            background-color: #4338ca;
        }
        #multiselect-toolbar button.other-selection {
            background-color: #6b7280;
        }
        #multiselect-toolbar button.other-selection:hover {
            background-color: #4b5563;
        }
    
        #help-icon-container i {
            transition: transform 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        #help-icon-container:hover i {
            transform: scale(1.2);
            color: #facc15; 
            text-shadow: 0 0 10px rgba(250, 204, 21, 0.7); 
        }
        #current-month-year-display {
            padding-right: 4rem; 
        }
        #help-icon-container {
            top: 50%; 
            right: 1rem; 
            transform: translateY(-50%); 
        }
        #tips-modal .modal-content {
    		max-width: 42rem;
    		background-color: #f9fafb;
    		border-radius: 0.75rem;
    		box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
    		padding: 1.5rem;
    		width: 90%;
    		max-height: 85vh;
    		overflow-y: auto;
    		display: flex;
    		flex-direction: column;
    		margin-bottom: 5vh;
        }
        #tips-modal h3 { font-family: 'Inter', sans-serif; }
        #tips-modal h4 { font-family: 'Inter', sans-serif; font-size: 1rem; margin-top: 0.75rem; }
        #tips-modal ul { margin-left: 1rem; }
        #tips-modal li { margin-bottom: 0.375rem; }
        #tips-modal code {
            background-color: #e0e7ff; color: #3730a3; padding: 0.125rem 0.375rem;
            border-radius: 0.25rem; font-size: 0.85em; font-family: 'Courier New', Courier, monospace;
        }
        .employee-name-cell {
            display: flex; justify-content: space-between;
            align-items: center; padding: 0.5rem 1rem;
        }
        .employee-name-display { cursor: grab; flex-grow: 1; }
        .employee-name-cell:hover .edit-icon, .employee-name-cell:hover .delete-employee-icon { opacity: 1; }
        .edit-icon, .delete-employee-icon {
            opacity: 0.3; margin-left: 8px; font-size: 0.9em; transition: opacity 0.2s; cursor: pointer;
        }
        .delete-employee-icon:hover { color: #ef4444; }
        .draggable-row.dragging { opacity: 0.4; background: #c7d2fe; }
        .drag-over-indicator { height: 3px; background-color: #4f46e5; margin: -1px 0; }
        .modal {
            position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.5);
            display: flex; align-items: flex-start; justify-content: center;
            z-index: 1000; padding: 1rem; overflow-y: auto; padding-top: 5vh;
        }
        .modal-content {
            background-color: white; padding: 2rem; border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            width: 100%; max-width: 28rem;
        }
        .unsaved-dot {
            display: inline-block; width: 8px; height: 8px; background-color: #ef4444;
            border-radius: 50%; margin-left: 0.5rem; vertical-align: middle;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .unsaved-dot.hidden-by-default { opacity: 0; transform: scale(0); }
        .add-employee-row-reformed { border-top: 1px dashed #d1d5db; }
        .add-employee-cell-reformed {
            padding: 0.75rem; text-align: left; position: -webkit-sticky; position: sticky;
            left: 0; background-color: #f9fafb; z-index: 10;
        }
        .add-employee-button-visual {
            display: inline-flex; align-items: center; gap: 0.6rem; padding: 0.55rem 0.9rem;
            font-size: 0.8rem; font-weight: 500; color: #374151; background-color: #f3f4f6;
            border: 1px solid #d1d5db; border-radius: 0.375rem; cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
        }
        .add-employee-button-visual:hover {
            background-color: #e5e7eb; border-color: #9ca3af; color: #1f2937;
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 4px 8px -1px rgba(0,0,0,0.07), 0 2px 4px -1px rgba(0,0,0,0.04);
        }
        .add-employee-button-visual:active {
            transform: translateY(0px) scale(0.99); box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }
        .add-employee-button-visual i {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); font-size: 0.85em;
        }
        .add-employee-button-visual:hover i {
            transform: rotate(135deg) scale(1.1); color: #4f46e5;
        }
        .add-employee-empty-cell-reformed {
            padding: 0.5rem 1rem; background-color: #f9fafb; border-right: 1px solid #f3f4f6; height: 54px;
        }
        .add-employee-empty-cell-reformed:last-child { border-right: none; }
        .footer-name {
            transition: opacity 0.5s ease-in-out, color 0.5s ease-in-out; cursor: pointer;
        }
        .footer-name.hidden-name { opacity: 0; color: #4f46e5; }
        .footer-name.visible-name { opacity: 1; color: inherit; }
    
        @keyframes button-shake { /* Tus animaciones de botones existentes */
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        #save-local-button:hover { animation: button-shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes icon-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
        #create-empty-csv-button:hover .fa-file-alt { animation: icon-pulse 0.6s ease-in-out; }
        @keyframes icon-jiggle { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(5deg); } 75% { transform: rotate(-5deg); } }
        #export-csv-button:hover .fa-file-csv { animation: icon-jiggle 0.4s ease-in-out; }
        @keyframes icon-download { 0% { transform: translateY(0); } 50% { transform: translateY(3px); } 100% { transform: translateY(0); } }
        #download-weekly-svg-button:hover .fa-file-pdf,
        #download-image-button:hover .fa-file-pdf { animation: icon-download 0.5s ease-in-out; }
        #export-month-calendar-button:hover .fa-calendar-plus::after {
            content: '+'; display: inline-block; animation: plus-grow 0.3s ease-out forwards; transform-origin: center;
        }
        @keyframes plus-grow { 0% { transform: scale(1); } 100% { transform: scale(1.3); } }
    
        .sr-only { /* Para accesibilidad, si lo usas */
            position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
            overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;
        }
    
        /* ESTILOS DE LA SECCI√ìN DE ESTAD√çSTICAS (MANTENIDOS) */
        .stats-section { 
            background-color: white; border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem; margin-bottom: 2rem;
        }
        .stats-section h2.section-main-title { font-size: 1.5rem; font-weight: 700; color: #1f2937; }
        .stats-section h3.chart-title { font-size: 1.125rem; font-weight: 600; color: #374151; margin-bottom: 0.75rem; }
        .table-header-controls {
            display: flex; flex-direction: column; align-items: flex-start; gap: 0.5rem;
            margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e5e7eb;
        }
        @media (min-width: 640px) { 
            .table-header-controls { flex-direction: row; align-items: center; justify-content: space-between; }
        }
        .table-wrapper { overflow-x: auto; }
        #stats-table-head th {
            background-color: #f9fafb; color: #374151; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.05em; padding: 0.75rem 1rem; text-align: left; white-space: nowrap;
        }
        #stats-table-head th i { margin-right: 0.375rem; }
        #tbody-idea1-expanded td {
            padding: 0.5rem 0.75rem; border-bottom: 1px solid #e5e7eb; font-size: 0.875rem;
            white-space: nowrap; text-align: center;
        }
        #tbody-idea1-expanded td.employee-name-cell {
            text-align: left; font-weight: 500; color: #1f2937; background-color: white !important;
        }
        #tbody-idea1-expanded tr:last-child td { border-bottom: none; }
        #tbody-idea1-expanded tr:hover { background-color: #f3f4f6; cursor: pointer; }
        #tbody-idea1-expanded tr:hover td.employee-name-cell { background-color: white !important; }
        .kpi-card {
            background-color: white; border-radius: 0.375rem; padding: 0.5rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); border: 1px solid #e5e7eb; text-align: center;
            display: flex; flex-direction: column; justify-content: center; min-height: 70px;
        }
        .kpi-value { font-size: 1.25rem; font-weight: 700; color: #111827; line-height: 1.2; }
        .kpi-label { font-size: 0.65rem; color: #6b7280; line-height: 1.1; }
        .individual-charts-container, .general-stats-content {
            border: 2px dashed #cbd5e1; padding: 1.5rem; border-radius: 0.5rem;
        }
        .chart-container {
            background-color: #f9fafb; padding: 0.75rem; border-radius: 0.375rem;
            border: 1px solid #e5e7eb; display: flex; flex-direction: column;
            position: relative; min-height: 280px;
        }
        .chart-canvas { max-width: 100%; width: 100% !important; height: auto !important; margin: auto; }
        #normalBarChartCanvas { max-height: 200px; }
        #donutChartCanvas { max-height: 180px; }
        #generalStackedBarCanvas, #generalGroupedBarCanvas { max-height: 280px; min-height: 200px; }
        @media (max-width: 767px) { 
            #generalStackedBarCanvas, #generalGroupedBarCanvas { max-height: 250px; }
            .chart-container { min-height: 200px; }
            /* Adaptaci√≥n m√≥vil de tablas de estad√≠sticas */
            #stats-table-head th { font-size: 0.7rem; padding: 0.5rem 0.4rem; white-space: normal; text-align: center; line-height: 1.1; }
            #stats-table-head th:first-child { text-align: left; padding-left: 0.5rem; min-width: 90px; }
            #tbody-idea1-expanded td { font-size: 0.75rem; padding: 0.4rem 0.3rem; line-height: 1.3; }
            #tbody-idea1-expanded td.employee-name-cell {
                font-size: 0.75rem; padding-left: 0.5rem; max-width: 90px;
                overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            }
            /* Adaptaci√≥n m√≥vil de la barra de turnos multiselecci√≥n */
            #multiselect-toolbar {
                flex-wrap: wrap; justify-content: center; width: calc(100% - 40px); max-width: 400px;
                padding-top: 0.5rem; padding-bottom: 0.5rem; gap: 0.375rem;
            }
            #multiselect-toolbar button {
                padding: 0.4rem 0.6rem; font-size: 0.8rem; margin-bottom: 0.25rem; 
            }
        }
		
		@media (max-width: 639px) { /* sm breakpoint */
			#legend-colors-modal-footer {
				flex-direction: column; /* Apila los botones verticalmente */
				align-items: stretch; /* Hace que los botones se estiren al ancho completo */
				justify-content: center; /* Centra el bloque de botones si es necesario */
			}

			#legend-colors-modal-footer .action-button {
				width: 100%; /* Cada bot√≥n ocupa el ancho completo */
				margin-left: 0 !important; /* Anula cualquier margen izquierdo de space-x */
				margin-right: 0 !important; /* Anula cualquier margen derecho */
				/* Considera reducir un poco el padding vertical y el tama√±o de fuente si es necesario */
				padding-top: 0.5rem;    /* Ejemplo: py-2 */
				padding-bottom: 0.5rem; /* Ejemplo: py-2 */
				font-size: 0.8rem;      /* Ejemplo: text-xs o sm */
			}

			/* Si los iconos hacen que el texto se envuelva de forma extra√±a, puedes ocultarlos o reducirlos */
			#legend-colors-modal-footer .action-button i {
				/* margin-right: 0.25rem; /* Reduce el espacio del icono */
				/* font-size: 0.9em;      /* Reduce el tama√±o del icono */
				/* display: none;         /* Oculta el icono en m√≥viles si es muy problem√°tico */
			}
		}

        /* Ajustes espec√≠ficos para la Vista Anual en M√≥vil (si se usa la clase en body) */
        body.annual-view-active #schedule-table .shift-cell { font-size: 0.6rem; padding: 0.3rem 0.1rem; min-width: 28px; }
        body.annual-view-active #schedule-table-head .day-header-date,
        body.annual-view-active #schedule-table-head .day-header-weekday { font-size: 0.55rem; }
        body.annual-view-active #schedule-table-head .sticky-col-header,
        body.annual-view-active #schedule-table .employee-name-cell { font-size: 0.7rem; }
        body.annual-view-active #schedule-table .employee-name-cell .employee-name-display { max-width: 70px; }
    
        .mini-calendar-heatmap {
            display: grid; grid-template-columns: repeat(7, 1fr); gap: 3px;
            max-width: 220px; margin: 0.25rem auto 0;
        }
        .calendar-header-day, .calendar-day {
            width: 28px; height: 28px; font-size: 0.7rem; display: flex;
            align-items: center; justify-content: center; border-radius: 3px;
        }
        .calendar-header-day { font-weight: 600; color: #4b5563; }
        .calendar-day.empty { background-color: transparent; border: none; }
        .month-dropdown-container { position: relative; display: inline-block; }
        .month-dropdown-button {
            background-color: white; color: #374151; padding: 0.5rem 1rem; font-size: 0.875rem;
            font-weight: 500; border: 1px solid #d1d5db; border-radius: 0.375rem;
            cursor: pointer; display: inline-flex; align-items: center; transition: background-color 0.2s;
        }
        .month-dropdown-button:hover { background-color: #f9fafb; }
        .month-dropdown-button i { margin-left: 0.5rem; transition: transform 0.2s; }
        .month-dropdown-content {
            display: none; position: absolute; background-color: white; min-width: 180px;
            box-shadow: 0 8px 16px 0 rgba(0,0,0,0.1); z-index: 10; border-radius: 0.375rem;
            border: 1px solid #e5e7eb; max-height: 300px; overflow-y: auto; right: 0;
        }
        .month-dropdown-content.show { display: block; }
        .month-dropdown-content a {
            color: #374151; padding: 0.75rem 1rem; text-decoration: none; display: block; font-size: 0.875rem;
        }
        .month-dropdown-content a:hover { background-color: #f3f4f6; }
        .month-dropdown-content a.active { background-color: #4f46e5; color: white; }
        .details-header-controls { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; }
        .close-details-button {
            background-color: #ef4444; color: white; padding: 0.625rem 1rem; border-radius: 0.375rem;
            font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .close-details-button:hover { background-color: #dc2626; transform: translateY(-1px); }
        .close-details-button:active { transform: translateY(0px); }
        .close-details-button i { margin-right: 0.375rem; }
        .general-stats-content { max-width: 100rem; margin-left: auto; margin-right: auto; }
    
        /* Estilos para botones de modales y modales de leyenda/normas */
        .action-button-modal-trigger {
            padding: 0.375rem 0.75rem; font-size: 0.75rem; font-weight: 500;
            border-radius: 0.375rem; transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px 0 rgba(0,0,0,0.05); display: inline-flex;
            align-items: center; gap: 0.3rem;
        }
        .action-button-modal-trigger:hover {
            opacity: 0.9;
            box-shadow: 0 2px 4px -1px rgba(0,0,0,0.08), 0 1px 2px -1px rgba(0,0,0,0.04);
        }
        .action-button-modal-trigger:disabled { opacity: 0.5; cursor: not-allowed; }
        #legend-colors-modal-body .section-title { font-size: 1.125rem; margin-bottom: 1rem; }
    
        #rules-modal-body .rule-block {
            padding: 1rem; background-color: #f9fafb; border: 1px solid #e5e7eb;
            border-radius: 0.5rem; margin-bottom: 1.5rem;
        }
        #rules-modal-body .rule-title {
            font-size: 1.125rem; font-weight: 600; color: #1f2937; margin-bottom: 0.75rem;
            display: flex; align-items: center;
        }
        #rules-modal-body .rule-title .rule-status-indicator {
            width: 10px; height: 10px; border-radius: 50%; margin-left: 0.75rem;
            background-color: #d1d5db; 
        }
        #rules-modal-body .rule-title .rule-status-indicator.active { background-color: #10b981; }
        #rules-modal-body .rule-config-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem;
        }
        #rules-modal-body .rule-config-grid label {
            font-size: 0.875rem; font-weight: 500; color: #374151; display: block; margin-bottom: 0.25rem;
        }
        #rules-modal-body .rule-config-grid input[type="number"] {
            width: 100%; padding: 0.5rem; border: 1px solid #d1d5db;
            border-radius: 0.375rem; font-size: 0.875rem;
        }
		#legend-colors-modal-footer {
			display: flex;
			flex-wrap: wrap; /* Permite que los botones pasen a la siguiente l√≠nea */
			justify-content: flex-end; /* Alineaci√≥n original a la derecha */
			gap: 0.75rem; /* Espacio entre botones (equivalente a space-x-3) */
		}
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 24px;
        }
        .slider:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #4f46e5; }
        input:focus + .slider { box-shadow: 0 0 1px #4f46e5; }
        input:checked + .slider:before { transform: translateX(20px); }
    
        .day-rule-violation .day-number-wrapper { 
            border: 2px solid #ef4444; border-radius: 50%; padding: 1px 3px;
            display: inline-block; line-height: 1; color: #ef4444; background-color: #fee2e2;
        }

        .consecutive-workday-violation-cell {
            /* Opci√≥n 1: Fondo distintivo */
            /* background-color: rgba(255, 235, 238, 0.8) !important; /* Rosa muy claro, con !important si es necesario */
            /* border: 1px dashed #e53e3e !important; /* Borde rojo discontinuo */
        
            /* Opci√≥n 2: Solo bordes para un "rect√°ngulo" */
            /* Los bordes espec√≠ficos se aplicar√°n con JS, pero aqu√≠ puedes definir el color/estilo base */
             /* border-color: #e53e3e !important; /* Rojo */
             /* border-style: solid !important; */
        
            /* Opci√≥n 3: Una barra superior e inferior */
            border-top: 3px solid #ef4444 !important; /* Tailwind red-500 */
            border-bottom: 3px solid #ef4444 !important; /* Tailwind red-500 */
            /* Para que la barra no se coma el contenido, ajusta el padding o la altura de la celda si es necesario */
        }
        
        /* Para la primera celda de la secuencia de violaci√≥n (barra completa) */
        .consecutive-workday-violation-cell.is-first-in-sequence {
            border-left: 3px solid #ef4444 !important;
        }
        
        /* Para la √∫ltima celda de la secuencia de violaci√≥n (barra completa) */
        .consecutive-workday-violation-cell.is-last-in-sequence {
            border-right: 3px solid #ef4444 !important;
        }

        
        @keyframes palpitar {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .corazon-palpitando {
            animation: palpitar 0.5s ease-in-out;
        }
		
		#footer-heart {
			-webkit-user-select: none; /* Safari */
			-moz-user-select: none;    /* Firefox */
			-ms-user-select: none;     /* IE10+/Edge */
			user-select: none;         /* Est√°ndar */
			cursor: pointer; /* Para mantener la indicaci√≥n de que es clickeable */
        

    </style>
</head>

<body class="p-4 md:p-8">

    <div class="container mx-auto max-w-full">
        <header class="mb-10 text-center">
            <div id="logo-container" class="flex justify-center mb-3">
                </div>
            <h1 id="main-title-text" class="text-4xl md:text-5xl font-bold text-gray-800 tracking-tight inline-block">Gestor de Horarios Laborales</h1>
        </header>

        <section id="controls-section" class="mb-8 p-6 bg-white rounded-xl shadow-xl">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 items-end">
                <div>
                    <label for="csv-file-input" class="block text-sm font-medium text-gray-700 mb-1">Importar Horario (CSV):</label>
                    <input type="file" id="csv-file-input" accept=".csv" class="w-full text-sm text-gray-500
                        file:mr-4 file:py-2.5 file:px-4 file:cursor-pointer
                        file:rounded-lg file:border-0
                        file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700
                        hover:file:bg-indigo-100 transition-colors
                    "/>
                    <button id="create-empty-csv-button" class="action-button w-full mt-2 bg-sky-600 text-white hover:bg-sky-700 focus:ring-2 focus:ring-sky-500 focus:ring-offset-2">
                        <i class="fas fa-file-alt mr-2"></i>Nuevo Horario Vac√≠o
                    </button>
                </div>
                <div>
                    <label for="year-input" class="block text-sm font-medium text-gray-700 mb-1">A√±o del Horario:</label>
                    <input type="number" id="year-input" value="2026" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                <div class="lg:col-start-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                    <div class="flex items-center gap-2 flex-1">
                        <button id="save-local-button" title="Guarda el horario actual, las notas y la configuraci√≥n de colores en el almacenamiento local de tu navegador." class="action-button flex-1 bg-green-600 text-white hover:bg-green-700 focus:ring-2 focus:ring-green-500 focus:ring-offset-2" disabled>
                            <i class="fas fa-save"></i>Guardar Local
                        </button>
                        <i id="save-local-help-icon" class="fas fa-question-circle text-gray-500 hover:text-indigo-600 cursor-pointer text-xl" title="Ayuda sobre Guardado Local"></i>
                    </div>
                    <button id="export-csv-button" class="action-button flex-1 bg-blue-600 text-white hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-csv"></i>Exportar CSV
                    </button>
                </div>
            </div>
        
            <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-4 items-end mt-4">
                <div class="md:col-span-3 flex flex-col sm:flex-row gap-3 justify-self-start md:justify-self-end mt-4 md:mt-0 w-full">
                    <button id="export-month-calendar-button" class="action-button flex-1 bg-orange-500 text-white hover:bg-orange-600 focus:ring-2 focus:ring-orange-400 focus:ring-offset-2" disabled>
                        <i class="fas fa-calendar-plus mr-2"></i>Exportar Mes a Calendar
                    </button>
                    <button id="download-weekly-svg-button" class="action-button flex-1 bg-teal-600 text-white hover:bg-teal-700 focus:ring-2 focus:ring-teal-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Semanal PDF
                    </button>
                    <button id="download-image-button" class="action-button flex-1 bg-purple-600 text-white hover:bg-purple-700 focus:ring-2 focus:ring-purple-500 focus:ring-offset-2" disabled>
                        <i class="fas fa-file-pdf mr-2"></i>Descargar Calendario PDF
                    </button>
                </div>
            </div>
        
            <div class="mt-4 pt-4 border-t border-gray-200 flex flex-col sm:flex-row items-center justify-end gap-4">
                <label for="autosave-toggle" class="flex items-center cursor-pointer">
                    <span class="mr-3 text-sm font-medium text-gray-700">Autoguardado local (30s):</span>
                    <div class="relative">
                        <input type="checkbox" id="autosave-toggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-indigo-500 peer-checked:bg-indigo-600 transition-colors"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-transform peer-checked:translate-x-full"></div>
                    </div>
                </label>
            </div>
        </section>

        <section id="welcome-message" class="my-8 p-8 bg-indigo-50 text-indigo-700 rounded-xl shadow-lg text-center">
            <i class="fas fa-info-circle fa-2x mb-3"></i>
            <p class="text-lg">Bienvenido/a al Gestor de Horarios.</p>
            <p class="text-sm">Por favor, importa un archivo CSV, aplica una plantilla vac√≠a o carga datos guardados localmente para comenzar.</p>
        </section>

        <main id="schedule-display-section" class="hidden-by-default">
        
            <div class="schedule-navigation-bar"> 
                <div id="view-mode-buttons-group"
                     class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-3 w-full">
                
                    <div class="flex flex-row w-full gap-2 sm:contents">
                        <button id="open-legend-colors-modal-button-nav"
                                class="view-toggle-button bg-teal-500 hover:bg-teal-600 text-white !justify-center flex-1 sm:flex-none sm:w-auto sm:order-1"
                                title="Abrir Leyenda, Colores y Horarios de Turno">
                            <i class="fas fa-palette"></i>
                            <span>Personalizaci√≥n</span>
                        </button>
                        <button id="open-rules-modal-button-nav"
                                class="view-toggle-button bg-sky-500 hover:bg-sky-600 text-white !justify-center flex-1 sm:flex-none sm:w-auto sm:order-3"
                                title="Abrir Configuraci√≥n de Normas">
                            <i class="fas fa-gavel"></i>
                            <span>Normas</span>
                        </button>
                    </div>
                
                    <div class="flex justify-center w-full gap-2 sm:gap-3 sm:order-2 sm:w-auto">
                        <button id="view-monthly-button" class="view-toggle-button active flex-1 sm:flex-initial">
                            <i class="fas fa-calendar-day"></i>
                            <span>Vista Mensual</span>
                        </button>
                        <button id="view-annual-button" class="view-toggle-button flex-1 sm:flex-initial">
                            <i class="fas fa-calendar-alt"></i>
                            <span>Vista Anual</span>
                        </button>
                    </div>
                </div>
        
                <div id="month-tabs-wrapper" class="min-w-0"> 
                    <div id="month-tabs-container" class="month-tabs-container">
                        <!-- Las pesta√±as de mes (ENE, FEB, etc.) ser√°n generadas aqu√≠ 
                             por tu funci√≥n JavaScript populateMonthTabs(). 
                             No necesitas copiar los botones de mes del prototipo aqu√≠. -->
                    </div>
                </div>
            </div>
            <section id="schedule-table-section" class="bg-white rounded-xl shadow-xl">
                <h2 id="current-month-year-display" class="text-2xl font-bold text-gray-800 p-5 border-b border-gray-200 bg-gray-50 rounded-t-xl relative">
                    <span id="current-month-year-text">Horario para [Mes A√±o]</span>
                    <span id="unsaved-indicator-table" class="unsaved-dot hidden-by-default" title="Hay cambios sin guardar"></span>
                    <span id="help-icon-container" class="absolute top-0 right-0 p-3 cursor-pointer" title="Mostrar Consejos √ötiles">
                        <i class="fas fa-lightbulb text-gray-500 text-2xl"></i>
                    </span>
                </h2>
                <div class="table-container">
                    <table id="schedule-table" class="min-w-full divide-y divide-gray-200">
                        <thead id="schedule-table-head" class="bg-gray-50 sticky-header"></thead>
                        <tbody id="schedule-table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                 <div id="no-data-message" class="p-8 text-center text-gray-500 text-lg hidden-by-default">
                    <i class="fas fa-folder-open fa-2x mb-3 text-gray-400"></i><br>
                    No hay datos de horario para mostrar. Importa un archivo CSV, aplica una plantilla vac√≠a o a√±ade empleados.
                </div>
            </section>
        
            <div class="mt-10 grid grid-cols-1 lg:grid-cols-4 gap-8">
                <section id="statistics-section" class="lg:col-span-4">
                    <section class="stats-section" id="idea1-table-improved-expanded">
        					<div class="table-header-controls">
        						<h2 class="text-xl font-semibold section-main-title">Tabla Comparativa de Empleados</h2>
        						<div class="flex items-center gap-3"> 
        							<div class="month-dropdown-container" id="main-month-dropdown-container">
        								<button id="month-dropdown-btn" class="month-dropdown-button">
        									<span id="selected-month-text">A√±o Completo</span>
        									<i class="fas fa-chevron-down text-xs"></i>
        								</button>
        								<div id="month-dropdown-options" class="month-dropdown-content">
        								</div>
        							</div>
        							<button id="export-stats-to-pdf-button" class="action-button bg-blue-500 text-white hover:bg-blue-700">
        								<i class="fas fa-file-pdf mr-2"></i>Exportar Estad√≠sticas PDF
        							</button>
        						</div>
        					</div>
                            <div class="table-wrapper">
                                <table class="min-w-full">
                                    <thead id="stats-table-head">
                                    </thead>
                                    <tbody id="tbody-idea1-expanded">
                                    </tbody>
                                </table>
                            </div>
                             <div class="mt-4 text-sm text-gray-600">
                                <span id="pagination-info"></span> 
                            </div>
                            <div class="mt-8 text-center">
                                <button id="show-general-stats-btn" class="px-8 py-3 bg-teal-600 text-white font-semibold rounded-lg shadow-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 transition-all duration-150 ease-in-out transform hover:scale-105">
                                    <i class="fas fa-chart-bar mr-2"></i>Ver Estad√≠sticas Generales de la Plantilla
                                </button>
                            </div>
                        </section>
        
                        <section class="stats-section hidden" id="individual-employee-charts-section">
                            <div class="flex flex-wrap justify-between items-center mb-1">
        						<h2 class="!text-xl !font-semibold !mb-0 !pb-0 !border-0 section-main-title w-full sm:w-auto mb-2 sm:mb-0">
        							Detalles para <span id="selected-month-year-display-details" class="text-gray-700"></span>:
        							<span id="details-employee-name-placeholder" class="text-indigo-600 font-semibold">
        							</span>
        						</h2>
                                <div class="details-header-controls w-full sm:w-auto justify-end">
                                     <div class="month-dropdown-container" id="details-month-dropdown-container">
                                        <button id="details-month-dropdown-btn" class="month-dropdown-button text-sm">
                                            <span id="details-selected-month-text">A√±o Completo</span>
                                            <i class="fas fa-chevron-down text-xs"></i>
                                        </button>
                                        <div id="details-month-dropdown-options" class="month-dropdown-content">
                                        </div>
                                    </div>
                                    <button id="close-individual-charts" class="close-details-button">
                                        <i class="fas fa-times"></i>Cerrar
                                    </button>
                                </div>
                            </div>
        
        					<div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6" id="donut-calendar-grid">
        						<div class="chart-container" id="donut-chart-wrapper">
        							<h3 class="chart-title">Proporci√≥n Total de Turnos</h3>
        							<canvas id="donutChartCanvas" class="chart-canvas donut-chart-canvas"></canvas>
        							<div id="donutChartMessage" class="text-center text-gray-500 text-sm mt-2"></div>
        						</div>
        
        						<div class="chart-container" id="calendar-heatmap-wrapper">
        							<h3 class="chart-title" id="calendar-heatmap-title">Calendario</h3>
        							<div id="mini-calendar-heatmap-container" class="mini-calendar-heatmap">
        							</div>
        						</div>
        					</div>
        
        					<div class="mt-6" id="kpi-section-wrapper"> <h3 class="chart-title mb-3">Resumen Clave Detallado</h3>
        						<div id="kpi-summary-card-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2 md:gap-3">
                                </div>
                            </div>
                        </section>
        
                        <section class="stats-section hidden" id="general-plantilla-stats-section">
        					<div class="flex flex-wrap justify-between items-center mb-6 pb-3 border-b border-gray-200">
        						<h2 class="!text-xl md:!text-2xl !font-semibold !mb-0 !pb-0 !border-0 text-indigo-700 section-main-title w-full sm:w-auto mb-2 sm:mb-0">
        							<i class="fas fa-users mr-2"></i>Estad√≠sticas Generales de la Plantilla
        						</h2>
        						<div class="details-header-controls w-full sm:w-auto justify-end flex items-center gap-3"> <div class="month-dropdown-container" id="general-stats-month-dropdown-container">
        								<button id="general-stats-month-dropdown-btn" class="month-dropdown-button text-sm"> 
        									<span id="general-stats-selected-month-text">A√±o Completo</span> 
        									<i class="fas fa-chevron-down text-xs"></i>
        								</button>
        								<div id="general-stats-month-dropdown-options" class="month-dropdown-content"> 
        								</div>
        							</div>
        							<button id="close-general-stats-btn" class="close-details-button"> 
        								<i class="fas fa-times"></i>Cerrar
        							</button>
        						</div>
        					</div>
        
                            <div class="general-stats-content grid grid-cols-1 md:grid-cols-2 gap-8">
                                <div class="chart-container">
                                    <h3 class="chart-title">Composici√≥n de Turnos por Empleado (Barras Apiladas)</h3>
                                    <canvas id="generalStackedBarCanvas"></canvas>
                                </div>
                                <div class="chart-container">
                                    <h3 class="chart-title">D√≠as Trabajados vs. FDS Libres por Empleado</h3>
                                    <canvas id="generalGroupedBarCanvas"></canvas>
                                </div>
                            </div>
                        </section>
                </section> 
        
                <div class="lg:col-span-4 grid grid-cols-1 lg:grid-cols-2 gap-8"> 
                    <section id="history-section" class="lg:col-span-1">
                        <div class="flex justify-between items-center mb-3 border-b border-gray-200 pb-3">
                            <h3 class="section-title !mb-0 !border-b-0 !pb-0 flex-grow">
                                <i class="fas fa-history"></i>Historial de Cambios
                            </h3>
                            <div class="flex-shrink-0">
                                <button id="undo-button" title="Deshacer (Ctrl+Z)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5 mr-2" disabled>
                                    <i class="fas fa-undo"></i>
                                </button>
                                <button id="redo-button" title="Rehacer (Ctrl+Y)" class="action-button bg-gray-200 text-gray-700 hover:bg-gray-300 focus:ring-gray-400 text-xs px-3 py-1.5" disabled>
                                    <i class="fas fa-redo"></i>
                                </button>
                            </div>
                        </div>
                        <div id="change-history-list-container">
                            <ul id="change-history-list">
                                <li class="text-center text-gray-400">No hay cambios recientes.</li>
                            </ul>
                        </div>
                    </section>
        
                    <section id="notes-section" class="lg:col-span-1">
                        <h3 class="section-title"><i class="fas fa-pencil-alt"></i>Notas Generales</h3>
                        <textarea id="general-notes" class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 text-sm notes-textarea" placeholder="A√±ade comentarios o recordatorios aqu√≠..."></textarea>
                    </section>
                </div> 
            </div> 
        </main>

        <footer class="mt-16 text-center text-sm text-gray-500 relative pb-4 md:pb-2 px-4 md:px-2">
            <p id="footer-text" class="mb-2 md:mb-0">Gestor de Horarios. Creado por <span id="creator-name" class="footer-name">Daniel Fern√°ndez</span> con <i id="footer-heart" class="fas fa-heart text-red-500 footer-name"></i>.</p>
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mt-3">
                <a id="download-test-csv-link"
                   href="https://drive.usercontent.google.com/u/0/uc?id=1tgKrFfdCjyLj7ARzUhXybqyrtt15liYx&export=download" download="csv_prueba.csv"
                   title="Descargar CSV de prueba"
                   class="inline-block px-2 py-1 bg-gray-200 text-gray-600 hover:bg-gray-300 text-xs rounded-md shadow-sm transition-colors no-underline">
                    Prueba CSV
                </a>
                <button id="clear-local-storage-button"
                        title="Borrar todos los datos guardados localmente por esta aplicaci√≥n."
                        class="action-button bg-gray-400 text-white hover:bg-gray-700 focus:ring-2 focus:ring-red-500 focus:ring-offset-2 text-xs px-3 py-1.5">
                    <i class="fas fa-trash-alt mr-1"></i>Borrar Datos Locales
                </button>
            </div>
        </footer>
    </div>

    <div id="toast-container" class="fixed bottom-6 right-6 space-y-3 z-50"></div>
    <div id="color-palette-popup-container"></div>
    <div id="multiselect-toolbar" class="hidden-by-default"></div>

    <div id="add-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">A√±adir Nuevo Empleado</h3>
                <div>
                    <input type="text" id="modal-employee-name-input" placeholder="Nombre del empleado" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-add-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-add-employee" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">A√±adir</button>
                </div>
            </div>
        </div>
    </div>
    <div id="delete-employee-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-red-600 mb-2">¬°Atenci√≥n!</h3>
                <p class="text-gray-700 mb-4">Est√°s a punto de eliminar al empleado <strong id="employee-name-to-delete" class="font-semibold"></strong> y todos sus datos de horario.</p>
                <p class="text-sm text-gray-500 mb-1">Esta acci√≥n es permanente.</p>
                <p id="delete-countdown-message" class="text-red-500 font-semibold mb-4"></p>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-delete-employee" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-delete-employee" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2" disabled>Eliminar</button>
                </div>
            </div>
        </div>
    </div>
    <div id="filename-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="filename-modal-title" class="text-xl font-bold text-gray-900 mb-2">Nombre del Archivo</h3>
            <p id="filename-modal-description" class="text-sm text-gray-600 mb-4"></p>
            <div>
                <input type="text" id="modal-filename-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="nombre_del_archivo">
                <p class="text-xs text-gray-500 mt-1">No incluyas la extensi√≥n (ej: .csv o .pdf).</p>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-filename" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-filename" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Aceptar</button>
            </div>
        </div>
    </div>
    <div id="export-calendar-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-900 mb-4">Exportar Mes a Calendar</h3>
            <div class="mb-4">
                <label for="modal-calendar-employee-select" class="block text-sm font-medium text-gray-700 mb-1">Selecciona Empleado:</label>
                <select id="modal-calendar-employee-select" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </select>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-export-calendar" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-export-calendar" class="action-button bg-orange-500 text-white hover:bg-orange-600 px-4 py-2">Exportar</button>
            </div>
        </div>
    </div>
    <div id="tips-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-lg bg-gray-50 p-6 rounded-lg shadow-xl"> <div class="flex justify-between items-center mb-6 pb-3 border-b border-gray-300">
                <h3 class="text-2xl font-bold text-indigo-700"><i class="fas fa-lightbulb text-yellow-400 mr-3"></i>Consejos √ötiles</h3>
                <button id="close-tips-modal" class="text-gray-500 hover:text-gray-800 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>

            <div class="space-y-4 text-gray-700 text-sm">
                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar/Deseleccionar Celdas (Clic):</h4>
                    <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Usa <code>Ctrl/Cmd + Clic</code>.</li>
                        <li><strong>M√≥vil:</strong> Realiza una pulsaci√≥n sobre la celda.</li>
                        <li><strong>Seleccionar Rango (PC/Mac):</strong> Haz clic en la celda de inicio, luego mant√©n presionada la tecla <code>Shift</code> y haz clic en la celda final.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Seleccionar M√∫ltiples Celdas (Arrastrando):</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>PC/Mac:</strong> Haz clic en una celda y, sin soltar, arrastra el cursor para seleccionar un bloque.</li>
                        <li><strong>M√≥vil:</strong> Toca una celda para seleccionarla, mant√©n pulsado y arrastra el dedo para expandir la selecci√≥n a celdas adyacentes.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Reordenar Empleados:</h4>
                    <p class="pl-4">Arrastra y suelta el nombre del empleado en la tabla para cambiar su posici√≥n.</p>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Editar Texto en Celdas:</h4>
                     <ul class="list-disc list-inside pl-4 space-y-1">
                        <li><strong>Nombres de Empleado:</strong> Doble clic (PC/Mac) o pulsaci√≥n larga (M√≥vil) sobre el nombre.</li>
                        <li><strong>Turnos Personalizados:</strong> Doble clic (PC/Mac) o pulsaci√≥n larga (M√≥vil) sobre una celda que ya contenga texto personalizado (solo sirve si el turno es "Otro"). Si el texto contiene una coma (,) no se guardar√°.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="font-semibold text-indigo-600 mb-1">Barra de Acciones R√°pida:</h4>
                    <p class="pl-4">Tras seleccionar una o m√°s celdas, aparecer√° una barra de acciones en la parte inferior de la pantalla. √ösala para asignar r√°pidamente turnos est√°ndar (M, T, N, L, V, B) o para limpiar la celda (bot√≥n "Otro", que asigna un valor vac√≠o, permitiendo luego escribir texto personalizado si se desea).</p>
                </div>
            </div>

            <div class="mt-8 text-right">
                <button id="ok-tips-modal" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-6 py-2 rounded-lg">
                    Entendido
                </button>
            </div>
        </div>
    </div>
    <div id="custom-event-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 id="custom-event-modal-title" class="text-xl font-bold text-gray-900 mb-4">Editar Evento</h3>
            <div>
                <input type="text" id="modal-custom-event-input" class="w-full p-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm" placeholder="Introduce evento o texto">
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-custom-event" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-custom-event" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Guardar</button>
            </div>
        </div>
    </div>
    <div id="confirm-load-csv-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <h3 class="text-xl font-bold text-gray-900 mb-2">Confirmar Carga de Nuevo Horario</h3>
            <p id="confirm-load-csv-message" class="text-sm text-gray-600 mb-4">Ya hay un horario cargado. Si cargas un nuevo archivo CSV, los cambios no guardados se perder√°n. ¬øDeseas continuar?</p>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-load-csv" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                <button id="modal-confirm-load-csv" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2">Cargar Nuevo</button>
            </div>
        </div>
    </div>
    <div id="save-local-help-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-md"> <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900">Informaci√≥n sobre Guardado Local</h3>
                <button id="close-save-local-help-modal-icon" class="text-gray-500 hover:text-gray-800">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>
            <div class="text-sm text-gray-700 space-y-3">
                <p>La funci√≥n 'Guardar Local' almacena el estado actual de tu horario (incluyendo todos los turnos, empleados, las normas, el nombre del archivo CSV importado originalmente (si aplica), las notas y las configuraciones de colores) directamente en el almacenamiento de tu navegador web.</p>
                <p>Esto te permite cerrar la aplicaci√≥n y, al volver a abrirla en el mismo navegador y ordenador, cargar tus datos guardados para continuar tu trabajo.</p>
                <p class="font-semibold text-indigo-700">Importante: Esta acci√≥n <strong class="text-red-600">NO modifica ni sobrescribe el archivo CSV original</strong> que pudiste haber importado desde tu ordenador. Los navegadores web, por razones de seguridad, no permiten que las p√°ginas web editen archivos directamente en tu disco duro.</p>
                <p>Para obtener una copia de tu horario actual como un archivo CSV en tu ordenador (para guardarlo o compartirlo), debes usar la funci√≥n '<strong class="text-blue-600">Exportar CSV</strong>'. Esto descargar√° un nuevo archivo con los datos m√°s recientes.</p>
            </div>
            <div class="mt-6 text-right">
                <button id="close-save-local-help-modal-button" class="action-button bg-indigo-600 text-white hover:bg-indigo-700 px-4 py-2">Entendido</button>
            </div>
        </div>
    </div>
	<div id="filename-modal-stats-pdf" class="modal hidden-by-default">
		<div class="modal-content">
			<h3 id="filename-modal-title-stats-pdf" class="text-lg font-semibold mb-3">Nombre del Archivo PDF</h3>
			<input type="text" id="modal-filename-input-stats-pdf" class="w-full p-2 border border-gray-300 rounded-md mb-4" placeholder="nombre_del_archivo_pdf">
			<p id="filename-modal-extension-stats-pdf" class="text-xs text-gray-500 mb-3">Extensi√≥n: .pdf</p>
			<div class="flex justify-end gap-3 mt-6">
				<button id="modal-cancel-filename-stats-pdf" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
				<button id="modal-confirm-filename-stats-pdf" class="action-button bg-sky-600 text-white hover:bg-sky-700 px-4 py-2">Aceptar</button>
			</div>
		</div>
	</div>
	
    <div id="legend-colors-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-3xl">
            <div class="flex justify-between items-center mb-6 pb-3 border-b border-gray-300">
                <h3 class="text-xl font-bold text-gray-900"><i class="fas fa-palette mr-2 text-teal-500"></i>Leyenda, Colores y Horarios de Turno</h3>
                <button id="close-legend-colors-modal-button" class="text-gray-500 hover:text-gray-800 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>
            <div id="legend-colors-modal-body">
                <div id="legend-items-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 text-sm">
                    <!-- El contenido de la leyenda (items de colores y tiempos) 
                         es generado din√°micamente por JavaScript mediante la funci√≥n updateLegend() 
                         y se inserta aqu√≠. En el HTML est√°tico, este div est√° vac√≠o inicialmente. -->
                </div>
            </div>
            <div id="legend-colors-modal-footer" class="mt-6 pt-4 border-t border-gray-200 flex justify-end"> 
                <!-- La clase 'space-x-3' fue eliminada aqu√≠ como parte de la gu√≠a anterior, 
                     ya que el espaciado ahora se maneja con 'gap' en el CSS de #legend-colors-modal-footer -->
                <button id="modal-apply-colors-button" class="action-button bg-indigo-500 text-white hover:bg-indigo-600 focus:ring-indigo-400 px-4 py-2" disabled>
                    <i class="fas fa-check mr-2"></i>Aplicar Cambios
                </button>
                <button id="modal-reset-colors-button" class="action-button bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-400 px-4 py-2" disabled>
                    <i class="fas fa-undo mr-2"></i>Restaurar
                </button>
                <button id="modal-ok-legend-colors-button" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">
                    Cerrar
                </button>
            </div>
        </div>
    </div>
    
    <div id="rules-modal" class="modal hidden-by-default">
        <div class="modal-content max-w-2xl">
            <div class="flex justify-between items-center mb-6 pb-3 border-b border-gray-300">
                <h3 class="text-xl font-bold text-gray-900"><i class="fas fa-gavel mr-2 text-sky-500"></i>Configuraci√≥n de Normas del Horario</h3>
                <button id="close-rules-modal-button" class="text-gray-500 hover:text-gray-800 transition-colors">
                    <i class="fas fa-times fa-lg"></i>
                </button>
            </div>
            
            <div id="rules-modal-body" class="space-y-6">
                <div class="rule-block border p-4 rounded-lg bg-white shadow">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-lg font-semibold text-gray-800">Personas por Turno</h4>
                        <label for="persons-per-shift-enabled-toggle" class="flex items-center cursor-pointer">
                            <div class="relative switch">
                                <input type="checkbox" id="persons-per-shift-enabled-toggle" class="sr-only peer">
                                <span class="slider"></span>
                            </div>
                        </label>
                    </div>
                    <p class="text-xs text-gray-500 mb-4">
                        Define el rango de empleados (m√≠nimo - m√°ximo) requeridos por turno.
                        M2, T2, N2 cuentan como M, T, N respectivamente. Deja un campo vac√≠o si no hay l√≠mite espec√≠fico.
                    </p>
                    <div id="persons-per-shift-settings-inputs" class="space-y-3 hidden-by-default">
                        <div class="grid grid-cols-1 sm:grid-cols-7 gap-x-3 items-center">
                            <label for="persons-morning-min" class="text-sm font-medium text-gray-600 sm:col-span-2">Ma√±anas (M/M2):</label>
                            <input type="number" id="persons-morning-min" placeholder="M√≠n." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2">
                            <span class="text-center sm:col-span-1 hidden sm:inline">-</span>
                            <input type="number" id="persons-morning-max" placeholder="M√°x." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2 mt-1 sm:mt-0">
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-7 gap-x-3 items-center">
                            <label for="persons-afternoon-min" class="text-sm font-medium text-gray-600 sm:col-span-2">Tardes (T/T2):</label>
                            <input type="number" id="persons-afternoon-min" placeholder="M√≠n." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2">
                            <span class="text-center sm:col-span-1 hidden sm:inline">-</span>
                            <input type="number" id="persons-afternoon-max" placeholder="M√°x." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2 mt-1 sm:mt-0">
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-7 gap-x-3 items-center">
                            <label for="persons-night-min" class="text-sm font-medium text-gray-600 sm:col-span-2">Noches (N/N2):</label>
                            <input type="number" id="persons-night-min" placeholder="M√≠n." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2">
                            <span class="text-center sm:col-span-1 hidden sm:inline">-</span>
                            <input type="number" id="persons-night-max" placeholder="M√°x." min="0" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2 mt-1 sm:mt-0">
                        </div>
                    </div>
                </div>
            
                <div class="rule-block border p-4 rounded-lg bg-white shadow">
                   <div class="flex justify-between items-center mb-3">
                       <h4 class="text-lg font-semibold text-gray-800">M√°ximo D√≠as Consecutivos Trabajados</h4>
                       <label for="max-consecutive-days-enabled-toggle" class="flex items-center cursor-pointer">
                           <div class="relative switch">
                               <input type="checkbox" id="max-consecutive-days-enabled-toggle" class="sr-only peer">
                               <span class="slider"></span>
                           </div>
                       </label>
                   </div>
                   <p class="text-xs text-gray-500 mb-4">
                       Define el n√∫mero m√°ximo de d√≠as que un empleado puede trabajar consecutivamente sin un d√≠a libre.
                       Se consideran d√≠as trabajados aquellos con turnos M, T, N (y sus variantes M2, T2, N2) o texto personalizado.
                   </p>
                   <div id="max-consecutive-days-settings-inputs" class="space-y-3 hidden-by-default">
                       <div class="grid grid-cols-1 sm:grid-cols-3 items-center gap-x-3">
                           <label for="max-consecutive-days-input" class="text-sm font-medium text-gray-600 sm:col-span-1">M√°x. D√≠as:</label>
                           <input type="number" id="max-consecutive-days-input" placeholder="Ej: 7" min="1" class="w-full p-1.5 border border-gray-300 rounded-md text-sm sm:col-span-2">
                       </div>
                   </div>
               </div>
            
                <div id="rule-violations-summary-section" class="p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-semibold text-gray-700 mb-3">Resumen de Violaciones de Normas:</h4>
                    <div id="rule-violations-summary" class="text-sm text-gray-600 max-h-40 overflow-y-auto">
                        <p>No se han detectado violaciones o las normas est√°n desactivadas.</p>
                        </div>
                </div>
            </div>
            
            
            <div class="mt-6 pt-4 border-t border-gray-200 flex justify-end space-x-3">
                <button id="save-rules-button" class="action-button bg-indigo-500 text-white hover:bg-indigo-600 focus:ring-indigo-400 px-4 py-2" disabled>
                    <i class="fas fa-save mr-2"></i>Guardar Normas
                </button>
                <button id="modal-ok-rules-button" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">
                    Cerrar
                </button>
            </div>
        </div>
    </div>
	
	
	    <div id="confirm-clear-local-storage-modal" class="modal hidden-by-default">
        <div class="modal-content">
            <div class="text-center">
                <h3 class="text-2xl font-bold text-red-600 mb-2">¬°ATENCI√ìN!</h3>
                <p class="text-gray-700 mb-4">Est√°s a punto de borrar <strong class="font-semibold">TODOS los datos locales</strong> de esta aplicaci√≥n (horarios, notas, colores, historial, normas, etc.).</p>
                <p class="text-sm text-gray-500 mb-1">Esta acci√≥n es <strong class="text-red-700">PERMANENTE</strong> y no se podr√° deshacer.</p>
                <p id="clear-local-storage-countdown-message" class="text-red-500 font-semibold mb-4"></p>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-cancel-clear-local-storage" class="action-button bg-gray-300 text-gray-700 hover:bg-gray-400 px-4 py-2">Cancelar</button>
                    <button id="modal-confirm-clear-local-storage" class="action-button bg-red-600 text-white hover:bg-red-700 px-4 py-2" disabled>Confirmar Borrado</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- CONSTANTES Y CONFIGURACI√ìN ---
		
        const SVG_GHM_LOGO_SIMPLE = `
            <g transform="scale(0.5)">
                <defs>
                    <path id="star-shape" d="M10 0 L12.3511 6.1803 L19.5106 7.2949 L14.7295 12.3197 L15.2939 19.0211 L10 16 L4.7061 19.0211 L5.2705 12.3197 L0.4894 7.2949 L7.6489 6.1803 Z" />
                </defs>
                <text x="110" y="28" style="font-family: 'Times New Roman', Times, serif; font-size: 20px; font-weight: normal; fill: #252525; text-anchor: middle; dominant-baseline: central;">GRAN HOTEL</text>
                <text x="110" y="55" style="font-family: 'Times New Roman', Times, serif; font-size: 26px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: central;">MIRAMAR</text>
                <g style="fill: #B08D57;" transform="translate(68.5, 72) scale(0.7)">
                    <use href="#star-shape" x="0" />
                    <use href="#star-shape" x="25" />
                    <use href="#star-shape" x="50" />
                    <use href="#star-shape" x="75" />
                    <use href="#star-shape" x="100" />
                </g>
            </g>
        `;

        // Estos pueden mantenerse como en el prototipo, definen la estructura de la tabla en el PDF.
        const statHeadersPdf = { 
            name: "Empleado", M: "Ma√±anas", T: "Tardes", N: "Noches", L: "Libres", V: "Vacaciones", B: "Bajas", Otro: "Otros", totalWorkDays: "D√≠as Trab.", weekendsOff: "FDS Libres"
        };
        const columnOrderPdf = ["name", "M", "T", "N", "L", "V", "B", "Otro", "totalWorkDays", "weekendsOff"];

        const SVG_FINAL_LOGO_MARKUP = `
            <svg width="200" height="75" viewBox="0 0 220 100" xmlns="http://www.w3.org/2000/svg">
                <style>
                    .logo-text-gh { font-family: 'Times New Roman', Times, serif; font-size: 20px; font-weight: normal; fill: #252525; text-anchor: middle; dominant-baseline: central; }
                    .logo-text-m { font-family: 'Times New Roman', Times, serif; font-size: 26px; font-weight: bold; fill: #1a1a1a; text-anchor: middle; dominant-baseline: central; }
                    .stars-group { fill: #B08D57; }
                </style>
                <defs>
                    <path id="star-shape" d="M10 0 L12.3511 6.1803 L19.5106 7.2949 L14.7295 12.3197 L15.2939 19.0211 L10 16 L4.7061 19.0211 L5.2705 12.3197 L0.4894 7.2949 L7.6489 6.1803 Z" />
                </defs>
                <text x="110" y="28" class="logo-text-gh">GRAN HOTEL</text>
                <text x="110" y="55" class="logo-text-m">MIRAMAR</text>
                <g class="stars-group" transform="translate(68.5, 72) scale(0.7)">
                    <use href="#star-shape" x="0" />
                    <use href="#star-shape" x="25" />
                    <use href="#star-shape" x="50" />
                    <use href="#star-shape" x="75" />
                    <use href="#star-shape" x="100" />
                </g>
            </svg>
        `;

        const MONTH_NAMES = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
        const SHORT_MONTH_NAMES = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const WEEK_DAY_NAMES = ["Domingo", "Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado"];
        const SHORT_WEEK_DAY_NAMES = ["D", "L", "M", "X", "J", "V", "S"];
        const SHIFT_TYPES = ["M", "T", "N", "L", "V", "B", "M2", "T2", "N2"];
        const SHIFT_TYPE_FULL_NAMES = {
            M: "Ma√±ana", T: "Tarde", N: "Noche", L: "Libre", V: "Vacaciones", B: "Baja", M2: "Ma√±ana 2", T2: "Tarde 2", N2: "Noche 2"
        };
        const DEFAULT_SHIFT_TIMES = {
            M: { start: [7,0], end: [15,0], nextDayEnd: false },
            T: { start: [15,0], end: [23,0], nextDayEnd: false },
            N: { start: [23,0], end: [7,0], nextDayEnd: true },
            M2: { start: [8,0], end: [16,0], nextDayEnd: false },
            T2: { start: [16,0], end: [0,0], nextDayEnd: false },
            N2: { start: [0,0], end: [8,0], nextDayEnd: false }
        };
        let currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));

        const LOCAL_STORAGE_KEY_SCHEDULE = 'scheduleAppData_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_NOTES = 'scheduleAppNotes_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_VIEW = 'scheduleAppView_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_COLORS = 'scheduleAppColors_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_HISTORY = 'scheduleAppHistory_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_YEAR = 'scheduleAppYear_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_SHIFT_TIMES = 'scheduleAppShiftTimes_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_AUTOSAVE = 'scheduleAppAutosaveEnabled_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_UNDO_STACK = 'scheduleAppUndoStack_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_REDO_STACK = 'scheduleAppRedoStack_v3_26_svglogo_final_stats_reforma_v2.7_features_helpmodal_baja_STATS_REFORM_V1';
        const LOCAL_STORAGE_KEY_RULES = 'scheduleAppRulesConfig_v1'; 


        const TEMPLATE_FLAG_FILENAME = "TEMPLATE_SCHEDULE";


        const MAX_HISTORY_ITEMS = 30;
        const MAX_UNDO_STACK_SIZE = 30;

        let undoStack = [];
        let redoStack = [];
        let currentConfirmAction = null;
        let currentPaletteScrollListener = null; 


		// INICIO: A√ëADIR ESTA NUEVA VARIABLE GLOBAL
		let activeRuleViolations = {}; // Objeto para almacenar violaciones: { "a√±o-mes-d√≠a": ["mensaje1"] }
		let activeConsecutiveDayViolations = {}; // Formato: { "employeeName": [{ startDay, endDay, count, month, year }, ...], ... }
        let clearLocalStorageCountdownInterval = null;
		
        const LONG_PRESS_DURATION = 500;
        const MAX_TOUCH_MOVE_THRESHOLD = 10;
        let dragOverIndicator = null;
        let deleteCountdownInterval = null;
        let employeeToDeleteName = null;

        const DEFAULT_SHIFT_COLORS = {
            M: { // Versi√≥n OSCURA (ej. Ma√±ana)
                bg: 'bg-green-300',    // Clase Tailwind para la tabla HTML (verde oscuro)
                text: 'text-green-700',  // Clase Tailwind para la tabla HTML
                hexBg: '#86efac',      // HEX para PDF (CORREGIDO para coincidir con bg-green-300)
                hexText: '#047857'     // HEX para PDF (CORREGIDO para coincidir con text-green-700)
            },
            T: { // TURNO TARDE - ¬°MODIFICADO! (M√°s oscuro que T2)
                bg: 'bg-orange-400',   // Naranja medio
                text: 'text-orange-900', // Texto naranja muy oscuro para contraste
                hexBg: '#fa811e',      // HEX correspondiente a bg-orange-400
                hexText: '#7c2d12'     // HEX correspondiente a text-orange-900
            },
            N: { // Versi√≥n OSCURA (ej. Noche)
                bg: 'bg-blue-300',     // Clase Tailwind (azul oscuro)
                text: 'text-blue-700',   // Clase Tailwind
                hexBg: '#93c5fd',      // HEX para PDF (CORREGIDO para coincidir con bg-blue-300)
                hexText: '#1d4ed8'     // HEX para PDF (CORREGIDO para coincidir con text-blue-700)
            },
            M2: { // Versi√≥n CLARA (ej. Ma√±ana 2)
                bg: 'bg-green-200',    // Clase Tailwind (verde claro)
                text: 'text-green-800',  // Clase Tailwind
                hexBg: '#bbf7d0',      // HEX para PDF (CORREGIDO para coincidir con bg-green-200)
                hexText: '#065f46'     // HEX para PDF (CORREGIDO para coincidir con text-green-800)
            },
            T2: { // Versi√≥n CLARA (ej. Tarde 2)
                bg: 'bg-orange-200',   // Clase Tailwind (naranja claro)
                text: 'text-orange-800', // Clase Tailwind
                hexBg: '#fed7aa',      // HEX para PDF (CORREGIDO para coincidir con bg-orange-200)
                hexText: '#9a3412'     // HEX para PDF (CORREGIDO para coincidir con text-orange-800)
            },
            N2: { // Versi√≥n CLARA (ej. Azul 2)
                bg: 'bg-blue-200',     // Clase Tailwind (azul claro)
                text: 'text-blue-800',   // Clase Tailwind
                hexBg: '#bfdbfe',      // HEX para PDF (CORREGIDO para coincidir con bg-blue-200)
                hexText: '#1e40af'     // HEX para PDF (CORREGIDO para coincidir con text-blue-800)
            },
            L: { bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            V: { bg: 'bg-yellow-300', text: 'text-yellow-700', hexBg: '#fde047', hexText: '#b45309' },
            B: { bg: 'bg-red-400', text: 'text-red-800', hexBg: '#f87171', hexText: '#991b1b' },
            empty: { bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' }
        };
        
        

        const AVAILABLE_COLORS = [
            { name: 'Blanco', bg: 'bg-white', text: 'text-gray-500', hexBg: '#ffffff', hexText: '#6b7280' }, 
            { name: 'Verde Pastel', bg: 'bg-green-200', text: 'text-green-700', hexBg: '#a7f3d0', hexText: '#047857' },
            { name: 'Naranja Pastel', bg: 'bg-orange-200', text: 'text-orange-700', hexBg: '#fed7aa', hexText: '#c2410c' },
            { name: 'Azul Pastel', bg: 'bg-blue-200', text: 'text-blue-700', hexBg: '#bfdbfe', hexText: '#1d4ed8' },
            { name: 'Gris Pastel', bg: 'bg-gray-200', text: 'text-gray-700', hexBg: '#e5e7eb', hexText: '#374151' },
            { name: 'Amarillo Pastel', bg: 'bg-yellow-200', text: 'text-yellow-700', hexBg: '#fef08a', hexText: '#a16207' }, 
            { name: 'Rojo Pastel', bg: 'bg-red-200', text: 'text-red-700', hexBg: '#fecaca', hexText: '#b91c1c' },
            { name: 'Rojo Suave', bg: 'bg-red-300', text: 'text-red-800', hexBg: '#fca5a5', hexText: '#991b1b' }, 
            { name: 'Morado Pastel (Def. Otro)', bg: 'bg-purple-200', text: 'text-purple-700', hexBg: '#e9d5ff', hexText: '#7e22ce' },
            { name: 'Cian Pastel', bg: 'bg-cyan-200', text: 'text-cyan-700', hexBg: '#a5f3fc', hexText: '#0e7490' },
            { name: 'Rosa Pastel', bg: 'bg-pink-200', text: 'text-pink-700', hexBg: '#fbcfe8', hexText: '#be185d' },
            { name: 'Lima Pastel', bg: 'bg-lime-200', text: 'text-lime-700', hexBg: '#d9f99d', hexText: '#65a30d' },
            { name: 'Esmeralda Pastel', bg: 'bg-emerald-200', text: 'text-emerald-700', hexBg: '#a7f3d0', hexText: '#065f46' }, 
            { name: 'Turquesa Pastel', bg: 'bg-teal-200', text: 'text-teal-700', hexBg: '#99f6e4', hexText: '#0d9488' },
            { name: 'Fucsia Pastel', bg: 'bg-fuchsia-200', text: 'text-fuchsia-700', hexBg: '#f5d0fe', hexText: '#a21caf' },
            { name: 'Celeste Pastel', bg: 'bg-sky-200', text: 'text-sky-700', hexBg: '#bae6fd', hexText: '#0369a1' },
            { name: '√çndigo Pastel', bg: 'bg-indigo-200', text: 'text-indigo-700', hexBg: '#c7d2fe', hexText: '#4338ca' },
            { name: 'Verde Suave (M2)', bg: 'bg-green-300', text: 'text-green-800', hexBg: '#86efac', hexText: '#185938' },
            { name: 'Naranja Suave (T2)', bg: 'bg-orange-300', text: 'text-orange-800', hexBg: '#fdba74', hexText: '#9a3412' },
            { name: 'Azul Suave (N2)', bg: 'bg-blue-300', text: 'text-blue-800', hexBg: '#93c5fd', hexText: '#1e40af' },
            { name: 'Melocot√≥n', bg: 'bg-orange-100', text: 'text-orange-700', hexBg: '#ffedd5', hexText: '#c2410c' }, 
            { name: 'Azul Cielo', bg: 'bg-blue-100', text: 'text-blue-700', hexBg: '#dbeafe', hexText: '#1d4ed8' }, 
            { name: 'Gris Muy Claro', bg: 'bg-gray-100', text: 'text-gray-700', hexBg: '#f3f4f6', hexText: '#374151' }, 
            { name: 'Crema', bg: 'bg-yellow-100', text: 'text-yellow-700', hexBg: '#fef9c3', hexText: '#a16207' }, 
            { name: 'Salm√≥n', bg: 'bg-red-100', text: 'text-red-700', hexBg: '#fee2e2', hexText: '#b91c1c' }, 
            { name: 'Lavanda', bg: 'bg-purple-100', text: 'text-purple-700', hexBg: '#f3e8ff', hexText: '#7e22ce' }, 
            { name: 'Aguamarina', bg: 'bg-cyan-100', text: 'text-cyan-700', hexBg: '#cffafe', hexText: '#0e7490' }, 
            { name: 'Menta Azulado', bg: 'bg-teal-100', text: 'text-teal-700', hexBg: '#ccfbf1', hexText: '#0d9488' }, 
            { name: 'Magenta Claro', bg: 'bg-fuchsia-100', text: 'text-fuchsia-700', hexBg: '#fae8ff', hexText: '#a21caf' }, 
            { name: 'Coral Claro', bg: 'bg-rose-100', text: 'text-rose-700', hexBg: '#ffe4e6', hexText: '#be123c' }, 
            { name: 'Azul Hielo', bg: 'bg-sky-100', text: 'text-sky-700', hexBg: '#e0f2fe', hexText: '#0369a1' }, 
            { name: '√çndigo Muy Claro', bg: 'bg-indigo-100', text: 'text-indigo-700', hexBg: '#e0e7ff', hexText: '#4338ca' }, 
            { name: 'Amarillo Suave', bg: 'bg-yellow-300', text: 'text-yellow-800', hexBg: '#fde047', hexText: '#854d0e' },
            { name: 'Rojo Intenso', bg: 'bg-red-500', text: 'text-red-100', hexBg: '#ef4444', hexText: '#fee2e2' },
            { name: 'Naranja Intenso', bg: 'bg-orange-500', text: 'text-orange-100', hexBg: '#f97316', hexText: '#ffedd5' },
            { name: '√Åmbar Intenso', bg: 'bg-amber-500', text: 'text-amber-900', hexBg: '#f59e0b', hexText: '#78350f' },
            { name: 'Lima Intenso', bg: 'bg-lime-500', text: 'text-lime-900', hexBg: '#84cc16', hexText: '#365314' },
            { name: 'Verde Intenso', bg: 'bg-green-600', text: 'text-green-100', hexBg: '#16a34a', hexText: '#dcfce7' },
            { name: 'Esmeralda Intenso', bg: 'bg-emerald-500', text: 'text-emerald-100', hexBg: '#10b981', hexText: '#d1fae5' },
            { name: 'Turquesa Intenso', bg: 'bg-teal-500', text: 'text-teal-100', hexBg: '#14b8a6', hexText: '#ccfbf1' },
            { name: 'Cian Intenso', bg: 'bg-cyan-500', text: 'text-cyan-100', hexBg: '#06b6d4', hexText: '#cffafe' },
            { name: 'Celeste Intenso', bg: 'bg-sky-600', text: 'text-sky-100', hexBg: '#0284c7', hexText: '#e0f2fe' },
            { name: 'Azul Intenso', bg: 'bg-blue-600', text: 'text-blue-100', hexBg: '#2563eb', hexText: '#dbeafe' },
            { name: '√çndigo Intenso', bg: 'bg-indigo-600', text: 'text-indigo-100', hexBg: '#4f46e5', hexText: '#e0e7ff' },
            { name: 'Violeta Intenso', bg: 'bg-violet-600', text: 'text-violet-100', hexBg: '#7c3aed', hexText: '#ede9fe' },
            { name: 'P√∫rpura Intenso', bg: 'bg-purple-600', text: 'text-purple-100', hexBg: '#9333ea', hexText: '#f3e8ff' },
            { name: 'Fucsia Intenso', bg: 'bg-fuchsia-600', text: 'text-fuchsia-100', hexBg: '#d946ef', hexText: '#fae8ff' },
            { name: 'Rosa Intenso', bg: 'bg-pink-600', text: 'text-pink-100', hexBg: '#db2777', hexText: '#fce7f3' },
            { name: 'Rosado Intenso', bg: 'bg-rose-600', text: 'text-rose-100', hexBg: '#e11d48', hexText: '#ffe4e6' },
            { name: 'Gris Medio', bg: 'bg-gray-400', text: 'text-gray-800', hexBg: '#9ca3af', hexText: '#1f2937' }, 
            { name: 'Gris Oscuro', bg: 'bg-gray-600', text: 'text-gray-100', hexBg: '#4b5563', hexText: '#f3f4f6' },
            { name: 'Amarillo Oro', bg: 'bg-yellow-500', text: 'text-yellow-900', hexBg: '#eab308', hexText: '#713f12' }, 
            { name: 'Verde Bosque', bg: 'bg-green-700', text: 'text-green-100', hexBg: '#047857', hexText: '#dcfce7' },
            { name: 'Azul Marino', bg: 'bg-blue-800', text: 'text-blue-100', hexBg: '#1e40af', hexText: '#dbeafe' },
            { name: 'Morado Real', bg: 'bg-purple-700', text: 'text-purple-100', hexBg: '#6b21a8', hexText: '#f3e8ff' },
            { name: 'Rojo Carmes√≠', bg: 'bg-red-700', text: 'text-red-100', hexBg: '#b91c1c', hexText: '#fee2e2' },
            { name: 'Naranja Fuerte', bg: 'bg-orange-600', text: 'text-orange-100', hexBg: '#ea580c', hexText: '#ffedd5' },
            { name: 'Cian Oscuro', bg: 'bg-cyan-700', text: 'text-cyan-100', hexBg: '#0891b2', hexText: '#cffafe' },
            { name: '√çndigo Oscuro', bg: 'bg-indigo-700', text: 'text-indigo-100', hexBg: '#4338ca', hexText: '#e0e7ff' },
            { name: 'Rosa Mexicano', bg: 'bg-pink-500', text: 'text-pink-100', hexBg: '#ec4899', hexText: '#fce7f3' },
            { name: 'Verde Lima Fuerte', bg: 'bg-lime-600', text: 'text-lime-100', hexBg: '#65a30d', hexText: '#f7fee7' },
        ];

        let currentShiftColors = { ...DEFAULT_SHIFT_COLORS };
        let activeColorPalette = null;

        let scheduleData = {};
        let employeeNamesOrdered = [];
        let currentViewMode = 'monthly';
        let currentSelectedMonth = new Date().getMonth() + 1;
        let yearOfSchedule = new Date().getFullYear();
        let hasUnsavedChanges = false;
        let changeHistory = [];

        let cellsBeingEditedViaEventModal = [];
        let isSingleCellEditViaModal = false;

        let selectedCells = [];
        let lastSelectedCellInfo = null;
        let cellsAffectedByCurrentDrag = new Set();

        let touchstartTime = 0;
        let touchstartTarget = null;
        let longPressTimer = null;
        let touchstartX = 0, touchstartY = 0;
        let wasLongPress = false;

        let isDraggingToSelect = false;
        let dragSelectionStartCellInfo = null;
        let lastCellOverForDragSelectInfo = null;

        let draggedRow = null;
        let currentFilenameConfirmCallback = null;
        let currentFilenameExtension = '';
        let footerHeartClicks = 0;
        let notesDebounceTimer;

        let isAutosaveEnabled = false;
        let autosaveIntervalId = null;
        const AUTOSAVE_INTERVAL_MS = 30000;

        const domCache = {};
		
        const ALL_LOCAL_STORAGE_KEYS = [
            LOCAL_STORAGE_KEY_SCHEDULE,
            LOCAL_STORAGE_KEY_NOTES,
            LOCAL_STORAGE_KEY_VIEW,
            LOCAL_STORAGE_KEY_COLORS,
            LOCAL_STORAGE_KEY_HISTORY,
            LOCAL_STORAGE_KEY_YEAR,
            LOCAL_STORAGE_KEY_SHIFT_TIMES,
            LOCAL_STORAGE_KEY_AUTOSAVE,
            LOCAL_STORAGE_KEY_UNDO_STACK,
            LOCAL_STORAGE_KEY_REDO_STACK,
            LOCAL_STORAGE_KEY_RULES
            // IMPORTANTE: A√±ade aqu√≠ CUALQUIER OTRA CLAVE que tu aplicaci√≥n utilice.
        ];
        

        // INICIO: Nuevas Variables Globales para Normas
        let rulesConfig = {
            personsPerShift: {
                enabled: false, 
                settings: {
                    morning: { min: null, max: null },
                    afternoon: { min: null, max: null },
                    night: { min: null, max: null }
                }
            },
            // --- NUEVA NORMA ---
            maxConsecutiveWorkdays: {
                enabled: false,
                maxDays: 7 // Valor por defecto, por ejemplo, 7 d√≠as
            }
            // --- FIN NUEVA NORMA ---
        };

        // --- FUNCIONES DE GESTI√ìN DE ESTADO (DESHACER/REHACER) ---
        function getAppStateSnapshot() {
            return {
                scheduleData: JSON.parse(JSON.stringify(scheduleData)),
                employeeNamesOrdered: JSON.parse(JSON.stringify(employeeNamesOrdered)),
                currentShiftColors: JSON.parse(JSON.stringify(currentShiftColors)),
                currentUserShiftTimes: JSON.parse(JSON.stringify(currentUserShiftTimes)),
                generalNotes: domCache.generalNotesTextarea.value,
                yearOfSchedule: yearOfSchedule,
                currentSelectedMonth: currentSelectedMonth,
                currentViewMode: currentViewMode,
                uploadedFileName: domCache.csvFileInput?.dataset?.uploadedFileName || null,
                rulesConfig: JSON.parse(JSON.stringify(rulesConfig)) // 
            };
        }

        function restoreAppState(snapshot) {
        		const currentGlobalYearBeforeRestore = yearOfSchedule;
        
        		scheduleData = snapshot.scheduleData;
        		employeeNamesOrdered = snapshot.employeeNamesOrdered;
        		currentShiftColors = snapshot.currentShiftColors;
        		currentUserShiftTimes = snapshot.currentUserShiftTimes;
        		domCache.generalNotesTextarea.value = snapshot.generalNotes;
            // <<<< INICIO: A√ëADIR ESTO PARA RULESCONFIG >>>>
            if (snapshot.rulesConfig) {
                rulesConfig = snapshot.rulesConfig;
            } else {
                // Si el snapshot es antiguo y no tiene rulesConfig, usar defaults
                rulesConfig = getDefaultRulesConfig();
            }
            // <<<< FIN: A√ëADIR ESTO PARA RULESCONFIG >>>>
        
        		currentSelectedMonth = snapshot.currentSelectedMonth;
        		currentViewMode = snapshot.currentViewMode;
        		if (domCache.csvFileInput) {
        			if (snapshot.uploadedFileName) {
        				domCache.csvFileInput.dataset.uploadedFileName = snapshot.uploadedFileName;
        			} else {
        				delete domCache.csvFileInput.dataset.uploadedFileName;
        			}
        		}
        
        		yearOfSchedule = currentGlobalYearBeforeRestore;
        		domCache.yearInput.value = yearOfSchedule; 
        
        		updateLegend();
        		handleViewChange(); 
        		initializeAndRenderNewStatistics(); 
        		populateMonthTabs();
        		updateViewModeUI();
        		updateUnsavedChangesIndicator();
        		updateUndoRedoButtonsState();
            validateAndDisplayRuleViolations(); // <<<< A√ëADIR: Revalidar normas despu√©s de restaurar estado
        	}

        function saveStateForUndo(descriptionForHistory) {
            if (undoStack.length >= MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            undoStack.push(getAppStateSnapshot());
            redoStack = [];
            addChangeToHistory(descriptionForHistory);
            hasUnsavedChanges = true;
            updateUnsavedChangesIndicator();
            if (domCache.saveLocalButton) domCache.saveLocalButton.disabled = !isDataLoadedForSave();
            updateUndoRedoButtonsState();
        }

        function undoChange() {
            if (undoStack.length === 0) return;
            redoStack.push(getAppStateSnapshot());
            if (redoStack.length > MAX_UNDO_STACK_SIZE) {
                redoStack.shift();
            }
            const previousState = undoStack.pop();
            restoreAppState(previousState);
            showToast('Acci√≥n deshecha.', 'info');
            addChangeToHistory("Acci√≥n deshecha.");
            updateUndoRedoButtonsState();
        }

        function redoChange() {
            if (redoStack.length === 0) return;
            undoStack.push(getAppStateSnapshot());
            if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                undoStack.shift();
            }
            const nextState = redoStack.pop();
            restoreAppState(nextState);
            showToast('Acci√≥n rehecha.', 'info');
            addChangeToHistory("Acci√≥n rehecha.");
            updateUndoRedoButtonsState();
        }

        function updateUndoRedoButtonsState() {
            if (domCache.undoButton) {
                domCache.undoButton.disabled = undoStack.length === 0;
            }
            if (domCache.redoButton) {
                domCache.redoButton.disabled = redoStack.length === 0;
            }
        }

        // --- UTILIDADES ---
        function createElement(tag, options = {}, children = []) {
            const element = document.createElement(tag);
            if (options.className) element.className = options.className;
            if (options.id) element.id = options.id;
            if (options.textContent) element.textContent = options.textContent;
            if (options.innerHTML) element.innerHTML = options.innerHTML;
            if (options.title) element.title = options.title;
            if (options.dataset) {
                for (const key in options.dataset) {
                    element.dataset[key] = options.dataset[key];
                }
            }
            if (options.style) {
                for (const prop in options.style) {
                    element.style[prop] = options.style[prop];
                }
            }
            if (options.attributes) {
                for (const attr in options.attributes) {
                    element.setAttribute(attr, options.attributes[attr]);
                }
            }
            children.forEach(child => {
                if (typeof child === 'string') {
                    element.appendChild(document.createTextNode(child));
                } else if (child instanceof Node) {
                    element.appendChild(child);
                }
            });
            return element;
        }

        function updateUnsavedChangesIndicator() {
            if (domCache.unsavedIndicatorTable) {
                domCache.unsavedIndicatorTable.classList.toggle('hidden-by-default', !hasUnsavedChanges);
            }
            if (domCache.saveLocalButton) {
                 domCache.saveLocalButton.disabled = !hasUnsavedChanges || !isDataLoadedForSave();
            }
        }


        function lightenDarkenColor(col, amt) {
            let usePound = false;
            if (col[0] == "#") {
                col = col.slice(1);
                usePound = true;
            }
            let num = parseInt(col, 16);
            if (isNaN(num)) return usePound ? "#FFFFFF" : "FFFFFF";
            let r = (num >> 16) + amt;
            if (r > 255) r = 255; else if (r < 0) r = 0;
            let b = ((num >> 8) & 0x00FF) + amt;
            if (b > 255) b = 255; else if (b < 0) b = 0;
            let g = (num & 0x0000FF) + amt;
            if (g > 255) g = 255; else if (g < 0) g = 0;
            let hex = (g | (b << 8) | (r << 16)).toString(16);
            while(hex.length < 6) hex = '0' + hex;
            return (usePound ? "#" : "") + hex;
        }


        // --- CACH√â DE ELEMENTOS DEL DOM ---
        function cacheDOMElements() {
            // --- Elementos Generales y de Control Principal ---
            domCache.mainTitleText = document.getElementById('main-title-text');
            domCache.logoContainer = document.getElementById('logo-container');
            domCache.toastContainer = document.getElementById('toast-container');
            domCache.footerTextElement = document.getElementById('footer-text');
            domCache.creatorNameElement = document.getElementById('creator-name');
            domCache.footerHeartElement = document.getElementById('footer-heart');
        
            // --- Controles de Importaci√≥n, A√±o y Guardado/Exportaci√≥n Principal ---
            domCache.csvFileInput = document.getElementById('csv-file-input');
            domCache.yearInput = document.getElementById('year-input');
            domCache.saveLocalButton = document.getElementById('save-local-button');
            domCache.exportCsvButton = document.getElementById('export-csv-button');
            domCache.createEmptyCsvButton = document.getElementById('create-empty-csv-button');
            domCache.downloadImageButton = document.getElementById('download-image-button');
            domCache.downloadWeeklySvgButton = document.getElementById('download-weekly-svg-button');
            domCache.exportMonthCalendarButton = document.getElementById('export-month-calendar-button');
            domCache.autosaveToggle = document.getElementById('autosave-toggle');
            domCache.saveLocalHelpIcon = document.getElementById('save-local-help-icon');
        
            // --- Controles de Vista y Navegaci√≥n del Horario Principal ---
            domCache.viewMonthlyButton = document.getElementById('view-monthly-button');
            domCache.viewAnnualButton = document.getElementById('view-annual-button');
            domCache.viewModeButtonsContainer = document.getElementById('view-mode-buttons-container');
            domCache.monthTabsContainer = document.getElementById('month-tabs-container');
			domCache.monthTabsWrapper = document.getElementById('month-tabs-wrapper');
        
            // --- Secciones Principales de la UI ---
            domCache.welcomeMessage = document.getElementById('welcome-message');
            domCache.scheduleDisplaySection = document.getElementById('schedule-display-section');
            domCache.scheduleTableSection = document.getElementById('schedule-table-section');
            // domCache.notesSection = document.getElementById('notes-section'); // Ya no existe como secci√≥n principal
            // domCache.legendSection = document.getElementById('legend-section'); // Ya no existe como secci√≥n principal
            domCache.historySection = document.getElementById('history-section');
        
            // --- Elementos de la Tabla de Horario Principal ---
            domCache.currentMonthYearDisplay = document.getElementById('current-month-year-display');
            domCache.currentMonthYearText = document.getElementById('current-month-year-text');
            domCache.unsavedIndicatorTable = document.getElementById('unsaved-indicator-table');
            domCache.scheduleTableHead = document.getElementById('schedule-table-head');
            domCache.scheduleTableBody = document.getElementById('schedule-table-body');
            domCache.noDataMessage = document.getElementById('no-data-message');
        
            // --- Barra de Herramientas de Multiselecci√≥n y Paleta de Colores ---
            domCache.multiselectToolbar = document.getElementById('multiselect-toolbar');
            domCache.colorPalettePopupContainer = document.getElementById('color-palette-popup-container');
        
            // --- Leyenda (ahora dentro del modal) ---
            domCache.legendItemsContainer = document.getElementById('legend-items-container'); // Sigue siendo el mismo ID, pero ahora est√° en el modal
        
            // --- Historial de Cambios y Notas ---
            domCache.changeHistoryList = document.getElementById('change-history-list');
            domCache.generalNotesTextarea = document.getElementById('general-notes'); // Asumo que la secci√≥n de notas sigue existiendo
            domCache.undoButton = document.getElementById('undo-button');
            domCache.redoButton = document.getElementById('redo-button');
        
            // --- Modales Existentes ---
            domCache.addEmployeeModal = document.getElementById('add-employee-modal');
            domCache.modalEmployeeNameInput = document.getElementById('modal-employee-name-input');
            domCache.modalConfirmAddEmployee = document.getElementById('modal-confirm-add-employee');
            domCache.modalCancelAddEmployee = document.getElementById('modal-cancel-add-employee');
        
            domCache.deleteEmployeeModal = document.getElementById('delete-employee-modal');
            domCache.employeeNameToDeleteSpan = document.getElementById('employee-name-to-delete');
            domCache.deleteCountdownMessageSpan = document.getElementById('delete-countdown-message');
            domCache.modalConfirmDeleteEmployee = document.getElementById('modal-confirm-delete-employee');
            domCache.modalCancelDeleteEmployee = document.getElementById('modal-cancel-delete-employee');
        
            domCache.filenameModal = document.getElementById('filename-modal');
            domCache.filenameModalTitle = document.getElementById('filename-modal-title');
            domCache.filenameModalDescription = document.getElementById('filename-modal-description');
            domCache.modalFilenameInput = document.getElementById('modal-filename-input');
            domCache.modalConfirmFilename = document.getElementById('modal-confirm-filename');
            domCache.modalCancelFilename = document.getElementById('modal-cancel-filename');
        
            domCache.exportCalendarModal = document.getElementById('export-calendar-modal');
            domCache.modalCalendarEmployeeSelect = document.getElementById('modal-calendar-employee-select');
            domCache.modalConfirmExportCalendar = document.getElementById('modal-confirm-export-calendar');
            domCache.modalCancelExportCalendar = document.getElementById('modal-cancel-export-calendar');
        
            domCache.tipsModal = document.getElementById('tips-modal');
            domCache.helpIconContainer = document.getElementById('help-icon-container');
            domCache.closeTipsModalButton = document.getElementById('close-tips-modal');
            domCache.okTipsModalButton = document.getElementById('ok-tips-modal');
        
            domCache.customEventModal = document.getElementById('custom-event-modal');
            domCache.customEventModalTitle = document.getElementById('custom-event-modal-title');
            domCache.modalCustomEventInput = document.getElementById('modal-custom-event-input');
            domCache.modalConfirmCustomEvent = document.getElementById('modal-confirm-custom-event');
            domCache.modalCancelCustomEvent = document.getElementById('modal-cancel-custom-event');
        
            domCache.confirmLoadCsvModal = document.getElementById('confirm-load-csv-modal');
            domCache.confirmLoadCsvMessage = document.getElementById('confirm-load-csv-message');
            domCache.modalCancelLoadCsv = document.getElementById('modal-cancel-load-csv');
            domCache.modalConfirmLoadCsv = document.getElementById('modal-confirm-load-csv');
        
            domCache.saveLocalHelpModal = document.getElementById('save-local-help-modal');
            domCache.closeSaveLocalHelpModalIcon = document.getElementById('close-save-local-help-modal-icon');
            domCache.closeSaveLocalHelpModalButton = document.getElementById('close-save-local-help-modal-button');
        
            // --- Elementos de Estad√≠sticas (sin cambios en este paso, pero listados por completitud) ---
            domCache.statisticsSectionReformed = document.getElementById('statistics-section');
            domCache.mainStatsTableSection = document.getElementById('idea1-table-improved-expanded');
            domCache.statsTableHead = document.getElementById('stats-table-head');
            domCache.statsTableBody = document.getElementById('tbody-idea1-expanded');
            domCache.paginationInfo = document.getElementById('pagination-info');
            domCache.mainMonthDropdownContainer = document.getElementById('main-month-dropdown-container');
            domCache.mainMonthDropdownBtn = document.getElementById('month-dropdown-btn');
            domCache.selectedMonthText = document.getElementById('selected-month-text');
            domCache.mainMonthDropdownOptions = document.getElementById('month-dropdown-options');
            domCache.showGeneralStatsBtn = document.getElementById('show-general-stats-btn');
            domCache.individualChartsSection = document.getElementById('individual-employee-charts-section');
            domCache.selectedMonthYearDisplayDetails = document.getElementById('selected-month-year-display-details');
            domCache.detailsEmployeeNamePlaceholder = document.getElementById('details-employee-name-placeholder');
            domCache.detailsMonthDropdownContainer = document.getElementById('details-month-dropdown-container');
            domCache.detailsMonthDropdownBtn = document.getElementById('details-month-dropdown-btn');
            domCache.detailsSelectedMonthText = document.getElementById('details-selected-month-text');
            domCache.detailsMonthDropdownOptions = document.getElementById('details-month-dropdown-options');
            domCache.closeIndividualChartsBtn = document.getElementById('close-individual-charts');
            domCache.donutChartCanvas = document.getElementById('donutChartCanvas');
            domCache.donutChartMessage = document.getElementById('donutChartMessage');
            domCache.calendarHeatmapTitle = document.getElementById('calendar-heatmap-title');
            domCache.miniCalendarHeatmapContainer = document.getElementById('mini-calendar-heatmap-container');
            domCache.kpiSummaryCardContainer = document.getElementById('kpi-summary-card-container');
            domCache.donutChartWrapper = document.getElementById('donut-chart-wrapper');
            domCache.calendarHeatmapWrapper = document.getElementById('calendar-heatmap-wrapper');
            domCache.donutCalendarGrid = document.getElementById('donut-calendar-grid');
            domCache.generalPlantillaStatsSection = document.getElementById('general-plantilla-stats-section');
            domCache.closeGeneralStatsBtn = document.getElementById('close-general-stats-btn');
            domCache.generalStatsMonthDropdownContainer = document.getElementById('general-stats-month-dropdown-container');
            domCache.generalStatsMonthDropdownBtn = document.getElementById('general-stats-month-dropdown-btn');
            domCache.generalStatsSelectedMonthText = document.getElementById('general-stats-selected-month-text');
            domCache.generalStatsMonthDropdownOptions = document.getElementById('general-stats-month-dropdown-options');
            domCache.generalStackedBarCanvas = document.getElementById('generalStackedBarCanvas');
            domCache.generalGroupedBarCanvas = document.getElementById('generalGroupedBarCanvas');
            domCache.filenameModalStatsPdf = document.getElementById('filename-modal-stats-pdf');
            domCache.filenameModalTitleStatsPdf = document.getElementById('filename-modal-title-stats-pdf');
            domCache.modalFilenameInputStatsPdf = document.getElementById('modal-filename-input-stats-pdf');
            domCache.filenameModalExtensionStatsPdf = document.getElementById('filename-modal-extension-stats-pdf');
            domCache.modalCancelFilenameStatsPdf = document.getElementById('modal-cancel-filename-stats-pdf');
            domCache.modalConfirmFilenameStatsPdf = document.getElementById('modal-confirm-filename-stats-pdf');
            domCache.exportStatsToPdfButton = document.getElementById('export-stats-to-pdf-button');
        
            // --- NUEVOS ELEMENTOS PARA MODALES DE LEYENDA Y NORMAS ---
            domCache.modalTriggersContainer = document.getElementById('modal-triggers-container');
			domCache.openLegendColorsModalButton = document.getElementById('open-legend-colors-modal-button-nav');
			domCache.openRulesModalButton = document.getElementById('open-rules-modal-button-nav');
        
            // Modal de Leyenda y Colores
            domCache.legendColorsModal = document.getElementById('legend-colors-modal');
            domCache.legendColorsModalBody = document.getElementById('legend-colors-modal-body');
            domCache.closeLegendColorsModalButton = document.getElementById('close-legend-colors-modal-button');
            domCache.modalApplyColorsButton = document.getElementById('modal-apply-colors-button');
            domCache.modalResetColorsButton = document.getElementById('modal-reset-colors-button');
            domCache.modalOkLegendColorsButton = document.getElementById('modal-ok-legend-colors-button');
            // domCache.legendItemsContainer ya est√° cacheado arriba, se mantiene.
        
            // Modal de Normas
            domCache.rulesModal = document.getElementById('rules-modal');
            domCache.rulesModalBody = document.getElementById('rules-modal-body');
            domCache.closeRulesModalButton = document.getElementById('close-rules-modal-button');
            domCache.saveRulesButton = document.getElementById('save-rules-button');
            domCache.modalOkRulesButton = document.getElementById('modal-ok-rules-button');
            domCache.ruleViolationsSummary = document.getElementById('rule-violations-summary');
			domCache.ruleViolationsSummarySection = document.getElementById('rule-violations-summary-section');
			domCache.maxConsecutiveDaysEnabledToggle = document.getElementById('max-consecutive-days-enabled-toggle');
			domCache.maxConsecutiveDaysSettingsInputs = document.getElementById('max-consecutive-days-settings-inputs');
			domCache.maxConsecutiveDaysInput = document.getElementById('max-consecutive-days-input');
			
			domCache.personsPerShiftEnabledToggle = document.getElementById('persons-per-shift-enabled-toggle');
			domCache.personsPerShiftSettingsInputs = document.getElementById('persons-per-shift-settings-inputs');
			domCache.personsMorningMin = document.getElementById('persons-morning-min');
			domCache.personsMorningMax = document.getElementById('persons-morning-max');
			domCache.personsAfternoonMin = document.getElementById('persons-afternoon-min');
			domCache.personsAfternoonMax = document.getElementById('persons-afternoon-max');
			domCache.personsNightMin = document.getElementById('persons-night-min');
			domCache.personsNightMax = document.getElementById('persons-night-max');
			
			
			// Bot√≥n del Footer para borrar datos locales
			domCache.clearLocalStorageButton = document.getElementById('clear-local-storage-button');

			// Elementos del Modal de Confirmaci√≥n de Borrado de LocalStorage
			domCache.confirmClearLocalStorageModal = document.getElementById('confirm-clear-local-storage-modal');
			domCache.clearLocalStorageCountdownMessage = document.getElementById('clear-local-storage-countdown-message');
			domCache.modalCancelClearLocalStorage = document.getElementById('modal-cancel-clear-local-storage');
			domCache.modalConfirmClearLocalStorage = document.getElementById('modal-confirm-clear-local-storage');
        }

        // --- MANEJO DE EVENTOS DE SELECCI√ìN DE CELDAS ---
        function handleCellMouseDown(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;
            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            isDraggingToSelect = true;
            dragSelectionStartCellInfo = cellInfo;
            lastCellOverForDragSelectInfo = cellInfo;
            cellsAffectedByCurrentDrag = new Set();

            processCellClick(cellInfo, event.shiftKey, (event.ctrlKey || event.metaKey), false);

            selectedCells.forEach(sc => {
                cellsAffectedByCurrentDrag.add(sc.tdElement);
            });
            updateMultiselectToolbar();
        }

        function handleDocumentMouseMove(event) {
            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return;
            const currentTarget = event.target;
            const currentTd = currentTarget.closest('td.shift-cell');
            if (!currentTd) return;

            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo) return;

            if (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement) {
                return;
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            const minRow = Math.min(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const maxRow = Math.max(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const minCol = Math.min(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);
            const maxCol = Math.max(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);

            const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
            allCellsInTable.forEach(cellElement => {
                const cellIterInfo = getCellInfoFromElement(cellElement);
                if (!cellIterInfo) return;

                const isInCurrentRect = cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol;
                let isSelectedInGlobalList = selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement);

                if (isInCurrentRect) {
                    if (!isSelectedInGlobalList) {
                        selectedCells.push(cellIterInfo);
                        cellElement.classList.add('cell-selected');
                        cellsAffectedByCurrentDrag.add(cellElement);
                    }
                } else {
                    if (isSelectedInGlobalList && cellsAffectedByCurrentDrag.has(cellElement)) {
                        const index = selectedCells.findIndex(sc => sc.tdElement === cellIterInfo.tdElement);
                        if (index > -1) selectedCells.splice(index, 1);
                        cellElement.classList.remove('cell-selected');
                    }
                }
            });
            updateMultiselectToolbar();
        }

        function handleDocumentMouseUp(event) {
            if (isDraggingToSelect) {
                isDraggingToSelect = false;
            }
        }

        function handleCellTouchStart(event) {
            const targetTd = event.target.closest('td.shift-cell');
            if (!targetTd) return;
            const cellInfo = getCellInfoFromElement(targetTd);
            if (!cellInfo) return;

            touchstartTarget = targetTd;
            touchstartTime = new Date().getTime();
            touchstartX = event.touches[0].clientX;
            touchstartY = event.touches[0].clientY;
            wasLongPress = false;
            isDraggingToSelect = false;
            cellsAffectedByCurrentDrag = new Set();

            const isAlreadySelected = selectedCells.some(sc => sc.tdElement === cellInfo.tdElement);

            if (isAlreadySelected) {
                dragSelectionStartCellInfo = cellInfo;
                lastCellOverForDragSelectInfo = cellInfo;
            } else {
                dragSelectionStartCellInfo = null;
                lastCellOverForDragSelectInfo = null;
            }
            selectedCells.forEach(sc => {
                cellsAffectedByCurrentDrag.add(sc.tdElement);
            });


            if (longPressTimer) clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => {
                if (isDraggingToSelect) {
                    longPressTimer = null;
                    return;
                }
                wasLongPress = true;
                const currentCellInfoOnTimeout = getCellInfoFromElement(touchstartTarget);
                if (currentCellInfoOnTimeout) {
                    const currentValue = scheduleData[currentCellInfoOnTimeout.employee]?.[currentCellInfoOnTimeout.month]?.[currentCellInfoOnTimeout.day] || "";
                    if (!SHIFT_TYPES.includes(currentValue)) {
                         event.preventDefault();
                         editCellOnLongPress(currentCellInfoOnTimeout);
                    }
                }
                longPressTimer = null;
            }, LONG_PRESS_DURATION);
        }

        function handleDocumentTouchMove(event) {
            if (!touchstartTarget) return; // Si no hubo un touchstart, no hacer nada

            const deltaX = Math.abs(event.touches[0].clientX - touchstartX);
            const deltaY = Math.abs(event.touches[0].clientY - touchstartY);

            if (!isDraggingToSelect && (deltaX > MAX_TOUCH_MOVE_THRESHOLD || deltaY > MAX_TOUCH_MOVE_THRESHOLD)) {
                // Si no est√°bamos arrastrando y el movimiento supera el umbral, empezamos a arrastrar.
                isDraggingToSelect = true;
                if (longPressTimer) { // Cancelar el timer de pulsaci√≥n larga si se convierte en arrastre
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                wasLongPress = false; // No fue una pulsaci√≥n larga si se arrastr√≥

                // Si el arrastre comenz√≥, la celda inicial debe ser la celda de inicio del arrastre.
                // Si no estaba seleccionada, seleccionarla ahora.
                dragSelectionStartCellInfo = getCellInfoFromElement(touchstartTarget);
                if (dragSelectionStartCellInfo && !selectedCells.some(sc => sc.tdElement === dragSelectionStartCellInfo.tdElement)) {
                    // Solo la seleccionamos si no estaba ya en la lista (por un toque previo sin arrastre)
                    // No es necesario llamar a processCellClick aqu√≠, ya que el resto de la l√≥gica de arrastre se encargar√°.
                    // Simplemente la marcamos visualmente y la a√±adimos a selectedCells.
                    selectedCells.push(dragSelectionStartCellInfo);
                    dragSelectionStartCellInfo.tdElement.classList.add('cell-selected');
                    cellsAffectedByCurrentDrag.add(dragSelectionStartCellInfo.tdElement); // A√±adir a las afectadas por este arrastre
                }
                lastCellOverForDragSelectInfo = dragSelectionStartCellInfo; // La celda inicial es la √∫ltima sobre la que pasamos
            }

            if (!isDraggingToSelect || !dragSelectionStartCellInfo) return; // Si a√∫n no estamos arrastrando o no hay celda de inicio, salir

            event.preventDefault(); // Prevenir scroll solo si estamos efectivamente arrastrando para seleccionar

            const currentTarget = document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY);
            const currentTd = currentTarget ? currentTarget.closest('td.shift-cell') : null;
            if (!currentTd) return;

            const currentCellInfo = getCellInfoFromElement(currentTd);
            if (!currentCellInfo || (lastCellOverForDragSelectInfo && currentCellInfo.tdElement === lastCellOverForDragSelectInfo.tdElement)) {
                return; // No hacer nada si no es una celda v√°lida o es la misma que la √∫ltima procesada
            }
            lastCellOverForDragSelectInfo = currentCellInfo;

            // L√≥gica para determinar el rect√°ngulo de selecci√≥n y actualizar celdas
            const minRow = Math.min(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const maxRow = Math.max(dragSelectionStartCellInfo.rowIndex, currentCellInfo.rowIndex);
            const minCol = Math.min(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);
            const maxCol = Math.max(dragSelectionStartCellInfo.colIndex, currentCellInfo.colIndex);

            const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
            allCellsInTable.forEach(cellElement => {
                const cellIterInfo = getCellInfoFromElement(cellElement);
                if (!cellIterInfo) return;

                const isInCurrentRect = cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol;
                
                let isSelectedInGlobalList = selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement);

                if (isInCurrentRect) {
                    if (!isSelectedInGlobalList) {
                        selectedCells.push(cellIterInfo);
                        cellElement.classList.add('cell-selected');
                        cellsAffectedByCurrentDrag.add(cellElement); // Marcar como afectada por ESTE arrastre
                    }
                } else {
                    // Si la celda est√° fuera del rect√°ngulo actual Y fue seleccionada por ESTE arrastre
                    if (isSelectedInGlobalList && cellsAffectedByCurrentDrag.has(cellElement)) {
                        const index = selectedCells.findIndex(sc => sc.tdElement === cellIterInfo.tdElement);
                        if (index > -1) selectedCells.splice(index, 1);
                        cellElement.classList.remove('cell-selected');
                        // No la quitamos de cellsAffectedByCurrentDrag, ya que su estado cambi√≥ debido a este arrastre
                    }
                }
            });
            updateMultiselectToolbar();
        }

        function handleDocumentTouchEnd(event) {
            const wasActuallyDragging = isDraggingToSelect;
            if (isDraggingToSelect) {
                isDraggingToSelect = false;
            }

            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (!wasActuallyDragging && !wasLongPress && touchstartTarget) {
                const cellInfo = getCellInfoFromElement(touchstartTarget);
                if (cellInfo) {
                    const deltaX = Math.abs(event.changedTouches[0].clientX - touchstartX);
                    const deltaY = Math.abs(event.changedTouches[0].clientY - touchstartY);
                    if (deltaX <= MAX_TOUCH_MOVE_THRESHOLD && deltaY <= MAX_TOUCH_MOVE_THRESHOLD) {
                        const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                        if (!SHIFT_TYPES.includes(currentValue)) {
                             processCellClick(cellInfo, false, false, true);
                        } else {
                            processCellClick(cellInfo, false, false, true);
                        }
                    }
                }
            }

            touchstartTarget = null;
            touchstartTime = 0;
            dragSelectionStartCellInfo = null;
            lastCellOverForDragSelectInfo = null;
        }


        // --- CONFIGURACI√ìN DE EVENT LISTENERS ---
        
        // Dentro de tu archivo JavaScript
        
        function setupEventListeners() {
            // --- Listeners Existentes (DEBES MANTENER LOS QUE YA TEN√çAS Y FUNCIONABAN) ---
            if (domCache.csvFileInput) {
                domCache.csvFileInput.addEventListener('change', handleFileUpload);
            }
            if (domCache.yearInput) {
                domCache.yearInput.addEventListener('change', handleYearChange);
            }
            if (domCache.saveLocalButton) {
                domCache.saveLocalButton.addEventListener('click', () => saveScheduleToLocalStorage(false));
            }
            if (domCache.exportCsvButton) {
                domCache.exportCsvButton.addEventListener('click', prepareExportScheduleToCSV);
            }
            if (domCache.createEmptyCsvButton) {
                domCache.createEmptyCsvButton.addEventListener('click', handleCreateEmptyScheduleClick);
            }
            if (domCache.downloadImageButton) {
                domCache.downloadImageButton.addEventListener('click', () => prepareDownloadSvgOrPdf('monthlyAnnual'));
            }
            if (domCache.downloadWeeklySvgButton) {
                domCache.downloadWeeklySvgButton.addEventListener('click', () => prepareDownloadSvgOrPdf('weekly'));
            }
            if (domCache.exportMonthCalendarButton) {
                domCache.exportMonthCalendarButton.addEventListener('click', showExportToCalendarModal);
            }
            if (domCache.viewMonthlyButton) {
                domCache.viewMonthlyButton.addEventListener('click', () => switchViewMode('monthly'));
            }
            if (domCache.viewAnnualButton) {
                domCache.viewAnnualButton.addEventListener('click', () => switchViewMode('annual'));
            }
            if (domCache.autosaveToggle) { // Aseg√∫rate de que domCache.autosaveToggle est√© definido
                domCache.autosaveToggle.addEventListener('change', (event) => {
                    toggleAutosave(event.target.checked);
                });
            }
            if (domCache.saveLocalHelpIcon) { // Aseg√∫rate de que domCache.saveLocalHelpIcon est√© definido
                domCache.saveLocalHelpIcon.addEventListener('click', () => {
                    showModal(domCache.saveLocalHelpModal);
                });
            }
            
            // Listeners de la tabla de horario principal
            if (domCache.scheduleTableBody) {
                domCache.scheduleTableBody.addEventListener('dblclick', handleTableDblClick);
                domCache.scheduleTableBody.addEventListener('dragstart', handleDragStart);
                domCache.scheduleTableBody.addEventListener('dragover', handleDragOver);
                domCache.scheduleTableBody.addEventListener('dragleave', handleDragLeave);
                domCache.scheduleTableBody.addEventListener('drop', handleDrop);
                domCache.scheduleTableBody.addEventListener('dragend', handleDragEnd);
        
                domCache.scheduleTableBody.addEventListener('mousedown', handleCellMouseDown);
                // Nota: los listeners para mousemove y mouseup en 'document' se a√±aden una vez y no necesitan estar en domCache.
                // Ya los tienes en la gu√≠a original, aseg√∫rate de que est√©n fuera de esta funci√≥n si se a√±aden directamente a 'document'.
                // Si estaban dentro, mantenlos aqu√≠. Para este ejemplo, asumo que se a√±aden una vez globalmente.
        
                domCache.scheduleTableBody.addEventListener('touchstart', handleCellTouchStart, { passive: false });
                // Similarmente para touchmove y touchend en 'document'.
        
                domCache.scheduleTableBody.addEventListener('contextmenu', (event) => {
                    const targetCell = event.target.closest('td.shift-cell');
                    if (targetCell && selectedCells.length > 0) {
                        event.preventDefault();
                        clearSelection();
                        showToast('Selecci√≥n limpiada.', 'info', 1500);
                        return;
                    }
                    // La l√≥gica de wasLongPress para contextmenu puede ser compleja y propensa a errores,
                    // considera si es estrictamente necesaria o si el doble clic/pulsaci√≥n larga es suficiente.
                });
            }
        
            // Listener global para clics fuera de elementos (para cerrar paleta, limpiar selecci√≥n)
            document.addEventListener('mousedown', (event) => {
                if (activeColorPalette && !activeColorPalette.contains(event.target) &&
                    !event.target.closest('.legend-color-swatch')) {
                    closeColorPalette();
                }
                // L√≥gica para limpiar selecci√≥n si se hace clic fuera de la tabla/toolbar/modales
                const isClickOnTableBody = event.target.closest('#schedule-table-body');
                const isClickOnToolbar = event.target.closest('#multiselect-toolbar');
                const isClickOnModalContent = event.target.closest('.modal-content'); // Clase gen√©rica para tus modales
                const isClickOnLegendItem = event.target.closest('.legend-item-container'); // En el modal de leyenda
                const isClickOnControlsSection = event.target.closest('#controls-section');
                const isClickOnNewStatsSection = event.target.closest('#statistics-section');
                const isClickOnViewModeButtonsGroup = event.target.closest('#view-mode-buttons-group'); // Contenedor de botones de vista/leyenda/normas
                const isClickOnFooterButton = event.target.closest('#clear-local-storage-button'); // El nuevo bot√≥n
        
                if (!isClickOnTableBody && !isClickOnToolbar && !isClickOnModalContent && 
                    !isClickOnLegendItem && !isClickOnControlsSection && !isClickOnNewStatsSection &&
                    !isClickOnViewModeButtonsGroup && !isClickOnFooterButton && selectedCells.length > 0) {
                    clearSelection();
                }
            });
            
            // Listener para notas generales
            if (domCache.generalNotesTextarea) {
                domCache.generalNotesTextarea.addEventListener('input', () => {
                    hasUnsavedChanges = true;
                    updateUnsavedChangesIndicator();
                    if (Object.keys(scheduleData).length > 0 || domCache.generalNotesTextarea.value.trim()) {
                        if(domCache.saveLocalButton) domCache.saveLocalButton.disabled = false;
                    }
                    clearTimeout(notesDebounceTimer);
                    notesDebounceTimer = setTimeout(() => {
                        const lastUndoState = undoStack.length > 0 ? undoStack[undoStack.length - 1] : null;
                        if (!lastUndoState || lastUndoState.generalNotes !== domCache.generalNotesTextarea.value) {
                            // saveStateForUndo("Notas generales modificadas."); // Descomenta si quieres que cada cambio en notas sea un estado de deshacer
                        }
                    }, 1500);
                });
            }
        
            // --- Listeners para el modal de Normas ---
            if (domCache.personsPerShiftEnabledToggle) {
                domCache.personsPerShiftEnabledToggle.addEventListener('change', (event) => {
                    if (domCache.personsPerShiftSettingsInputs) {
                        domCache.personsPerShiftSettingsInputs.classList.toggle('hidden-by-default', !event.target.checked);
                    }
                    handleRuleInputChange();
                });
            }
            if (domCache.maxConsecutiveDaysEnabledToggle) {
                domCache.maxConsecutiveDaysEnabledToggle.addEventListener('change', (event) => {
                    if (domCache.maxConsecutiveDaysSettingsInputs) {
                        domCache.maxConsecutiveDaysSettingsInputs.classList.toggle('hidden-by-default', !event.target.checked);
                    }
                    handleRuleInputChange();
                });
            }
            const ruleInputs = [
                domCache.personsMorningMin, domCache.personsMorningMax,
                domCache.personsAfternoonMin, domCache.personsAfternoonMax,
                domCache.personsNightMin, domCache.personsNightMax,
                domCache.maxConsecutiveDaysInput
            ];
            ruleInputs.forEach(input => {
                if (input) {
                    input.addEventListener('input', handleRuleInputChange);
                }
            });
            if (domCache.saveRulesButton) {
                domCache.saveRulesButton.addEventListener('click', saveRulesConfigFromModal);
            }
        
            // --- Listeners para Modales (A√±adir Empleado, Borrar Empleado, Nombre de Archivo, etc.) ---
            // (Aseg√∫rate de que estos IDs y la l√≥gica coincidan con tu implementaci√≥n actual)
            if (domCache.modalConfirmAddEmployee) {
                domCache.modalConfirmAddEmployee.addEventListener('click', handleAddEmployeeFromModal);
            }
            if (domCache.modalCancelAddEmployee) {
                domCache.modalCancelAddEmployee.addEventListener('click', () => hideModal(domCache.addEmployeeModal));
            }
            if (domCache.addEmployeeModal) {
                domCache.addEmployeeModal.addEventListener('click', (event) => {
                    if (event.target === domCache.addEmployeeModal) hideModal(domCache.addEmployeeModal);
                });
            }
        
            if (domCache.modalConfirmDeleteEmployee) {
                domCache.modalConfirmDeleteEmployee.addEventListener('click', confirmEmployeeDeletion);
            }
            if (domCache.modalCancelDeleteEmployee) {
                domCache.modalCancelDeleteEmployee.addEventListener('click', () => hideModal(domCache.deleteEmployeeModal, () => {
                    if (deleteCountdownInterval) clearInterval(deleteCountdownInterval);
                    employeeToDeleteName = null; // Aseg√∫rate de que employeeToDeleteName est√© definido globalmente
                }));
            }
            if (domCache.deleteEmployeeModal) {
                domCache.deleteEmployeeModal.addEventListener('click', (event) => {
                    if (event.target === domCache.deleteEmployeeModal) hideModal(domCache.deleteEmployeeModal, () => {
                        if (deleteCountdownInterval) clearInterval(deleteCountdownInterval);
                        employeeToDeleteName = null;
                    });
                });
            }
        
            if (domCache.modalConfirmFilename) {
                domCache.modalConfirmFilename.addEventListener('click', handleFilenameConfirm);
            }
            if (domCache.modalCancelFilename) {
                domCache.modalCancelFilename.addEventListener('click', () => hideModal(domCache.filenameModal, () => {
                    currentFilenameConfirmCallback = null; currentFilenameExtension = ''; if(domCache.modalFilenameInput) domCache.modalFilenameInput.value = '';
                }));
            }
            if (domCache.filenameModal) {
                domCache.filenameModal.addEventListener('click', (event) => {
                    if (event.target === domCache.filenameModal) hideModal(domCache.filenameModal, () => {
                        currentFilenameConfirmCallback = null; currentFilenameExtension = ''; if(domCache.modalFilenameInput) domCache.modalFilenameInput.value = '';
                    });
                });
            }
            
            if (domCache.modalConfirmExportCalendar) {
                domCache.modalConfirmExportCalendar.addEventListener('click', () => {
                    const selectedEmployee = domCache.modalCalendarEmployeeSelect.value;
                    if (selectedEmployee) exportToCalendar(selectedEmployee);
                    else showToast('Por favor, selecciona un empleado para exportar.', 'error');
                    hideModal(domCache.exportCalendarModal, () => {
                        if(domCache.modalCalendarEmployeeSelect) domCache.modalCalendarEmployeeSelect.innerHTML = '';
                    });
                });
            }
            if (domCache.modalCancelExportCalendar) {
                domCache.modalCancelExportCalendar.addEventListener('click', () => hideModal(domCache.exportCalendarModal, () => {
                    if(domCache.modalCalendarEmployeeSelect) domCache.modalCalendarEmployeeSelect.innerHTML = '';
                }));
            }
            if (domCache.exportCalendarModal) {
                domCache.exportCalendarModal.addEventListener('click', (event) => {
                    if (event.target === domCache.exportCalendarModal) hideModal(domCache.exportCalendarModal, () => {
                        if(domCache.modalCalendarEmployeeSelect) domCache.modalCalendarEmployeeSelect.innerHTML = '';
                    });
                });
            }
        
            if (domCache.helpIconContainer) {
                domCache.helpIconContainer.addEventListener('click', () => {
                    showModal(domCache.tipsModal);
                });
            }
            if (domCache.closeTipsModalButton) {
                domCache.closeTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.okTipsModalButton) {
                domCache.okTipsModalButton.addEventListener('click', () => {
                    hideModal(domCache.tipsModal);
                });
            }
            if (domCache.tipsModal) {
                domCache.tipsModal.addEventListener('click', (event) => {
                    if (event.target === domCache.tipsModal) {
                        hideModal(domCache.tipsModal);
                    }
                });
            }
        
            if (domCache.modalConfirmCustomEvent) {
                domCache.modalConfirmCustomEvent.addEventListener('click', handleConfirmCustomEvent);
            }
            if (domCache.modalCancelCustomEvent) {
                domCache.modalCancelCustomEvent.addEventListener('click', hideCustomEventModal);
            }
            if (domCache.customEventModal) {
                domCache.customEventModal.addEventListener('click', (event) => {
                    if (event.target === domCache.customEventModal) {
                        hideCustomEventModal();
                    }
                });
            }
        
            if (domCache.modalConfirmLoadCsv) {
                domCache.modalConfirmLoadCsv.addEventListener('click', () => {
                    hideModal(domCache.confirmLoadCsvModal);
                    if (currentConfirmAction === 'applyEmptyTemplate') { // currentConfirmAction debe estar definido globalmente
                        applyEmptyScheduleTemplate();
                    } else {
                        // L√≥gica para cargar archivo CSV (ya la tienes)
                        const fileInput = domCache.csvFileInput;
                        if (fileInput && fileInput.files.length > 0) {
                            const file = fileInput.files[0];
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                try {
                                    const csvContent = e.target.result;
                                    parseCSV(csvContent);
                                    if (isDataLoadedForStats()) {
                                        if (file) {
                                            domCache.csvFileInput.dataset.uploadedFileName = file.name;
                                        }
                                        undoStack = []; redoStack = [];
                                        localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                                        localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
                                        updateUndoRedoButtonsState();
                                        populateMonthTabs();
                                        currentSelectedMonth = 1;
                                        hasUnsavedChanges = false;
                                        updateUnsavedChangesIndicator();
                                        enableControls(true);
                                        switchViewMode('monthly');
                                        initializeAndRenderNewStatistics();
                                        showToast('Horario cargado correctamente desde CSV.', 'success');
                                    } else {
                                        showToast('El CSV est√° vac√≠o o no tiene el formato esperado.', 'error');
                                        resetToInitialState();
                                    }
                                } catch (error) {
                                    console.error("Error al procesar el CSV (confirmado):", error);
                                    showToast(`Error al procesar el CSV: ${error.message}`, 'error');
                                    resetToInitialState();
                                } finally {
                                    fileInput.value = '';
                                }
                            };
                            reader.readAsText(file, 'UTF-8');
                        } else if (currentConfirmAction !== 'applyEmptyTemplate' && domCache.csvFileInput && domCache.csvFileInput.value) {
                             domCache.csvFileInput.value = '';
                        }
                    }
                    currentConfirmAction = null;
                });
            }
            if (domCache.modalCancelLoadCsv) {
                domCache.modalCancelLoadCsv.addEventListener('click', () => {
                    hideModal(domCache.confirmLoadCsvModal);
                    if(domCache.csvFileInput) domCache.csvFileInput.value = '';
                    currentConfirmAction = null;
                });
            }
            if (domCache.confirmLoadCsvModal) {
                domCache.confirmLoadCsvModal.addEventListener('click', (event) => {
                    if (event.target === domCache.confirmLoadCsvModal) {
                        hideModal(domCache.confirmLoadCsvModal);
                        if(domCache.csvFileInput) domCache.csvFileInput.value = '';
                        currentConfirmAction = null;
                    }
                });
            }
        
            if (domCache.closeSaveLocalHelpModalIcon) { // Aseg√∫rate de que domCache.closeSaveLocalHelpModalIcon est√© definido
                domCache.closeSaveLocalHelpModalIcon.addEventListener('click', () => {
                    hideModal(domCache.saveLocalHelpModal);
                });
            }
            if (domCache.closeSaveLocalHelpModalButton) { // Aseg√∫rate de que domCache.closeSaveLocalHelpModalButton est√© definido
                domCache.closeSaveLocalHelpModalButton.addEventListener('click', () => {
                    hideModal(domCache.saveLocalHelpModal);
                });
            }
            if (domCache.saveLocalHelpModal) { // Aseg√∫rate de que domCache.saveLocalHelpModal est√© definido
                domCache.saveLocalHelpModal.addEventListener('click', (event) => {
                    if (event.target === domCache.saveLocalHelpModal) {
                        hideModal(domCache.saveLocalHelpModal);
                    }
                });
            }
            
            // Listeners para la secci√≥n de estad√≠sticas (ya los tienes en setupNewStatisticsEventListeners)
            setupNewStatisticsEventListeners(); // Llama a tu funci√≥n existente
        
            if (domCache.modalConfirmFilenameStatsPdf) {
                domCache.modalConfirmFilenameStatsPdf.addEventListener('click', handleStatsPdfFilenameConfirm);
            }
            if (domCache.modalCancelFilenameStatsPdf) {
                domCache.modalCancelFilenameStatsPdf.addEventListener('click', hideStatsPdfFilenameModal);
            }
            if (domCache.filenameModalStatsPdf) {
                domCache.filenameModalStatsPdf.addEventListener('click', (event) => {
                    if (event.target === domCache.filenameModalStatsPdf) {
                        hideStatsPdfFilenameModal();
                    }
                });
            }
            if (domCache.exportStatsToPdfButton) {
                domCache.exportStatsToPdfButton.addEventListener('click', initiateStatsPdfExport);
            }
        
            if (domCache.footerHeartElement) {
                domCache.footerHeartElement.addEventListener('click', handleFooterHeartClick);
            }
        
            window.addEventListener('beforeunload', (event) => {
                if (hasUnsavedChanges) {
                    event.preventDefault();
                    event.returnValue = '';
                }
            });
        
            if (domCache.undoButton) {
                domCache.undoButton.addEventListener('click', undoChange);
            }
            if (domCache.redoButton) {
                domCache.redoButton.addEventListener('click', redoChange);
            }
            
            // Listeners para los botones de abrir modales de Leyenda y Normas (los que est√°n en la barra de navegaci√≥n)
            if (domCache.openLegendColorsModalButton) { 
                domCache.openLegendColorsModalButton.addEventListener('click', () => {
                    updateLegend(); // Actualiza el contenido del modal de leyenda antes de mostrarlo
                    const legendChanged = JSON.stringify(currentShiftColors) !== JSON.stringify(DEFAULT_SHIFT_COLORS) ||
                                          JSON.stringify(currentUserShiftTimes) !== JSON.stringify(DEFAULT_SHIFT_TIMES);
                    if(domCache.modalApplyColorsButton) domCache.modalApplyColorsButton.disabled = !legendChanged;
                    if(domCache.modalResetColorsButton) domCache.modalResetColorsButton.disabled = !legendChanged;
                    showModal(domCache.legendColorsModal);
                });
            }
            if (domCache.openRulesModalButton) { 
                domCache.openRulesModalButton.addEventListener('click', () => {
                    renderRulesModal(); // Actualiza el contenido del modal de normas antes de mostrarlo
                    validateAndDisplayRuleViolations(); // Muestra las violaciones actuales
                    showModal(domCache.rulesModal);
                });
            }
        
            // Listeners para los botones DENTRO del modal de Leyenda y Colores
            if (domCache.closeLegendColorsModalButton) {
                domCache.closeLegendColorsModalButton.addEventListener('click', () => hideModal(domCache.legendColorsModal));
            }
            if (domCache.modalOkLegendColorsButton) { // El bot√≥n "Cerrar" del modal de leyenda
                domCache.modalOkLegendColorsButton.addEventListener('click', () => hideModal(domCache.legendColorsModal));
            }
            if (domCache.legendColorsModal) { // Para cerrar al hacer clic fuera
                domCache.legendColorsModal.addEventListener('click', (event) => {
                    if (event.target === domCache.legendColorsModal) hideModal(domCache.legendColorsModal);
                });
            }
            if (domCache.modalApplyColorsButton) {
                domCache.modalApplyColorsButton.addEventListener('click', applyAndSaveColorsAndTimes);
            }
            if (domCache.modalResetColorsButton) {
                domCache.modalResetColorsButton.addEventListener('click', resetColorsAndTimes);
            }
        
            // Listeners para los botones DENTRO del modal de Normas
            if (domCache.closeRulesModalButton) {
                domCache.closeRulesModalButton.addEventListener('click', () => hideModal(domCache.rulesModal));
            }
            if (domCache.modalOkRulesButton) { // El bot√≥n "Cerrar" del modal de normas
                domCache.modalOkRulesButton.addEventListener('click', () => hideModal(domCache.rulesModal));
            }
            if (domCache.rulesModal) { // Para cerrar al hacer clic fuera
                domCache.rulesModal.addEventListener('click', (event) => {
                    if (event.target === domCache.rulesModal) hideModal(domCache.rulesModal);
                });
            }
            // El listener para domCache.saveRulesButton ya est√° a√±adido arriba con los inputs de las normas.
        
            // Listener global para teclas (Deshacer, Rehacer, Escape)
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey || event.metaKey) {
                    if (event.key === 'z' || event.key === 'Z') {
                        event.preventDefault();
                        if (domCache.undoButton && !domCache.undoButton.disabled) undoChange();
                    } else if (event.key === 'y' || event.key === 'Y') {
                        event.preventDefault();
                        if (domCache.redoButton && !domCache.redoButton.disabled) redoChange();
                    }
                } else if (event.key === 'Escape') {
                    // Cierra el modal activo. Esta l√≥gica debe ser robusta para manejar cualquier modal abierto.
                    // Ejemplo:
                    if (selectedCells.length > 0) clearSelection();
                    
                    const activeModals = document.querySelectorAll('.modal:not(.hidden-by-default)');
                    if (activeModals.length > 0) {
                        const topModal = activeModals[activeModals.length - 1]; // Cierra el m√°s visible
                        hideModal(topModal);
                        // Limpieza espec√≠fica si es el modal de borrado con cuenta atr√°s
                        if (topModal.id === 'confirm-clear-local-storage-modal' && clearLocalStorageCountdownInterval) {
                            clearInterval(clearLocalStorageCountdownInterval);
                            clearLocalStorageCountdownInterval = null;
                        }
                        if (topModal.id === 'delete-employee-modal' && deleteCountdownInterval) {
                             clearInterval(deleteCountdownInterval);
                             employeeToDeleteName = null;
                        }
                        // A√±ade aqu√≠ cualquier otra limpieza espec√≠fica de intervalo para otros modales si es necesario
                    }
                }
            });
        
            // --- NUEVOS LISTENERS PARA EL BOT√ìN DE BORRAR DATOS LOCALES ---
            if (domCache.clearLocalStorageButton) {
                domCache.clearLocalStorageButton.addEventListener('click', showConfirmClearLocalStorageModal);
            }
            if (domCache.modalConfirmClearLocalStorage) {
                domCache.modalConfirmClearLocalStorage.addEventListener('click', handleConfirmClearLocalStorage);
            }
            if (domCache.modalCancelClearLocalStorage) {
                domCache.modalCancelClearLocalStorage.addEventListener('click', () => {
                    hideModal(domCache.confirmClearLocalStorageModal);
                    if (clearLocalStorageCountdownInterval) {
                        clearInterval(clearLocalStorageCountdownInterval);
                        clearLocalStorageCountdownInterval = null;
                    }
                });
            }
            if (domCache.confirmClearLocalStorageModal) {
                domCache.confirmClearLocalStorageModal.addEventListener('click', (event) => {
                    if (event.target === domCache.confirmClearLocalStorageModal) {
                        hideModal(domCache.confirmClearLocalStorageModal);
                        if (clearLocalStorageCountdownInterval) {
                            clearInterval(clearLocalStorageCountdownInterval);
                            clearLocalStorageCountdownInterval = null;
                        }
                    }
                });
            }
            // El listener para Escape ya deber√≠a cubrir el nuevo modal si usas la l√≥gica de `activeModals`.
             document.addEventListener('mousemove', handleDocumentMouseMove);
             document.addEventListener('mouseup', handleDocumentMouseUp);
             document.addEventListener('touchmove', handleDocumentTouchMove, { passive: false });
             document.addEventListener('touchend', handleDocumentTouchEnd);
        }
        


        // --- INICIALIZACI√ìN ---
        document.addEventListener('DOMContentLoaded', () => {
            cacheDOMElements();
            if (domCache.logoContainer) {
                domCache.logoContainer.innerHTML = SVG_FINAL_LOGO_MARKUP;
            }
            setupEventListeners();
            loadYearFromLocalStorage();
            loadCustomColors();
            loadCustomShiftTimes();
			loadRulesConfigFromLocalStorage();
            updateLegend();
            loadChangeHistory();

            setupMultiselectToolbar();
            updateMultiselectToolbar();

			const dataLoaded = loadDataFromLocalStorage(); 
			if (dataLoaded) {
				handleViewChange(); 
				initializeAndRenderNewStatistics(); 
			} else {
				enableControls(false);
				renderAddEmployeeButtonInTable();
				initializeAndRenderNewStatistics(); 
			}

            renderChangeHistory();
            updateViewModeUI();
            updateCalendarExportButtonsState();
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState();

            const savedAutosaveState = localStorage.getItem(LOCAL_STORAGE_KEY_AUTOSAVE);
            if (savedAutosaveState !== null) {
                toggleAutosave(savedAutosaveState === 'true');
            } else {
                toggleAutosave(false);
            }

            // Inicializaci√≥n de la nueva secci√≥n de estad√≠sticas (se har√° con el JS espec√≠fico)
        });

        // --- MODALES ---
        function showModal(modalElement, elementToFocus = null) {
            if (!modalElement) return;
            modalElement.classList.remove('hidden-by-default');
            if (elementToFocus) {
                elementToFocus.focus();
                if (typeof elementToFocus.select === 'function') elementToFocus.select();
            }
        }

        function hideModal(modalElement, cleanupFunction = null) {
            if (!modalElement) return;
            modalElement.classList.add('hidden-by-default');
            if (typeof cleanupFunction === 'function') cleanupFunction();
        }

        function showCustomEventModal(title, initialText = "") {
            if (!domCache.customEventModal || !domCache.customEventModalTitle || !domCache.modalCustomEventInput) {
                console.error("Error: Elementos de la modal de evento personalizado no encontrados en domCache.");
                return;
            }
            domCache.customEventModalTitle.textContent = title;
            domCache.modalCustomEventInput.value = initialText;
            showModal(domCache.customEventModal, domCache.modalCustomEventInput);
        }

        function hideCustomEventModal() {
            if (!domCache.customEventModal) {
                console.error("Error: Modal de evento personalizado no encontrada en domCache.");
                return;
            }
            hideModal(domCache.customEventModal);
            cellsBeingEditedViaEventModal = [];
            isSingleCellEditViaModal = false;
            if (domCache.modalCustomEventInput) {
                domCache.modalCustomEventInput.value = "";
            }
        }

        function handleConfirmCustomEvent() {
            if (!domCache.modalCustomEventInput) {
                console.error("Error: Input de la modal de evento personalizado no encontrado.");
                return;
            }
            const newText = domCache.modalCustomEventInput.value.trim();

            if (newText.includes(',')) {
                showToast('El texto del evento no puede contener comas (,).', 'error');
                if (domCache.modalCustomEventInput) {
                    domCache.modalCustomEventInput.focus();
                }
                return;
            }

            let changesMadeCount = 0;
            let undoDescription = `Modificaci√≥n de ${cellsBeingEditedViaEventModal.length} celda(s) a '${newText === "" ? "Vac√≠o" : newText}'.`;

            if (cellsBeingEditedViaEventModal.length === 1) {
                const cellToEdit = cellsBeingEditedViaEventModal[0];
                const originalVal = cellToEdit.originalValue;
                undoDescription = `Evento de ${cellToEdit.employee} (${cellToEdit.day}/${SHORT_MONTH_NAMES[cellToEdit.month-1]}) cambiado de '${originalVal || "Vac√≠o"}' a '${newText || "Vac√≠o"}'.`;
            }

            if (cellsBeingEditedViaEventModal.some(cell => cell.originalValue !== newText)) {
                saveStateForUndo(undoDescription);
            }

            cellsBeingEditedViaEventModal.forEach((cellToEdit, index) => {
                const { tdElement, employee, month, day, originalValue } = cellToEdit;
                if (originalValue !== newText) {
                    if (!scheduleData[employee]) scheduleData[employee] = {};
                    if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
                    scheduleData[employee][month][day] = newText;
                    tdElement.textContent = newText;
                    applyShiftCellStyles(tdElement, newText);
                    changesMadeCount++;
                }
            });

            if (changesMadeCount > 0) {
            }
            hideCustomEventModal();
			initializeAndRenderNewStatistics();
            if (isSingleCellEditViaModal) {
                clearSelection();
            }
        }


        // --- OTRAS FUNCIONES DE UI ---
        function handleFooterHeartClick() {
            footerHeartClicks++;
        
            // 1. Animaci√≥n de palpitar al coraz√≥n
            if (domCache.footerHeartElement) {
                domCache.footerHeartElement.classList.add('corazon-palpitando');
                // Quitar la clase despu√©s de que la animaci√≥n termine para permitirla de nuevo
                setTimeout(() => {
                    if (domCache.footerHeartElement) { // Comprobar si todav√≠a existe
                        domCache.footerHeartElement.classList.remove('corazon-palpitando');
                    }
                }, 500); // 0.5s es la duraci√≥n de la animaci√≥n
            }
        
            // 2. L√≥gica del Easter Egg (cambio de nombre y confeti)
            if (footerHeartClicks === 10) {
                if (domCache.creatorNameElement) {
                    domCache.creatorNameElement.classList.add('hidden-name');
                    setTimeout(() => {
                        if (domCache.creatorNameElement) { // Comprobar si todav√≠a existe
                            domCache.creatorNameElement.textContent = 'Scrulius';
                            domCache.creatorNameElement.classList.remove('hidden-name');
                            domCache.creatorNameElement.classList.add('visible-name');
                        }
                        showToast('‚ú® ¬°Easter egg activado! ‚ú®', 'success');
        
                        // === INICIO DE LA MODIFICACI√ìN: Usar canvas-confetti ===
                        if (typeof confetti === 'function') {
                            confetti({
                                particleCount: 1500, // Cantidad de part√≠culas
                                spread: 100,        // Qu√© tanto se dispersan horizontalmente
                                origin: { y: 0.6 }, // Origen del confeti (0.6 es un poco abajo del centro vertical)
                                angle: 90,          // √Ångulo de lanzamiento (90 es hacia arriba)
                                startVelocity: 45,  // Velocidad inicial
                                zIndex: 9999        // Asegurar que est√© por encima
                            });
        
                            // Puedes a√±adir m√°s efectos si quieres, por ejemplo, desde los lados:
                            confetti({
                                particleCount: 70,
                                angle: 60,
                                spread: 55,
                                origin: { x: 0, y: 0.7 }, // Desde la izquierda
                                zIndex: 9999
                            });
                            confetti({
                                particleCount: 70,
                                angle: 120,
                                spread: 55,
                                origin: { x: 1, y: 0.7 }, // Desde la derecha
                                zIndex: 9999
                            });
                        }
                        // === FIN DE LA MODIFICACI√ìN ===
        
                    }, 500);
                }
            } else if (footerHeartClicks > 10) {
                // Opcional: si quieres que el confeti se lance cada vez que se hace clic despu√©s de activado
                if (typeof confetti === 'function') {
                    confetti({
                        particleCount: 50,
                        spread: 100,
                        origin: { y: Math.random() * 0.4 + 0.3 }, // Origen Y aleatorio
                        angle: Math.random() * 60 + 60,        // √Ångulo aleatorio
                        startVelocity: 30,
                        zIndex: 9999
                    });
                }
            }
        }
        

        function loadYearFromLocalStorage() {
            const savedYear = localStorage.getItem(LOCAL_STORAGE_KEY_YEAR);
            if (savedYear && !isNaN(parseInt(savedYear))) {
                yearOfSchedule = parseInt(savedYear);
            } else {
                yearOfSchedule = new Date().getFullYear();
            }
            domCache.yearInput.value = yearOfSchedule;
        }

        function handleYearChange(event) {
            const newYear = parseInt(event.target.value);
            if (!isNaN(newYear) && newYear > 1900 && newYear < 2200 && newYear !== yearOfSchedule) {
                yearOfSchedule = newYear;
                localStorage.setItem(LOCAL_STORAGE_KEY_YEAR, yearOfSchedule.toString());
                hasUnsavedChanges = true;
                updateUnsavedChangesIndicator();

                if (isDataLoadedForStats()) {
                    handleViewChange();
                    initializeAndRenderNewStatistics();
                }
                showToast(`A√±o del horario actualizado a ${yearOfSchedule}.`, 'info');
            } else if (newYear === yearOfSchedule) {
                // No action
            } else {
                event.target.value = yearOfSchedule;
                showToast('Por favor, introduce un a√±o v√°lido (ej. 2024).', 'error');
            }
        }

        function addChangeToHistory(description) {
            const newChange = { timestamp: new Date(), description: description };
            changeHistory.unshift(newChange);
            if (changeHistory.length > MAX_HISTORY_ITEMS) changeHistory.pop();
            renderChangeHistory();
        }


        function renderChangeHistory() {
            domCache.changeHistoryList.innerHTML = '';
            if (changeHistory.length === 0) {
                domCache.changeHistoryList.appendChild(createElement('li', {
                    textContent: 'No hay cambios recientes.', className: 'text-center text-gray-400'
                }));
                return;
            }
            changeHistory.forEach(change => {
                const timeSpan = createElement('span', {
                    className: 'history-time', textContent: `[${new Date(change.timestamp).toLocaleTimeString('es-ES')}]`
                });
                domCache.changeHistoryList.appendChild(createElement('li', {}, [ timeSpan, ` ${change.description}` ]));
            });
        }

        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA loadChangeHistory ---
        function loadChangeHistory() {
            const compressedHistoryString = localStorage.getItem(LOCAL_STORAGE_KEY_HISTORY);
            const savedHistory = decompressData(compressedHistoryString, "changeHistory");

            if (Array.isArray(savedHistory)) {
                try {
                    changeHistory = savedHistory.map(item => ({ // changeHistory debe estar definido
                        ...item,
                        timestamp: new Date(item.timestamp) // Re-hidratar las fechas
                    }));
                } catch (e) {
                    console.error("Error al procesar timestamps del historial (post-descompresi√≥n):", e);
                    changeHistory = [];
                }
            } else {
                if (savedHistory !== null) { // Si no es un array pero tampoco es null (error de parseo/descompresi√≥n)
                    console.warn("Historial de cambios cargado no es un array, usando historial vac√≠o.");
                }
                changeHistory = [];
            }
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA loadChangeHistory ---

        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA loadCustomColors ---
        function loadCustomColors() {
            const compressedColorsString = localStorage.getItem(LOCAL_STORAGE_KEY_COLORS);
            let parsedColors = null;
            let useDefaults = true; // Asumir que usaremos los por defecto inicialmente
        
            if (compressedColorsString) {
                parsedColors = decompressData(compressedColorsString, "customColors");
                if (parsedColors) {
                    let validStructure = true;
                    const keysToValidate = [...SHIFT_TYPES, 'empty']; // SHIFT_TYPES debe estar definido
        
                    for (const type of keysToValidate) {
                        if (!parsedColors[type] || 
                            typeof parsedColors[type].bg !== 'string' || 
                            typeof parsedColors[type].text !== 'string' ||
                            typeof parsedColors[type].hexBg !== 'string' || 
                            typeof parsedColors[type].hexText !== 'string') {
                            validStructure = false;
                            console.warn(`Estructura de color inv√°lida para el tipo '${type}' en localStorage. Faltan propiedades o tipos incorrectos.`);
                            break; 
                        }
                    }
        
                    if (validStructure) {
                        // Comprobaci√≥n adicional: ¬øLos colores para M y M2 est√°n invertidos en lo que se carg√≥?
                        // Esto es una heur√≠stica basada en el problema que estamos viendo.
                        // Comparamos si el hexBg de M en localStorage es el hexBg de M2 por defecto, y viceversa.
                        const mIsActuallyM2 = parsedColors.M && DEFAULT_SHIFT_COLORS.M2 && parsedColors.M.hexBg === DEFAULT_SHIFT_COLORS.M2.hexBg;
                        const m2IsActuallyM = parsedColors.M2 && DEFAULT_SHIFT_COLORS.M && parsedColors.M2.hexBg === DEFAULT_SHIFT_COLORS.M.hexBg;
        
                        if (mIsActuallyM2 && m2IsActuallyM) {
                            console.warn("Detectada posible inversi√≥n de colores M/M2 en localStorage. Forzando colores por defecto.");
                            // No establecemos useDefaults a false, as√≠ que se usar√°n los por defecto.
                        } else {
                            currentShiftColors = parsedColors;
                            useDefaults = false; // Los datos cargados son v√°lidos y no parecen invertidos
                            console.log("Colores personalizados cargados y validados desde localStorage.");
                        }
                    } else {
                        console.warn("Formato de colores guardados inv√°lido (post-descompresi√≥n), usando por defecto.");
                        // No establecemos useDefaults a false.
                    }
                } else {
                    // decompressData devolvi√≥ null (error de descompresi√≥n/parseo o no hab√≠a nada)
                    console.warn("No se encontraron colores personalizados o error al cargar/descomprimir, usando por defecto.");
                    // No establecemos useDefaults a false.
                }
            }
        
            if (useDefaults) {
                console.log("Usando DEFAULT_SHIFT_COLORS para inicializar currentShiftColors.");
                currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            }
        
            // L√≥gica de fallback para asegurar que todos los colores tengan hexBg y hexText
            // (esta parte es importante si alguna definici√≥n en DEFAULT_SHIFT_COLORS fuera incompleta,
            // o si se cargara un parsedColors parcial y v√°lido que pasara la validaci√≥n anterior)
            Object.keys(currentShiftColors).forEach(key => {
                if (!currentShiftColors[key] || !currentShiftColors[key].hexBg || !currentShiftColors[key].hexText) {
                    console.warn(`Color '${key}' en currentShiftColors no tiene hexBg o hexText. Aplicando fallback.`);
                    const defaultColorForKey = DEFAULT_SHIFT_COLORS[key] || DEFAULT_SHIFT_COLORS.empty;
                    const foundColor = AVAILABLE_COLORS.find(c => c.bg === (currentShiftColors[key]?.bg || defaultColorForKey.bg)) ||
                                     AVAILABLE_COLORS.find(c => c.bg === defaultColorForKey.bg) ||
                                     AVAILABLE_COLORS.find(c => c.hexBg === DEFAULT_SHIFT_COLORS.empty.hexBg) || // Fallback al 'empty' por defecto
                                     { hexBg: '#ffffff', hexText: '#000000' }; // √öltimo recurso
        
                    if (!currentShiftColors[key]) currentShiftColors[key] = {}; // Asegurar que el objeto exista
                    currentShiftColors[key].hexBg = foundColor.hexBg;
                    currentShiftColors[key].hexText = foundColor.hexText;
                    if (!currentShiftColors[key].bg) currentShiftColors[key].bg = foundColor.bg;
                    if (!currentShiftColors[key].text) currentShiftColors[key].text = foundColor.text;
                }
            });
             console.log("Estado final de currentShiftColors despu√©s de loadCustomColors:", JSON.parse(JSON.stringify(currentShiftColors)));
        }
        

        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA loadCustomShiftTimes ---
        function loadCustomShiftTimes() {
            const compressedTimesString = localStorage.getItem(LOCAL_STORAGE_KEY_SHIFT_TIMES);
            const parsedTimes = decompressData(compressedTimesString, "customShiftTimes");

            if (parsedTimes) {
                let valid = true;
                Object.keys(DEFAULT_SHIFT_TIMES).forEach(type => { // DEFAULT_SHIFT_TIMES debe estar definido
                    if (!parsedTimes[type] || !Array.isArray(parsedTimes[type].start) || parsedTimes[type].start.length !== 2 ||
                        !Array.isArray(parsedTimes[type].end) || parsedTimes[type].end.length !== 2 ||
                        typeof parsedTimes[type].nextDayEnd !== 'boolean') {
                        valid = false;
                    }
                });
                if (valid) {
                    currentUserShiftTimes = parsedTimes; // currentUserShiftTimes debe estar definido
                } else {
                    console.warn("Formato de horarios de turno inv√°lido (post-descompresi√≥n), usando por defecto.");
                    currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
                }
            } else {
                console.warn("No se encontraron horarios de turno personalizados o error al cargar, usando por defecto.");
                currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            }
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA loadCustomShiftTimes ---

        function applyAndSaveColorsAndTimes() {
            localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, JSON.stringify(currentShiftColors));
            localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, JSON.stringify(currentUserShiftTimes));
        
            // Efecto visual flash (opcional, pero estaba en tu c√≥digo)
            if (domCache.legendItemsContainer) { // Verificar que el contenedor exista
                const legendItems = domCache.legendItemsContainer.querySelectorAll('.legend-item-container');
                legendItems.forEach(item => {
                    item.classList.add('legend-item-flash');
                    setTimeout(() => item.classList.remove('legend-item-flash'), 700);
                });
            }
        
            updateLegend(); // Re-renderiza la leyenda con los nuevos colores/tiempos aplicados
            handleViewChange(); // Re-renderiza la tabla de horario para reflejar los cambios de color
            initializeAndRenderNewStatistics(); // Re-renderiza estad√≠sticas que puedan depender de colores/tiempos
            showToast('Colores y horarios de turno aplicados y guardados.', 'success');
        
            if (domCache.modalApplyColorsButton) domCache.modalApplyColorsButton.disabled = true;
            // El bot√≥n de restaurar se habilita porque ahora los colores/tiempos son diferentes de los defecto (o podr√≠an serlo)
            if (domCache.modalResetColorsButton) domCache.modalResetColorsButton.disabled = false;
        
            hasUnsavedChanges = true; // Los cambios en leyenda/colores cuentan como cambios no guardados
            updateUnsavedChangesIndicator();
            saveStateForUndo("Colores y horarios de leyenda modificados.");
        }

        function resetColorsAndTimes() {
            currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            localStorage.removeItem(LOCAL_STORAGE_KEY_COLORS); 
            localStorage.removeItem(LOCAL_STORAGE_KEY_SHIFT_TIMES); 
        
            updateLegend(); 
            handleViewChange(); 
            initializeAndRenderNewStatistics();
            showToast('Colores y horarios de turno restaurados a los valores por defecto.', 'info');
        
            // Despu√©s de restaurar, no hay cambios pendientes respecto a los defecto para "Aplicar"
            if (domCache.modalApplyColorsButton) domCache.modalApplyColorsButton.disabled = true; 
            // Y como son los defecto, el bot√≥n "Restaurar" tambi√©n se deshabilita
            if (domCache.modalResetColorsButton) domCache.modalResetColorsButton.disabled = true;
        
            hasUnsavedChanges = true; 
            updateUnsavedChangesIndicator();
            saveStateForUndo("Colores y horarios de leyenda restaurados a defecto.");
        }


        function formatTimeForInput(hours, minutes) {
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function updateLegend() {
            if (!domCache.legendItemsContainer) return; // Comprobaci√≥n de seguridad
            domCache.legendItemsContainer.innerHTML = '';
            const relevantShiftTypesForTimeInput = ['M', 'T', 'N', 'M2', 'T2', 'N2'];
            const legendOrder = ['M', 'T', 'N', 'M2', 'T2', 'N2', 'L', 'V', 'B', 'empty'];
        
            legendOrder.forEach(type => {
                const colorInfo = currentShiftColors[type];
                if (!colorInfo) {
                    console.warn(`Color configuration for shift type "${type}" not found in currentShiftColors.`);
                    return;
                }
        
                const legendItemDiv = createElement('div', { className: 'legend-item-container' });
        
                const swatch = createElement('span', {
                    className: `legend-color-swatch ${colorInfo.bg}`,
                    dataset: { shiftType: type },
                    title: `Cambiar color para ${type === 'empty' ? 'Otro' : (SHIFT_TYPE_FULL_NAMES[type] || type)}`
                });
                swatch.addEventListener('click', (event) => openColorPalette(event, type));
        
                const labelText = type === 'empty' ? 'Otro' : `${SHIFT_TYPE_FULL_NAMES[type] || type} (${type === 'empty' ? '' : type})`;
                const label = createElement('span', { textContent: labelText, className: 'mr-2 text-sm' }); // Aseg√∫rate que la clase text-sm est√© si la quieres
        
                legendItemDiv.appendChild(swatch);
                legendItemDiv.appendChild(label);
        
                if (relevantShiftTypesForTimeInput.includes(type)) {
                    const timeConfig = currentUserShiftTimes[type] || DEFAULT_SHIFT_TIMES[type];
                    if (timeConfig && timeConfig.start && timeConfig.end) {
                        const timeInputsDiv = createElement('div', { className: 'legend-time-inputs' });
        
                        const startTimeInput = createElement('input', {
                            attributes: { type: 'time', value: formatTimeForInput(timeConfig.start[0], timeConfig.start[1])},
                            dataset: { shiftType: type, timeType: 'start' }
                        });
                        const endTimeInput = createElement('input', {
                            attributes: { type: 'time', value: formatTimeForInput(timeConfig.end[0], timeConfig.end[1])},
                            dataset: { shiftType: type, timeType: 'end' }
                        });
        
                        startTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);
                        endTimeInput.addEventListener('change', handleShiftTimeChangeInLegend);
        
                        timeInputsDiv.appendChild(startTimeInput);
                        timeInputsDiv.appendChild(createElement('span', {textContent: '-', className: 'mx-1'}));
                        timeInputsDiv.appendChild(endTimeInput);
                        legendItemDiv.appendChild(timeInputsDiv);
                    } else {
                         console.warn(`Time configuration for shift type "${type}" not found or incomplete.`);
                    }
                }
                domCache.legendItemsContainer.appendChild(legendItemDiv);
            });
        }

        function handleShiftTimeChangeInLegend(event) {
            const input = event.target;
            const shiftType = input.dataset.shiftType;
            const timeType = input.dataset.timeType; // 'start' o 'end'
            const [hours, minutes] = input.value.split(':').map(Number);
        
            if (!currentUserShiftTimes[shiftType]) {
                // Si por alguna raz√≥n no existe, inicializarlo desde los defaults
                currentUserShiftTimes[shiftType] = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES[shiftType] || { start: [0,0], end: [0,0], nextDayEnd: false }));
            }
        
            if (timeType === 'start') {
                currentUserShiftTimes[shiftType].start = [hours, minutes];
            } else { // 'end'
                currentUserShiftTimes[shiftType].end = [hours, minutes];
            }
        
            // L√≥gica simple para nextDayEnd: si la hora de fin es menor que la de inicio, asumir que es del d√≠a siguiente.
            const startTimeInMinutes = currentUserShiftTimes[shiftType].start[0] * 60 + currentUserShiftTimes[shiftType].start[1];
            const endTimeInMinutes = currentUserShiftTimes[shiftType].end[0] * 60 + currentUserShiftTimes[shiftType].end[1];
            currentUserShiftTimes[shiftType].nextDayEnd = endTimeInMinutes < startTimeInMinutes;
        
            // Habilitar botones en el modal ya que ha habido un cambio
            if (domCache.modalApplyColorsButton) domCache.modalApplyColorsButton.disabled = false;
            if (domCache.modalResetColorsButton) domCache.modalResetColorsButton.disabled = false;
            // No marcamos hasUnsavedChanges aqu√≠, se har√° al pulsar "Aplicar Cambios".
        }


        
        function openColorPalette(event, shiftTypeToEdit) {
            event.stopPropagation();
            closeColorPalette(); 
        
            const swatchElement = event.target; 
            const swatchRect = swatchElement.getBoundingClientRect(); // Coordenadas relativas al viewport
            activeColorPalette = createElement('div', { className: 'color-palette-popup' });
            // El CSS ahora tiene position: fixed para .color-palette-popup
        
            AVAILABLE_COLORS.forEach((colorOption) => {
                const paletteSwatch = createElement('div', {
                    className: `palette-color-swatch ${colorOption.bg}`,
                    title: colorOption.name
                });
                paletteSwatch.addEventListener('click', () => {
                    currentShiftColors[shiftTypeToEdit] = {
                        bg: colorOption.bg,
                        text: colorOption.text,
                        name: colorOption.name,
                        hexBg: colorOption.hexBg || tailwindColorToHex(colorOption.bg),
                        hexText: colorOption.hexText || tailwindColorToHex(colorOption.text, true)
                    };
                    swatchElement.className = `legend-color-swatch ${colorOption.bg}`;
                    closeColorPalette();
                    if (domCache.modalApplyColorsButton) domCache.modalApplyColorsButton.disabled = false;
                    if (domCache.modalResetColorsButton) domCache.modalResetColorsButton.disabled = false;
                });
                activeColorPalette.appendChild(paletteSwatch);
            });
        
            if (domCache.colorPalettePopupContainer) {
                domCache.colorPalettePopupContainer.innerHTML = ''; 
                domCache.colorPalettePopupContainer.appendChild(activeColorPalette);
            } else {
                document.body.appendChild(activeColorPalette); // Fallback
                console.warn("domCache.colorPalettePopupContainer no encontrado, paleta a√±adida a document.body.");
            }
        
            const paletteRect = activeColorPalette.getBoundingClientRect(); 
            // *** INICIO: CORRECCI√ìN DE POSICIONAMIENTO para position:fixed ***
            // Usar swatchRect directamente ya que son relativas al viewport
            let top = swatchRect.bottom + 5; // 5px de espacio debajo del swatch
            let left = swatchRect.left;
            // *** FIN: CORRECCI√ìN DE POSICIONAMIENTO ***
        
            // Ajustar si se sale de la pantalla (esto sigue siendo √∫til)
            if (left + paletteRect.width > window.innerWidth - 10) { 
                left = window.innerWidth - paletteRect.width - 10;
            }
            if (top + paletteRect.height > window.innerHeight - 10) {
                // Si se sale por abajo, intentar ponerla encima del swatch
                top = swatchRect.top - paletteRect.height - 5; 
            }
            // Asegurarse que no se salga por arriba
            top = Math.max(5, top); // 5px de margen superior m√≠nimo
            left = Math.max(5, left); // 5px de margen izquierdo m√≠nimo
        
            activeColorPalette.style.top = `${top}px`;
            activeColorPalette.style.left = `${left}px`;
        
            // Listener para el scroll DENTRO DEL MODAL
            if (domCache.legendColorsModal) {
                currentPaletteScrollListener = () => {
                    if (activeColorPalette) { 
                        closeColorPalette();
                    }
                };
                domCache.legendColorsModal.addEventListener('scroll', currentPaletteScrollListener, { once: true });
            }
        }
        

        function closeColorPalette() {
            if (activeColorPalette) {
                activeColorPalette.remove();
                activeColorPalette = null;
            }
            // *** INICIO: Correcci√≥n para el scroll de la paleta ***
            if (domCache.legendColorsModal && currentPaletteScrollListener) {
                domCache.legendColorsModal.removeEventListener('scroll', currentPaletteScrollListener);
                currentPaletteScrollListener = null; // Limpiar la referencia
            }
            // *** FIN: Correcci√≥n para el scroll de la paleta ***
        }

        function tailwindColorToHex(twClass, isTextClass = false) {
            const foundInAvailable = AVAILABLE_COLORS.find(c => c.bg === twClass || c.text === twClass);
            if (foundInAvailable) {
                return isTextClass ? (foundInAvailable.hexText || '#000000') : (foundInAvailable.hexBg || '#ffffff');
            }
            if (twClass === 'bg-white') return '#ffffff';
            if (twClass === 'text-black') return '#000000';
            return isTextClass ? '#000000' : '#ffffff';
        }

        function showToast(message, type = 'info', duration = 3500) {
            let iconClass = 'fas fa-info-circle', bgColorClass = 'bg-blue-500';
            if (type === 'success') { bgColorClass = 'bg-green-500'; iconClass = 'fas fa-check-circle'; }
            else if (type === 'error') { bgColorClass = 'bg-red-500'; iconClass = 'fas fa-times-circle'; }
            else if (type === 'warning') { bgColorClass = 'bg-yellow-500'; iconClass = 'fas fa-exclamation-triangle'; }

            const toast = createElement('div', {
                className: `flex items-center p-4 rounded-lg shadow-xl text-sm text-white ${bgColorClass} transition-opacity duration-300 opacity-0`,
                innerHTML: `<i class="${iconClass} mr-3 text-xl"></i><span>${message}</span>`
            });
            domCache.toastContainer.appendChild(toast);
            setTimeout(() => toast.classList.remove('opacity-0'), 50);
            setTimeout(() => {
                toast.classList.add('opacity-0');
                setTimeout(() => toast.remove(), 500);
            }, duration);
        }

        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA enableControls ---
        function enableControls(dataLoaded = true) {
            const disable = !dataLoaded;
            if(domCache.exportCsvButton) domCache.exportCsvButton.disabled = disable;
            if(domCache.downloadImageButton) domCache.downloadImageButton.disabled = disable;
            if (domCache.exportStatsToPdfButton) {
                domCache.exportStatsToPdfButton.disabled = !dataLoaded;
            }
        
            // El 'view-mode-buttons-group' ahora contiene los botones de leyenda/normas y los de vista.
            // Su visibilidad general (como parte de .schedule-navigation-bar) se controla
            // junto con 'scheduleDisplaySection'.
            // Lo que necesitamos es habilitar/deshabilitar los botones internos.
        
            if(domCache.viewMonthlyButton) domCache.viewMonthlyButton.disabled = disable;
            if(domCache.viewAnnualButton) domCache.viewAnnualButton.disabled = disable;
            if(domCache.saveLocalButton) domCache.saveLocalButton.disabled = !dataLoaded || !hasUnsavedChanges;
        
            updateCalendarExportButtonsState();
        
            if (dataLoaded) {
                if(domCache.welcomeMessage) domCache.welcomeMessage.classList.add('hidden-by-default');
                if(domCache.scheduleDisplaySection) domCache.scheduleDisplaySection.classList.remove('hidden-by-default');
                if(domCache.noDataMessage) domCache.noDataMessage.classList.add('hidden-by-default');
        
                // Mostrar/ocultar pesta√±as de mes seg√∫n la vista y si hay datos
                if (domCache.monthTabsWrapper) { // Usar el wrapper para controlar visibilidad
                    domCache.monthTabsWrapper.style.display = (currentViewMode === 'monthly' && dataLoaded) ? 'block' : 'none';
                }
        
            } else {
                if(domCache.welcomeMessage) domCache.welcomeMessage.classList.remove('hidden-by-default');
                if(domCache.scheduleDisplaySection) domCache.scheduleDisplaySection.classList.add('hidden-by-default');
                if(domCache.noDataMessage) domCache.noDataMessage.classList.remove('hidden-by-default');
        
                if (domCache.monthTabsWrapper) { // Ocultar wrapper de pesta√±as de mes
                     domCache.monthTabsWrapper.style.display = 'none';
                }
            }
        
            // Habilitar/deshabilitar los nuevos botones de Leyenda y Normas en la barra de navegaci√≥n
            if (domCache.openLegendColorsModalButton) { // Este ahora es open-legend-colors-modal-button-nav
                domCache.openLegendColorsModalButton.disabled = !dataLoaded;
            }
            if (domCache.openRulesModalButton) { // Este ahora es open-rules-modal-button-nav
                domCache.openRulesModalButton.disabled = !dataLoaded;
            }
            // El div 'modal-triggers-container' original ya no existe, por lo que no es necesario controlar su visibilidad.
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA enableControls ---
        

        function isDataLoadedForSave() {
            return Object.keys(scheduleData).length > 0 || employeeNamesOrdered.length > 0 || domCache.generalNotesTextarea.value.trim();
        }
        function isDataLoadedForStats() { // General check if any data is loaded for the app
            return Object.keys(scheduleData).length > 0 && employeeNamesOrdered.length > 0;
        }

        function generateDefaultFilename(context, sourceFileName = null) {
            let baseName = "horario";
            const currentMonthNameSafe = MONTH_NAMES[currentSelectedMonth - 1].toLowerCase().replace(/\s+/g, '_');
            const year = yearOfSchedule;

            switch (context) {
                case 'csv':
                    if (sourceFileName === TEMPLATE_FLAG_FILENAME) {
                        baseName = `horario_plantilla_${year}`;
                    } else if (sourceFileName && typeof sourceFileName === 'string' && sourceFileName.lastIndexOf('.') > 0 && sourceFileName.lastIndexOf('.') < sourceFileName.length - 1) {
                        baseName = `${sourceFileName.substring(0, sourceFileName.lastIndexOf('.'))}_${year}`;
                    } else {
                        if (sourceFileName) {
                             showToast('Nombre de archivo original no v√°lido, usando nombre gen√©rico para CSV.', 'warning');
                        }
                        if (isDataLoadedForStats()) {
                            baseName = `horario_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}_exportado`;
                        } else {
                            baseName = `horario_vacio_${year}_exportado`;
                        }
                    }
                    break;
                case 'pdfWeekly': baseName += `_semanal_${currentMonthNameSafe}_${year}`; break;
                case 'pdfMonthly': baseName += `_mensual_${currentMonthNameSafe}_${year}`; break;
                case 'pdfAnnual': baseName += `_anual_${year}`; break;
                case 'calendar':
                    baseName += `_calendar_${sourceFileName ? sourceFileName.toLowerCase().replace(/\s+/g, '_') : 'empleado'}_${currentMonthNameSafe}_${year}`;
                    break;
                default:
                     if (isDataLoadedForStats()) {
                        baseName += `_${currentViewMode === 'monthly' ? currentMonthNameSafe : 'anual'}_${year}`;
                    }
            }
            return baseName.replace(/[^a-z0-9_-]/gi, '_').replace(/_{2,}/g, '_');
        }

        // --- MANEJO DE ARCHIVOS Y DATOS ---
        function handleCreateEmptyScheduleClick() {
            if (isDataLoadedForSave() || hasUnsavedChanges) {
                currentConfirmAction = 'applyEmptyTemplate';
                domCache.confirmLoadCsvMessage.textContent = "Ya hay un horario cargado. Si aplicas una plantilla vac√≠a, el horario actual ser√° reemplazado. ¬øDeseas continuar?";
                showModal(domCache.confirmLoadCsvModal);
            } else {
                applyEmptyScheduleTemplate();
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                if (isDataLoadedForSave() || hasUnsavedChanges) {
                    currentConfirmAction = 'loadFile';
                    domCache.confirmLoadCsvMessage.textContent = hasUnsavedChanges ?
                        "Ya hay un horario cargado con cambios sin guardar. Si cargas un nuevo archivo CSV, estos cambios se perder√°n. ¬øDeseas continuar?" :
                        "Ya hay un horario cargado. Si cargas un nuevo archivo CSV, el horario actual ser√° reemplazado. ¬øDeseas continuar?";
                    showModal(domCache.confirmLoadCsvModal);
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csvContent = e.target.result;
                        parseCSV(csvContent);

						if (isDataLoadedForStats()) {
							if (file) {
								domCache.csvFileInput.dataset.uploadedFileName = file.name;
							}
							undoStack = [];
							redoStack = [];
							localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
							localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
							updateUndoRedoButtonsState();
							populateMonthTabs();
							currentSelectedMonth = 1; 
							hasUnsavedChanges = false; 
							updateUnsavedChangesIndicator();
							enableControls(true);
							switchViewMode('monthly'); 
							initializeAndRenderNewStatistics(); 
							showToast('Horario cargado correctamente desde CSV.', 'success');
						} else {
							showToast('El CSV est√° vac√≠o o no tiene el formato esperado.', 'error');
							resetToInitialState();
						}
                    } catch (error) {
                        console.error("Error al procesar el CSV:", error);
                        showToast(`Error al procesar el CSV: ${error.message}`, 'error');
                        resetToInitialState();
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file, 'UTF-8');
            }
        }

        /**
         * Resetea el estado de la aplicaci√≥n en memoria y la interfaz de usuario a un estado inicial.
         * NO borra localStorage aqu√≠, ya que se asume que eso se maneja antes de llamar a esta funci√≥n
         * en el contexto de "Borrar Datos Locales".
         * @param {boolean} keepNotes - Si es true, las notas generales no se borran del textarea.
         */
        function resetToInitialState(keepNotes = false) {
            // Resetear pilas de Deshacer/Rehacer
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtonsState(); // Actualiza la UI de los botones
        
            // Resetear datos principales del horario
            scheduleData = {};
            employeeNamesOrdered = [];
            hasUnsavedChanges = false;
            updateUnsavedChangesIndicator();
        
            // Resetear vista y a√±o
            currentSelectedMonth = new Date().getMonth() + 1;
            yearOfSchedule = new Date().getFullYear();
            if (domCache.yearInput) { // Comprobar si el elemento existe antes de usarlo
                domCache.yearInput.value = yearOfSchedule;
            }
            
            clearSelection(); // Limpia cualquier celda seleccionada
        
            if (domCache.csvFileInput) { // Comprobar si el elemento existe
                 domCache.csvFileInput.value = ''; // Limpiar el input de archivo
                 delete domCache.csvFileInput.dataset.uploadedFileName;
            }
        
            // Actualizar UI general (deshabilitar controles, mostrar mensaje de bienvenida)
            enableControls(false); // Esta funci√≥n deber√≠a manejar la visibilidad de secciones
        
            // Limpiar elementos espec√≠ficos de la UI del horario
            if (domCache.monthTabsContainer) domCache.monthTabsContainer.innerHTML = '';
            if (domCache.scheduleTableHead) domCache.scheduleTableHead.innerHTML = ''; 
            if (domCache.scheduleTableBody) domCache.scheduleTableBody.innerHTML = '';
            if (domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes A√±o]';
        
            // Resetear notas si no se indica mantenerlas
            if (!keepNotes && domCache.generalNotesTextarea) {
                domCache.generalNotesTextarea.value = '';
            }
        
            // Resetear configuraci√≥n de colores y tiempos de turno a los por defecto
            currentShiftColors = JSON.parse(JSON.stringify(DEFAULT_SHIFT_COLORS));
            currentUserShiftTimes = JSON.parse(JSON.stringify(DEFAULT_SHIFT_TIMES));
            updateLegend(); // Actualiza la UI de la leyenda
            // El estado de los botones del modal de leyenda se gestionar√° cuando se abra.
        
            // Resetear configuraci√≥n de normas a los por defecto
            rulesConfig = getDefaultRulesConfig(); // Asumiendo que tienes esta funci√≥n
            // Si el modal de normas est√° abierto, podr√≠as querer actualizarlo aqu√≠ o al abrirlo.
            if (domCache.rulesModal && !domCache.rulesModal.classList.contains('hidden-by-default')) {
                renderRulesModal(); // Re-renderiza el modal de normas con los defaults
            }
            validateAndDisplayRuleViolations(); // Revalida normas (probablemente no habr√° violaciones)
        
        
            // Resetear estad√≠sticas
            initializeAndRenderNewStatistics(); // Esta funci√≥n deber√≠a manejar el reseteo de la UI de estad√≠sticas
        
            // Renderizar el bot√≥n de a√±adir empleado en la tabla vac√≠a
            renderAddEmployeeButtonInTable();
        
            // Asegurarse de que las secciones espec√≠ficas est√©n ocultas si enableControls(false) no lo hace todo
            if (domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.add('hidden');
            if (domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
            if (domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
        
            // Mostrar mensaje de bienvenida
            if (domCache.welcomeMessage) domCache.welcomeMessage.classList.remove('hidden-by-default');
            if (domCache.scheduleDisplaySection) domCache.scheduleDisplaySection.classList.add('hidden-by-default');
        
            console.log("Estado de la aplicaci√≥n reseteado a inicial (sin borrar localStorage desde esta funci√≥n).");
        }
        


        function parseCSV(csvText) {
            scheduleData = {}; employeeNamesOrdered = [];
            const uniqueEmployeeNames = new Set();
            const lines = csvText.trim().split(/\r\n|\n/);

            if (lines.length <= 1) return;

            for (let i = 1; i < lines.length; i++) {
                const cells = lines[i].split(',');
                if (cells.length < 3) continue;

                let employeeName = cells[0].trim();
                const month = parseInt(cells[1].trim(), 10);

                if (employeeName.length >= 2 && employeeName.startsWith('"') && employeeName.endsWith('"')) {
                    employeeName = employeeName.substring(1, employeeName.length - 1).replace(/""/g, '"');
                }

                if (!employeeName || isNaN(month) || month < 1 || month > 12) continue;

                if (!scheduleData[employeeName]) {
                    scheduleData[employeeName] = {};
                    uniqueEmployeeNames.add(employeeName);
                }
                if (!scheduleData[employeeName][month]) scheduleData[employeeName][month] = {};

                const daysInMonthForCSV = getDaysInMonth(month, yearOfSchedule);

                for (let dayIndex = 1; dayIndex <= 31; dayIndex++) {
                    if (dayIndex + 1 < cells.length) {
                        let cellValue = cells[dayIndex + 1] ? cells[dayIndex + 1].trim() : "";
                        if (cellValue.length >= 2 && cellValue.startsWith('"') && cellValue.endsWith('"')) {
                            cellValue = cellValue.substring(1, cellValue.length - 1).replace(/""/g, '"');
                        }
                        if (dayIndex <= daysInMonthForCSV) {
                           scheduleData[employeeName][month][dayIndex] = cellValue;
                        }
                    } else if (dayIndex <= daysInMonthForCSV) {
                        scheduleData[employeeName][month][dayIndex] = "";
                    }
                }
            }
            employeeNamesOrdered = Array.from(uniqueEmployeeNames);
        }

        function saveScheduleToLocalStorage(clearUndoRedoHistory = true) {
            if (!isDataLoadedForSave()) {
                showToast('No hay datos para guardar.', 'error');
                return;
            }
            try {
                // 1. Datos del Horario Principal (scheduleData, employeeOrder, etc.)
                const scheduleRelatedData = { // Objeto que ya estabas guardando para LOCAL_STORAGE_KEY_SCHEDULE
                    schedule: scheduleData,
                    employeeOrder: employeeNamesOrdered,
                    selectedMonth: currentSelectedMonth,
                    uploadedCsvName: domCache.csvFileInput?.dataset?.uploadedFileName || null
                };
                const scheduleJsonString = JSON.stringify(scheduleRelatedData);
                const compressedSchedule = LZString.compressToUTF16(scheduleJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_SCHEDULE, compressedSchedule);

                // 2. Notas (string simple, no necesita compresi√≥n generalmente)
                if (domCache.generalNotesTextarea) {
                    localStorage.setItem(LOCAL_STORAGE_KEY_NOTES, domCache.generalNotesTextarea.value);
                }

                // 3. Vista Actual (string simple, no necesita compresi√≥n)
                localStorage.setItem(LOCAL_STORAGE_KEY_VIEW, currentViewMode);

                // 4. Colores Personalizados
                const colorsJsonString = JSON.stringify(currentShiftColors);
                const compressedColors = LZString.compressToUTF16(colorsJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_COLORS, compressedColors);

                // 5. Horarios de Turno Personalizados
                const shiftTimesJsonString = JSON.stringify(currentUserShiftTimes);
                const compressedShiftTimes = LZString.compressToUTF16(shiftTimesJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_SHIFT_TIMES, compressedShiftTimes);

                // 6. Historial de Cambios
                const historyJsonString = JSON.stringify(changeHistory);
                const compressedHistory = LZString.compressToUTF16(historyJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_HISTORY, compressedHistory);

                // 7. A√±o del Horario (string/n√∫mero simple, no necesita compresi√≥n)
                localStorage.setItem(LOCAL_STORAGE_KEY_YEAR, yearOfSchedule.toString());

                // 8. Pila de Deshacer (Undo Stack)
                const undoStackJsonString = JSON.stringify(undoStack);
                const compressedUndoStack = LZString.compressToUTF16(undoStackJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_UNDO_STACK, compressedUndoStack);

                // 9. Pila de Rehacer (Redo Stack)
                const redoStackJsonString = JSON.stringify(redoStack);
                const compressedRedoStack = LZString.compressToUTF16(redoStackJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_REDO_STACK, compressedRedoStack);

                // NOTA: LOCAL_STORAGE_KEY_RULES se guarda en su propia funci√≥n saveRulesConfigToLocalStorage

                hasUnsavedChanges = false;
                updateUnsavedChangesIndicator();

                if (domCache.saveLocalButton) {
                    domCache.saveLocalButton.disabled = true;
                }

                if (domCache.modalApplyColorsButton) {
                    domCache.modalApplyColorsButton.disabled = true;
                }
                if (domCache.modalResetColorsButton) {
                    domCache.modalResetColorsButton.disabled = JSON.stringify(currentShiftColors) === JSON.stringify(DEFAULT_SHIFT_COLORS) &&
                                                           JSON.stringify(currentUserShiftTimes) === JSON.stringify(DEFAULT_SHIFT_TIMES);
                }

                if (clearUndoRedoHistory === true) {
                     showToast('Datos guardados localmente.', 'success');
                } else if (clearUndoRedoHistory === false && isAutosaveEnabled) {
                     // El toast del autoguardado ya se maneja en toggleAutosave
                }

            } catch (error) {
                console.error("Error al comprimir y guardar en localStorage:", error);
                if (error.name === 'QuotaExceededError') {
                    showToast('Error: L√≠mite de almacenamiento local excedido. No se pudieron guardar todos los datos.', 'error');
                } else {
                    showToast('Error al guardar los datos. Es posible que algunos datos no se hayan guardado.', 'error');
                }
                // Considera si quieres revertir parcialmente los cambios o notificar m√°s espec√≠ficamente.
            }
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA saveScheduleToLocalStorage ---

        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA loadDataFromLocalStorage ---
        function loadDataFromLocalStorage() {
            let dataLoadedSuccessfully = false;
            try {
                // 1. Datos del Horario Principal
                const compressedScheduleString = localStorage.getItem(LOCAL_STORAGE_KEY_SCHEDULE);
                const savedScheduleData = decompressData(compressedScheduleString, "scheduleData");

                // 2. Notas (string simple, no necesita descompresi√≥n)
                const savedNotes = localStorage.getItem(LOCAL_STORAGE_KEY_NOTES);
                if (savedNotes !== null) domCache.generalNotesTextarea.value = savedNotes; // !== null para permitir notas vac√≠as

                // 3. Vista Actual (string simple, no necesita descompresi√≥n)
                const savedView = localStorage.getItem(LOCAL_STORAGE_KEY_VIEW);
                if (savedView) currentViewMode = savedView;

                if (savedScheduleData && savedScheduleData.schedule && savedScheduleData.employeeOrder) {
                    scheduleData = savedScheduleData.schedule;
                    employeeNamesOrdered = savedScheduleData.employeeOrder;
                    currentSelectedMonth = savedScheduleData.selectedMonth || (new Date().getMonth() + 1);
                    if (domCache.csvFileInput && savedScheduleData.uploadedCsvName) {
                        domCache.csvFileInput.dataset.uploadedFileName = savedScheduleData.uploadedCsvName;
                    } else if (domCache.csvFileInput) {
                        delete domCache.csvFileInput.dataset.uploadedFileName;
                    }

                    if (isDataLoadedForStats()) { // isDataLoadedForStats ya deber√≠a estar definida en tu c√≥digo
                        dataLoadedSuccessfully = true;
                        hasUnsavedChanges = false; // Los datos reci√©n cargados se consideran "guardados"
                        populateMonthTabs();
                        enableControls(true);
                        showToast('Datos cargados desde almacenamiento local.', 'success');
                    }
                }

                // 4. Pila de Deshacer (Undo Stack)
                const compressedUndoStackString = localStorage.getItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                const savedUndoStack = decompressData(compressedUndoStackString, "undoStack");
                undoStack = Array.isArray(savedUndoStack) ? savedUndoStack : [];


                // 5. Pila de Rehacer (Redo Stack)
                const compressedRedoStackString = localStorage.getItem(LOCAL_STORAGE_KEY_REDO_STACK);
                const savedRedoStack = decompressData(compressedRedoStackString, "redoStack");
                redoStack = Array.isArray(savedRedoStack) ? savedRedoStack : [];

                // NOTA: Las otras claves (COLORS, SHIFT_TIMES, HISTORY, RULES, YEAR)
                // se cargan en sus funciones individuales (loadCustomColors, loadCustomShiftTimes, etc.)
                // Esas funciones tambi√©n necesitar√°n usar `decompressData`.

            } catch (error) { // Este catch es m√°s gen√©rico para errores inesperados en el flujo de carga
                console.error("Error general al cargar datos desde localStorage:", error);
                showToast('Error al cargar datos locales. Podr√≠an estar corruptos.', 'error');
                // Considera si quieres limpiar localStorage aqu√≠ o manejarlo de otra forma
                // localStorage.removeItem(LOCAL_STORAGE_KEY_SCHEDULE);
                // localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK);
                // localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK);
                undoStack = []; redoStack = []; // Resetear pilas en caso de error grave
            }

            if (!dataLoadedSuccessfully) {
                 enableControls(false);
                 renderAddEmployeeButtonInTable(); // Asumiendo que esta funci√≥n existe
                 undoStack = []; redoStack = [];
            }
            updateUnsavedChangesIndicator();
            updateUndoRedoButtonsState();
            return dataLoadedSuccessfully;
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA loadDataFromLocalStorage ---


        function applyEmptyScheduleTemplate() {
            let monthForTemplate;
            if (currentSelectedMonth >= 1 && currentSelectedMonth <= 12) {
                monthForTemplate = currentSelectedMonth;
            } else {
                monthForTemplate = new Date().getMonth() + 1;
                currentSelectedMonth = monthForTemplate;
            }
            const yearForTemplate = yearOfSchedule;
            const daysInMonthForTemplate = getDaysInMonth(monthForTemplate, yearForTemplate);

            let csvHeader = "Empleado,Mes";
            for (let i = 1; i <= 31; i++) {
                csvHeader += `,${i}`;
            }
            csvHeader += "\n";

            let employeeRow = `"Empleado Ejemplo",${monthForTemplate}`;
            for (let i = 1; i <= daysInMonthForTemplate; i++) {
                employeeRow += `,`;
            }
            for (let i = daysInMonthForTemplate + 1; i <= 31; i++) {
                employeeRow += `,`;
            }
            employeeRow += "\n";

            const csvContentInterno = csvHeader + employeeRow;

            try {
                parseCSV(csvContentInterno);

				if (isDataLoadedForStats()) {
				if (domCache.csvFileInput) {
					domCache.csvFileInput.value = '';
					domCache.csvFileInput.dataset.uploadedFileName = TEMPLATE_FLAG_FILENAME;
				}
				undoStack = []; 
				redoStack = []; 
				localStorage.removeItem(LOCAL_STORAGE_KEY_UNDO_STACK); 
				localStorage.removeItem(LOCAL_STORAGE_KEY_REDO_STACK); 
				updateUndoRedoButtonsState();
				populateMonthTabs();
				hasUnsavedChanges = true; 
				updateUnsavedChangesIndicator();
				enableControls(true);
				switchViewMode('monthly');
				initializeAndRenderNewStatistics();
				showToast('Nueva plantilla de horario aplicada.', 'success');
			} else {
				showToast('Error al aplicar la plantilla vac√≠a. No se cargaron datos.', 'error');
				resetToInitialState();
			}
            } catch (error) {
                console.error("Error al aplicar la plantilla de CSV vac√≠o:", error);
                showToast(`Error al aplicar la plantilla: ${error.message}`, 'error');
                resetToInitialState();
            }
        }


        function showFilenameModal(title, description, defaultName, extension, confirmCallback) {
            domCache.filenameModalTitle.textContent = title;
            domCache.filenameModalDescription.textContent = description;
            domCache.modalFilenameInput.value = defaultName;
            currentFilenameConfirmCallback = confirmCallback;
            currentFilenameExtension = extension;
            showModal(domCache.filenameModal, domCache.modalFilenameInput);
        }

        function handleFilenameConfirm() {
            const filenameBase = domCache.modalFilenameInput.value.trim();
            if (!filenameBase) {
                showToast('Por favor, introduce un nombre para el archivo.', 'error');
                domCache.modalFilenameInput.focus(); return;
            }
            if (currentFilenameConfirmCallback) currentFilenameConfirmCallback(filenameBase);
            hideModal(domCache.filenameModal, () => {
                currentFilenameConfirmCallback = null; currentFilenameExtension = ''; domCache.modalFilenameInput.value = '';
            });
        }

        function prepareExportScheduleToCSV() {
            if (!isDataLoadedForStats()) {
                showToast('No hay datos para exportar.', 'error'); return;
            }
            const sourceFileNameForDefault = domCache.csvFileInput?.dataset?.uploadedFileName || null;
            const defaultName = generateDefaultFilename('csv', sourceFileNameForDefault);
            showFilenameModal("Exportar Horario a CSV", "Nombre base para el archivo CSV:", defaultName, ".csv", exportScheduleToCSV);
        }

        function exportScheduleToCSV(filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`;
            let csvContent = "Empleado,Mes,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31\n";

            employeeNamesOrdered.forEach(empName => {
                for (let month = 1; month <= 12; month++) {
                    let row = `"${empName.replace(/"/g, '""')}",${month}`;
                    const monthData = scheduleData[empName]?.[month] || {};
                    const daysInThisMonth = getDaysInMonth(month, yearOfSchedule);

                    for (let day = 1; day <= 31; day++) {
                        if (day <= daysInThisMonth) {
                            let cellValue = monthData[day] || "";
                            if (/[",\n\r]/.test(cellValue)) {
                                cellValue = `"${cellValue.replace(/"/g, '""')}"`;
                            }
                            row += `,${cellValue}`;
                        } else {
                            row += `,`;
                        }
                    }
                    csvContent += row + "\n";
                }
            });

            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = createElement("a", { attributes: { href: URL.createObjectURL(blob), download: finalFilename }, style: { visibility: 'hidden' } });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Horario exportado como ${finalFilename}.`, 'success');
        }

        // --- GENERACI√ìN DE SVG Y PDF ---
        function prepareDownloadSvgOrPdf(type) {
            if (!isDataLoadedForStats()) {
                showToast('No hay horario para descargar.', 'error'); return;
            }
            if (type === 'weekly' && currentViewMode !== 'monthly') {
                 showToast('La descarga semanal solo est√° disponible en vista mensual.', 'warning'); return;
            }

            let defaultNameContext = type === 'weekly' ? 'pdfWeekly' : (currentViewMode === 'monthly' ? 'pdfMonthly' : 'pdfAnnual');
            const defaultName = generateDefaultFilename(defaultNameContext);
            const modalTitle = `Descargar ${type === 'weekly' ? 'Semanal' : (currentViewMode === 'monthly' ? 'Mensual' : 'Anual')} PDF`;
            showFilenameModal(modalTitle, "Nombre base para el archivo PDF:", defaultName, ".pdf", (filenameBase) => downloadSvgOrPdfInternal(type, filenameBase));
        }

        async function downloadSvgOrPdfInternal(type, filenameBase) {
            const finalFilename = `${filenameBase}${currentFilenameExtension}`;
            showToast('Generando PDF paginado, por favor espera...', 'info');
        
            const yearToRender = yearOfSchedule;
            // Vista Anual: HASTA 2 meses por p√°gina. Semanal: hasta 2 semanas.
            const itemsPerPage = 2; // Unificado a 2 para ambas vistas paginadas
        
            let allItemsToPaginate;
            if (type === 'weekly') {
                allItemsToPaginate = getWeeksForMonth(yearToRender, currentSelectedMonth);
            } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                allItemsToPaginate = Array.from({ length: 12 }, (_, i) => i + 1); 
            } else { 
                allItemsToPaginate = [currentSelectedMonth]; // Vista mensual individual
            }
            
            const totalItems = allItemsToPaginate.length;
            if (totalItems === 0) {
                showToast('No hay contenido para generar el PDF.', 'info');
                return;
            }
            
            // effectiveItemsPerPage se ajusta si es una exportaci√≥n mensual individual
            const effectiveItemsPerPage = (type === 'monthlyAnnual' && currentViewMode === 'monthly') ? 1 : itemsPerPage;
            const totalPages = Math.ceil(totalItems / effectiveItemsPerPage);
            let pdf;
        
            try {
                for (let pageIdx = 0; pageIdx < totalPages; pageIdx++) {
                    const startIndex = pageIdx * effectiveItemsPerPage;
                    const endIndex = Math.min(startIndex + effectiveItemsPerPage, totalItems);
                    const itemsForThisPage = allItemsToPaginate.slice(startIndex, endIndex);
        
                    let originalItemIndicesForPage;
                    if (type === 'weekly') {
                         originalItemIndicesForPage = Array.from({length: itemsForThisPage.length}, (_,i) => startIndex + i);
                    } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                         originalItemIndicesForPage = itemsForThisPage; 
                    } else { 
                         originalItemIndicesForPage = [currentSelectedMonth -1]; 
                    }
        
                    const svgString = getSvgString(
                        type,
                        yearToRender,
                        itemsForThisPage,
                        pageIdx + 1, 
                        totalPages,
                        originalItemIndicesForPage
                    );
        
                    if (!svgString) {
                        showToast(`Error generando SVG para p√°gina ${pageIdx + 1}.`, 'error');
                        console.error(`SVG string vac√≠o o nulo para p√°gina ${pageIdx + 1}, items:`, itemsForThisPage);
                        continue;
                    }
        
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
                    const svgElement = svgDoc.documentElement;
        
                    if (svgElement.tagName === "parsererror" || !svgElement || svgElement.querySelector('parsererror')) {
                        const errorDetails = svgElement.querySelector('parsererror div') ? svgElement.querySelector('parsererror div').textContent : "Error desconocido en SVG.";
                        console.error("Error al parsear SVG para p√°gina " + (pageIdx + 1) + ": " + errorDetails, "\nSVG problem√°tico:\n", svgString.substring(0, 500) + "...");
                        throw new Error("Error al parsear SVG para p√°gina " + (pageIdx + 1) + ". Revisa la consola para detalles.");
                    }
        
                    const svgWidth = parseFloat(svgElement.getAttribute('width'));
                    const svgHeight = parseFloat(svgElement.getAttribute('height'));
        
                    if (isNaN(svgWidth) || isNaN(svgHeight) || svgWidth <= 0 || svgHeight <= 0) {
                        console.error(`Dimensiones SVG inv√°lidas para p√°gina ${pageIdx + 1}: ${svgWidth}x${svgHeight}`, "\nSVG con problemas:\n", svgString.substring(0, 500) + "...");
                        throw new Error(`Dimensiones SVG inv√°lidas para p√°gina ${pageIdx + 1}: ${svgWidth}x${svgHeight}.`);
                    }
                    
                    const orientation = svgWidth > svgHeight ? 'l' : 'p'; 
        
                    if (pageIdx === 0) {
                        const { jsPDF } = window.jspdf; 
                        pdf = new jsPDF({
                            orientation: orientation,
                            unit: 'px',
                            format: [svgWidth, svgHeight], 
                            hotfixes: ['px_scaling'] 
                        });
                    } else {
                        pdf.addPage([svgWidth, svgHeight], orientation);
                    }
                    
                    await pdf.svg(svgElement, {
                        x: 0,
                        y: 0,
                        width: svgWidth,
                        height: svgHeight
                    });
                }
        
                if (pdf && totalPages > 0) {
                    pdf.save(finalFilename);
                    showToast(`PDF paginado descargado como ${finalFilename}.`, 'success');
                }
        
            } catch (error) {
                console.error("Error detallado al generar PDF paginado:", error, error.stack);
                showToast('Error cr√≠tico al generar el PDF: ' + error.message + '. Revisa la consola.', 'error');
            }
        }
        
        
        


        // --- VISTAS DE TABLA ---
        function switchViewMode(mode) {
            clearSelection(); // Asumiendo que tienes esta funci√≥n para limpiar celdas seleccionadas
            currentViewMode = mode;
        
            updateViewModeUI(); // Esta funci√≥n se encargar√° de la l√≥gica visual principal
            handleViewChange(); // Esta funci√≥n renderiza la tabla
            updateCalendarExportButtonsState(); // Actualiza estado de botones de exportaci√≥n
        
            // Guardar la preferencia de vista en localStorage (opcional, pero bueno para UX)
            localStorage.setItem(LOCAL_STORAGE_KEY_VIEW, currentViewMode);
        }
        


        function updateViewModeUI() {
            const dataExists = isDataLoadedForStats(); 
        
            if (domCache.monthTabsWrapper) {
                if (currentViewMode === 'monthly' && dataExists) {
                    domCache.monthTabsWrapper.classList.remove('hidden-by-default');
                } else {
                    domCache.monthTabsWrapper.classList.add('hidden-by-default');
                }
            } else {
                console.error("Error: domCache.monthTabsWrapper no est√° definido en updateViewModeUI.");
            }
        
            if (domCache.viewMonthlyButton && domCache.viewAnnualButton) {
                if (currentViewMode === 'annual' && dataExists) {
                    domCache.viewAnnualButton.classList.add('active');
                    domCache.viewMonthlyButton.classList.remove('active');
                    if (domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${yearOfSchedule}`;
                    // MODIFICACI√ìN: Texto del bot√≥n de descarga principal para vista anual
                    if (domCache.downloadImageButton) {
                        domCache.downloadImageButton.innerHTML = '<i class="fas fa-file-pdf mr-2"></i>Descargar Calendario Anual PDF';
                    }
                } else if (currentViewMode === 'monthly' && dataExists) {
                    domCache.viewMonthlyButton.classList.add('active');
                    domCache.viewAnnualButton.classList.remove('active');
                    if (domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`;
                    highlightActiveMonthTab();
                    // MODIFICACI√ìN: Texto del bot√≥n de descarga principal para vista mensual
                    if (domCache.downloadImageButton) {
                        domCache.downloadImageButton.innerHTML = '<i class="fas fa-file-pdf mr-2"></i>Descargar Calendario Mensual PDF';
                    }
                } else {
                    domCache.viewMonthlyButton.classList.remove('active');
                    domCache.viewAnnualButton.classList.remove('active');
                    if (domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = 'Horario para [Mes A√±o]';
                    // Texto por defecto si no hay datos o vista desconocida
                    if (domCache.downloadImageButton) {
                        domCache.downloadImageButton.innerHTML = '<i class="fas fa-file-pdf mr-2"></i>Descargar Calendario PDF';
                    }
                }
            }
        
            // MODIFICACI√ìN: Texto del bot√≥n de descarga semanal
            if (domCache.downloadWeeklySvgButton) {
                domCache.downloadWeeklySvgButton.innerHTML = '<i class="fas fa-file-pdf mr-2"></i>Descargar Calendario Semanal PDF';
            }
        
            if (domCache.downloadImageButton) {
                domCache.downloadImageButton.disabled = !dataExists;
            }
            if (domCache.downloadWeeklySvgButton) {
                domCache.downloadWeeklySvgButton.disabled = !dataExists || currentViewMode !== 'monthly';
            }
        
            updateCalendarExportButtonsState(); 
            updateUnsavedChangesIndicator(); 
        }

        function handleViewChange() {
            clearSelection(); 
            if (currentViewMode === 'annual') {
                renderAnnualScheduleTable(yearOfSchedule);
            } else {
                renderMonthlyScheduleTable(currentSelectedMonth, yearOfSchedule);
            }
        
            // LLAMADA CRUCIAL PARA ACTUALIZAR LAS NORMAS AUTOM√ÅTICAMENTE
            if (typeof validateAndDisplayRuleViolations === 'function') {
                validateAndDisplayRuleViolations(); 
            }
            // (La llamada a initializeAndRenderNewStatistics() tambi√©n puede estar aqu√≠ si es necesario para las estad√≠sticas,
            // aunque validateAndDisplayRuleViolations ya deber√≠a manejar la actualizaci√≥n visual de las normas).
        }
        

        function populateMonthTabs() {
            if (!domCache.monthTabsContainer) {
                console.error("Error: domCache.monthTabsContainer no est√° definido.");
                return;
            }
            domCache.monthTabsContainer.innerHTML = ''; 
        
            if (!isDataLoadedForStats()) { 
                domCache.monthTabsContainer.classList.add('hidden-by-default');
                return;
            }
            domCache.monthTabsContainer.classList.remove('hidden-by-default');
        
            MONTH_NAMES.forEach((monthName, index) => {
                const monthNum = index + 1;
                const button = createElement('button', {
                    className: 'month-tab',
                    textContent: monthName.substring(0, 3).toUpperCase(),
                    dataset: { month: monthNum.toString() }
                });
        
                if (monthNum === currentSelectedMonth) {
                    button.classList.add('active');
                }
        
                button.addEventListener('click', () => {
                    if (currentSelectedMonth !== monthNum) {
                        currentSelectedMonth = monthNum; 
                        switchViewMode('monthly'); // Esto llama a handleViewChange, que valida las normas.
        
                        // Sincronizaci√≥n de estad√≠sticas (esta l√≥gica ya la ten√≠as)
                        currentSelectedPeriodForMainStats = monthNum.toString(); 
                        if (domCache.selectedMonthText) {
                            domCache.selectedMonthText.textContent = MONTH_NAMES[monthNum - 1];
                            domCache.selectedMonthText.dataset.currentMonthValue = monthNum.toString();
                        }
                        if (domCache.mainMonthDropdownOptions) {
                            domCache.mainMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                a.classList.toggle('active', a.dataset.month === monthNum.toString());
                            });
                        }
                        renderNewStatsTable();
                        if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                            renderGeneralPlantillaStatsCharts();
                        }
                        if (domCache.individualChartsSection && !domCache.individualChartsSection.classList.contains('hidden') && currentSelectedEmployeeForDetails) {
                            const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                            if (employeeData) {
                                if (domCache.detailsSelectedMonthText) {
                                    domCache.detailsSelectedMonthText.textContent = MONTH_NAMES[monthNum - 1];
                                    domCache.detailsSelectedMonthText.dataset.currentMonthValue = monthNum.toString();
                                }
                                currentSelectedPeriodForDetailsStats = monthNum.toString(); 
                                if (domCache.detailsMonthDropdownOptions) {
                                    domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                        a.classList.toggle('active', a.dataset.month === monthNum.toString());
                                    });
                                }
                                showIndividualEmployeeCharts(employeeData, monthNum.toString());
                            }
                        }
                    }
                });
                domCache.monthTabsContainer.appendChild(button);
            });
            highlightActiveMonthTab(); 
        }



        function highlightActiveMonthTab() {
            domCache.monthTabsContainer.querySelectorAll('.month-tab').forEach(tab => {
                tab.classList.toggle('active', parseInt(tab.dataset.month) === currentSelectedMonth);
            });
        }

        function populateEmployeeSelects(selectElement) {
            selectElement.innerHTML = '';
            const placeholder = createElement('option', { textContent: 'Selecciona empleado', attributes: { value: "" } });
            selectElement.appendChild(placeholder);
            selectElement.value = "";

            employeeNamesOrdered.forEach(name => {
                selectElement.appendChild(createElement('option', { textContent: name, attributes: { value: name } }));
            });
        }

        function getDaysInMonth(month, year) {
            return new Date(year, month, 0).getDate();
        }
        function getWeekDayInitial(year, month, day) {
            return SHORT_WEEK_DAY_NAMES[new Date(year, month - 1, day).getDay()];
        }

		function applyShiftCellStyles(cell, shiftValue) {
		const allColorKeys = [...SHIFT_TYPES, 'empty', ...Object.keys(currentShiftColors)];
			allColorKeys.forEach(stKey => {
				if (DEFAULT_SHIFT_COLORS[stKey]?.bg) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].bg);
				if (DEFAULT_SHIFT_COLORS[stKey]?.text) cell.classList.remove(DEFAULT_SHIFT_COLORS[stKey].text);
				if (currentShiftColors[stKey]?.bg) cell.classList.remove(currentShiftColors[stKey].bg);
				if (currentShiftColors[stKey]?.text) cell.classList.remove(currentShiftColors[stKey].text);
				cell.classList.remove('font-bold');
			});

			const colorConfToApply = SHIFT_TYPES.includes(shiftValue) ? currentShiftColors[shiftValue] : currentShiftColors.empty;
			if (colorConfToApply?.bg) cell.classList.add(colorConfToApply.bg);
			if (colorConfToApply?.text) cell.classList.add(colorConfToApply.text);

			if (shiftValue && shiftValue.trim() !== "") {
				cell.classList.add('font-bold');
			} else {
				cell.classList.remove('font-bold');
			}
		}


        function handleTableDblClick(event) {
            const target = event.target;
            const employeeNameDisplay = target.closest('.employee-name-display');
            const shiftCell = target.closest('td.shift-cell');

            if (employeeNameDisplay && !target.closest('.delete-employee-icon')) {
                const td = employeeNameDisplay.closest('.employee-name-cell');
                const currentName = employeeNameDisplay.textContent;
                const input = createElement('input', {
                    attributes: { type: 'text', value: currentName },
                    className: 'w-full p-1 border border-indigo-300 rounded text-sm'
                });
                td.innerHTML = ''; td.appendChild(input); input.focus(); input.select();

                const saveName = () => {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        if (newName.includes(',')) {
                            showToast('El nombre del empleado no puede contener comas (,).', 'error');
                            td.innerHTML = '';
                            const originalNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                            const deleteIcon = createDeleteEmployeeIcon(currentName);
                            td.appendChild(originalNameSpan);
                            td.appendChild(deleteIcon);
                            input.focus();
                            return;
                        }
                        if (employeeNamesOrdered.includes(newName)) {
                            showToast(`El nombre "${newName}" ya existe.`, 'error');
                            td.innerHTML = '';
                            const originalNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                            const deleteIcon = createDeleteEmployeeIcon(currentName);
                            td.appendChild(originalNameSpan);
                            td.appendChild(deleteIcon);
                            return;
                        }
                        updateEmployeeName(currentName, newName);
                    } else {
                        td.innerHTML = '';
                        const nameSpanToRestore = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIconToRestore = createDeleteEmployeeIcon(currentName);
                        td.appendChild(nameSpanToRestore);
                        td.appendChild(deleteIconToRestore);
                    }
                };
                input.addEventListener('blur', saveName);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        td.innerHTML = '';
                        const newNameSpan = createElement('span', { className: 'employee-name-display flex-grow', textContent: currentName, attributes: { draggable: "true" } });
                        const deleteIcon = createDeleteEmployeeIcon(currentName);
                        td.appendChild(newNameSpan); td.appendChild(deleteIcon);
                    }
                });
            } else if (shiftCell) {
                const cellInfo = getCellInfoFromElement(shiftCell);
                if (!cellInfo) return;
                const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";

                if (SHIFT_TYPES.includes(currentValue)) {
                    return;
                }

                cellsBeingEditedViaEventModal = [{
                    tdElement: shiftCell,
                    employee: cellInfo.employee,
                    month: cellInfo.month,
                    day: cellInfo.day,
                    originalValue: currentValue
                }];
                isSingleCellEditViaModal = true;
                const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
                showCustomEventModal(modalTitle, currentValue);
                clearSelection(false);
            }
        }

		function updateEmployeeName(oldName, newName) {
			saveStateForUndo(`Nombre de empleado: "${oldName}" -> "${newName}".`); 

			const index = employeeNamesOrdered.indexOf(oldName);
			if (index > -1) employeeNamesOrdered[index] = newName;

			if (scheduleData[oldName]) {
				scheduleData[newName] = scheduleData[oldName];
				delete scheduleData[oldName];
			}
			handleViewChange();
			initializeAndRenderNewStatistics();   // <--- A√ëADIDO
			showToast(`Nombre de empleado actualizado a "${newName}".`, 'success');
		}


        function createDeleteEmployeeIcon(employeeName) {
            const deleteIcon = createElement('i', {
                className: 'fas fa-trash-alt delete-employee-icon text-red-400 hover:text-red-600',
                title: `Eliminar a ${employeeName}`
            });
            deleteIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                promptDeleteEmployee(employeeName);
            });
            return deleteIcon;
        }

        function buildScheduleTableHeader(viewType, month, year) {
            const headerRow = createElement('tr');
			headerRow.appendChild(createElement('th', {
				textContent: 'Empleado',
				className: 'py-3 px-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider sticky-col-header' // ¬°Clase clave!
			}));
        
            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(month, year);
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    // --- MODIFICACI√ìN AQU√ç para el wrapper del n√∫mero del d√≠a ---
                    const dayNumberWrapper = createElement('span', { className: 'day-number-wrapper', textContent: day });
                    const dayHeaderContent = createElement('div'); // Contenedor para el n√∫mero y el d√≠a de la semana
                    dayHeaderContent.appendChild(dayNumberWrapper);
                    dayHeaderContent.appendChild(createElement('span', { className: 'day-header-weekday', textContent: getWeekDayInitial(year, month, day) }));
                    
                    headerRow.appendChild(createElement('th', {
                        className: 'py-3 px-2 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider',
                    }, [dayHeaderContent])); 
                    // --- FIN DE MODIFICACI√ìN ---
                }
            } else if (viewType === 'annual') {
                for (let m = 1; m <= 12; m++) {
                    const daysInThisMonth = getDaysInMonth(m, year);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        // --- INICIO DE LA MODIFICACI√ìN PARA VISTA ANUAL ---
                        const dayNumberWrapper = createElement('span', { className: 'day-number-wrapper', textContent: day });
                        const dayHeaderContent = createElement('div'); // Contenedor para el n√∫mero del d√≠a y la inicial de la semana
                        
                        dayHeaderContent.appendChild(dayNumberWrapper);
                        // Aqu√≠ usamos getWeekDayInitial, igual que en la vista mensual
                        dayHeaderContent.appendChild(createElement('span', {
                        className: 'day-header-weekday', // Puedes usar la misma clase que la mensual
                        textContent: getWeekDayInitial(year, m, day) // 'm' es el mes actual en el bucle anual
                        }));
                        
                        headerRow.appendChild(createElement('th', {
                        className: 'py-3 px-1.5 text-center text-xs font-semibold text-gray-600 uppercase tracking-wider min-w-[50px]',
                        }, [dayHeaderContent]));
                        // --- FIN DE LA MODIFICACI√ìN PARA VISTA ANUAL ---
                    }
                }
            }
            return headerRow;
        }

        function buildEmployeeRow(employeeName, rowIndex, viewType, currentDisplayMonth, yearToDisplay) {
            const employeeRow = createElement('tr', {
                className: `draggable-row ${rowIndex % 2 === 0 ? 'bg-white' : 'bg-gray-50 hover:bg-gray-100'}`,
                dataset: { rowIndex: rowIndex.toString() }
            });

            const nameCell = createElement('td', {
                // ASEG√öRATE DE QUE ESTAS CLASES EST√âN PRESENTES Y CORRECTAS
                className: `py-2 px-4 whitespace-nowrap text-sm font-medium text-gray-800 sticky-col employee-name-cell`,
                title: 'Doble clic para editar. Arrastra para reordenar.'
            });
            nameCell.style.backgroundColor = (rowIndex % 2 === 0) ? '#ffffff' : '#f9fafb';

            const nameSpan = createElement('span', {
                className: 'employee-name-display flex-grow', textContent: employeeName, attributes: { draggable: "true" }
            });
            const deleteIcon = createDeleteEmployeeIcon(employeeName);
            nameCell.appendChild(nameSpan);
            nameCell.appendChild(deleteIcon);
            employeeRow.appendChild(nameCell);

            if (viewType === 'monthly') {
                const daysInSelectedMonth = getDaysInMonth(currentDisplayMonth, yearToDisplay);
                const employeeMonthData = scheduleData[employeeName]?.[currentDisplayMonth] || {};
                for (let day = 1; day <= daysInSelectedMonth; day++) {
                    const shift = employeeMonthData[day] || "";
                    const tdShift = createElement('td', {
                        textContent: shift, className: 'shift-cell',
                        dataset: { employee: employeeName, month: currentDisplayMonth.toString(), day: day.toString(), colIndex: (day - 1).toString() }
                    });
                    applyShiftCellStyles(tdShift, shift);
                    if (selectedCells.some(sc => sc.employee === employeeName && sc.month === currentDisplayMonth && sc.day === day)) {
                        tdShift.classList.add('cell-selected');
                    }
                    employeeRow.appendChild(tdShift);
                }
            } else if (viewType === 'annual') {
                let currentAnnualColIndex = 0;
                for (let m = 1; m <= 12; m++) {
                    const employeeMonthData = scheduleData[employeeName]?.[m] || {};
                    const daysInThisMonth = getDaysInMonth(m, yearToDisplay);
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = employeeMonthData[day] || "";
                        const tdShift = createElement('td', {
                            textContent: shift, className: 'shift-cell',
                            dataset: { employee: employeeName, month: m.toString(), day: day.toString(), colIndex: currentAnnualColIndex.toString() }
                        });
                        applyShiftCellStyles(tdShift, shift);
                         if (selectedCells.some(sc => sc.employee === employeeName && sc.month === m && sc.day === day)) {
                            tdShift.classList.add('cell-selected');
                        }
                        employeeRow.appendChild(tdShift);
                        currentAnnualColIndex++;
                    }
                }
            }
            return employeeRow;
        }

        function renderMonthlyScheduleTable(month, year) {
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            const headerRow = buildScheduleTableHeader('monthly', month, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) {
                renderAddEmployeeButtonInTable();
                enableControls(false);
                if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;
                domCache.noDataMessage.classList.remove('hidden-by-default');
                return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario para ${MONTH_NAMES[month - 1]} ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'monthly', month, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable();
            highlightActiveMonthTab();
            enableControls(true);
        }

        function renderAnnualScheduleTable(year) {
            domCache.scheduleTableHead.innerHTML = ''; domCache.scheduleTableBody.innerHTML = '';
            const headerRow = buildScheduleTableHeader('annual', null, year);
            domCache.scheduleTableHead.appendChild(headerRow);

            if (!isDataLoadedForStats()) {
                 renderAddEmployeeButtonInTable();
                 enableControls(false);
                 if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;
                 domCache.noDataMessage.classList.remove('hidden-by-default');
                 return;
            }
            domCache.noDataMessage.classList.add('hidden-by-default');
            if(domCache.currentMonthYearText) domCache.currentMonthYearText.textContent = `Horario Anual ${year}`;

            employeeNamesOrdered.forEach((employeeName, rowIndex) => {
                const employeeRow = buildEmployeeRow(employeeName, rowIndex, 'annual', null, year);
                domCache.scheduleTableBody.appendChild(employeeRow);
            });
            renderAddEmployeeButtonInTable();
            enableControls(true);
        }

        function renderAddEmployeeButtonInTable() {
            // Eliminar la fila existente del bot√≥n "A√±adir Empleado" si ya existe, para evitar duplicados
            const existingAddRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
            if (existingAddRow) {
                existingAddRow.remove();
            }
        
            // Crear la nueva fila para el bot√≥n
            const addEmployeeRow = createElement('tr', { className: 'add-employee-row-reformed' });
        
            // Crear la celda para el bot√≥n (esta es la celda que debe ser sticky)
            const buttonCell = createElement('td', {
                className: 'sticky-col add-employee-cell-reformed' // Clases clave para el efecto sticky
            });
        
            // Crear el bot√≥n visual con icono y texto
            const buttonVisual = createElement('button', {
                className: 'add-employee-button-visual',
                title: 'A√±adir nuevo empleado'
            });
            const addIcon = createElement('i', { className: 'fas fa-user-plus' });
            const buttonText = createElement('span', { textContent: 'A√±adir Empleado' });
        
            buttonVisual.appendChild(addIcon);
            buttonVisual.appendChild(buttonText);
            buttonVisual.addEventListener('click', showAddEmployeeModal); // Asumiendo que showAddEmployeeModal est√° definida
        
            buttonCell.appendChild(buttonVisual);
            addEmployeeRow.appendChild(buttonCell);
        
            // A√±adir celdas vac√≠as para el resto de las columnas para mantener la estructura de la tabla
            let numberOfDayCells = 0;
            const headerRow = domCache.scheduleTableHead.querySelector('tr');
            if (headerRow && headerRow.cells.length > 1) {
                // Restamos 1 porque la primera celda de la cabecera es "Empleado"
                numberOfDayCells = headerRow.cells.length - 1;
            }
        
            for (let i = 0; i < numberOfDayCells; i++) {
                addEmployeeRow.appendChild(createElement('td', { className: 'add-employee-empty-cell-reformed' }));
            }
        
            // A√±adir la fila completa al cuerpo de la tabla
            domCache.scheduleTableBody.appendChild(addEmployeeRow);
        }
        

        // --- DRAG & DROP DE EMPLEADOS ---
        function handleDragStart(event) {
            if (event.target.classList.contains('employee-name-display')) {
                const targetRow = event.target.closest('.draggable-row');
                if (targetRow && targetRow.dataset.rowIndex) {
                    draggedRow = targetRow;
                    event.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => draggedRow.classList.add('dragging'), 0);
                }
            } else {
                event.preventDefault();
            }
        }
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable-row:not(.dragging):not(.add-employee-row-reformed)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDragOver(event) {
            event.preventDefault(); // Necesario para permitir el drop
            if (!draggedRow) return; // Solo proceder si se est√° arrastrando una fila
        
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
        
            // Crear el indicador solo si no existe
            if (!dragOverIndicator) {
                dragOverIndicator = createElement('tr', { className: 'drag-over-indicator-row' }, [
                    createElement('td', { attributes: { colspan: "100%" } }, [ // Colspan grande para abarcar todas las columnas
                        createElement('div', { className: 'drag-over-indicator' })
                    ])
                ]);
            }
        
            // Asegurar que el indicador est√© en el DOM y moverlo a la posici√≥n correcta
            const addRow = domCache.scheduleTableBody.querySelector('.add-employee-row-reformed');
        
            if (afterElement == null) { // Si se arrastra al final de la lista (antes de la fila "A√±adir Empleado" o al final absoluto)
                if (addRow) {
                    // Solo mover si no est√° ya antes de addRow o si no est√° en el DOM
                    if (dragOverIndicator.nextSibling !== addRow || !dragOverIndicator.parentElement) {
                        domCache.scheduleTableBody.insertBefore(dragOverIndicator, addRow);
                    }
                } else {
                    // Si no hay fila de "A√±adir Empleado", a√±adir al final
                    if (domCache.scheduleTableBody.lastChild !== dragOverIndicator || !dragOverIndicator.parentElement) {
                        domCache.scheduleTableBody.appendChild(dragOverIndicator);
                    }
                }
            } else { // Si se arrastra antes de otro elemento
                // Solo mover si no est√° ya en la posici√≥n correcta o si no est√° en el DOM
                if (dragOverIndicator.nextSibling !== afterElement || !dragOverIndicator.parentElement) {
                    domCache.scheduleTableBody.insertBefore(dragOverIndicator, afterElement);
                }
            }
        }
        

        function handleDragLeave(event) {
            if (!domCache.scheduleTableBody.contains(event.relatedTarget)) {
                removeDragOverIndicator();
            }
        }
        function removeDragOverIndicator() {
            if (dragOverIndicator && dragOverIndicator.parentElement) {
                dragOverIndicator.remove(); // M√©todo moderno para eliminar el elemento
            }
            // No establecemos dragOverIndicator a null aqu√≠; se har√° en dragend/drop
        }
        
        function handleDrop(event) {
            event.preventDefault();
            removeDragOverIndicator(); 
            dragOverIndicator = null;  

            if (!draggedRow) return;

            saveStateForUndo("Empleados reordenados."); 

            const originalIndex = parseInt(draggedRow.dataset.rowIndex);
            const afterElement = getDragAfterElement(domCache.scheduleTableBody, event.clientY);
            let newIndex;

            if (afterElement) {
                newIndex = parseInt(afterElement.dataset.rowIndex);
            } else {
                newIndex = employeeNamesOrdered.length;
            }

            if (originalIndex === newIndex || (originalIndex < newIndex && originalIndex === newIndex -1) || (originalIndex > newIndex && originalIndex === newIndex) ) {
                 if(draggedRow) draggedRow.classList.remove('dragging');
                 draggedRow = null; 
                 return;
            }

            const [draggedEmployeeName] = employeeNamesOrdered.splice(originalIndex, 1);

            if (originalIndex < newIndex) {
                employeeNamesOrdered.splice(newIndex - 1, 0, draggedEmployeeName);
            } else {
                employeeNamesOrdered.splice(newIndex, 0, draggedEmployeeName);
            }

            handleViewChange(); // Re-renderiza la tabla de horarios

            // === INICIO DE LA MODIFICACI√ìN ===
            initializeAndRenderNewStatistics(); // Actualiza y re-renderiza las estad√≠sticas
            // === FIN DE LA MODIFICACI√ìN ===

            if(draggedRow) draggedRow.classList.remove('dragging');
            draggedRow = null; 
        }

        function handleDragEnd(event) {
            if(draggedRow) draggedRow.classList.remove('dragging');
            removeDragOverIndicator(); // Llama a la funci√≥n para quitarlo del DOM
            dragOverIndicator = null;  // IMPORTANTE: resetear la variable global
            draggedRow = null; // Resetear draggedRow
        }
        

        // --- EDICI√ìN DE CELDAS Y SELECCI√ìN M√öLTIPLE ---
        function editCellOnLongPress(cellInfo) {
            const shiftCell = cellInfo.tdElement;
            const currentValue = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";

            if (SHIFT_TYPES.includes(currentValue)) {
                 return;
            }

            cellsBeingEditedViaEventModal = [{
                tdElement: shiftCell,
                employee: cellInfo.employee,
                month: cellInfo.month,
                day: cellInfo.day,
                originalValue: currentValue
            }];
            isSingleCellEditViaModal = true;
            const modalTitle = `Editar Evento: ${cellInfo.employee} - ${cellInfo.day}/${SHORT_MONTH_NAMES[cellInfo.month-1]}`;
            showCustomEventModal(modalTitle, currentValue);
            clearSelection(false);
        }

        function getCellInfoFromElement(tdElement) {
            if (!tdElement || !tdElement.dataset.employee) return null;
            return {
                employee: tdElement.dataset.employee,
                month: parseInt(tdElement.dataset.month),
                day: parseInt(tdElement.dataset.day),
                tdElement: tdElement,
                rowIndex: parseInt(tdElement.parentElement.dataset.rowIndex),
                colIndex: parseInt(tdElement.dataset.colIndex)
            };
        }
        function processCellClick(cellInfo, isShiftKey, isCtrlOrMetaKey, isTap = false) {
            if (isShiftKey && lastSelectedCellInfo) {
                clearSelection(false);
                const minRow = Math.min(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const maxRow = Math.max(lastSelectedCellInfo.rowIndex, cellInfo.rowIndex);
                const minCol = Math.min(lastSelectedCellInfo.colIndex, cellInfo.colIndex);
                const maxCol = Math.max(lastSelectedCellInfo.colIndex, cellInfo.colIndex);

                const allCellsInTable = domCache.scheduleTableBody.querySelectorAll('td.shift-cell');
                allCellsInTable.forEach(cellElement => {
                    const cellIterInfo = getCellInfoFromElement(cellElement);
                    if (cellIterInfo &&
                        cellIterInfo.rowIndex >= minRow && cellIterInfo.rowIndex <= maxRow &&
                        cellIterInfo.colIndex >= minCol && cellIterInfo.colIndex <= maxCol) {
                        if (!selectedCells.some(sc => sc.tdElement === cellIterInfo.tdElement)) {
                            selectedCells.push(cellIterInfo);
                            cellIterInfo.tdElement.classList.add('cell-selected');
                        }
                    }
                });
            } else if (isCtrlOrMetaKey || isTap) {
                toggleCellSelection(cellInfo);
                lastSelectedCellInfo = cellInfo;
            } else {
                if (!selectedCells.some(sc => sc.tdElement === cellInfo.tdElement)) {
                    clearSelection(false);
                    toggleCellSelection(cellInfo);
                } else if (selectedCells.length > 1) {
                    clearSelection(false);
                    toggleCellSelection(cellInfo);
                }
                lastSelectedCellInfo = cellInfo;
            }
            updateMultiselectToolbar();
        }

        function toggleCellSelection(cellInfo) {
            const existingIndex = selectedCells.findIndex(sc => sc.tdElement === cellInfo.tdElement);
            if (existingIndex > -1) {
                selectedCells.splice(existingIndex, 1);
                cellInfo.tdElement.classList.remove('cell-selected');
            } else {
                selectedCells.push(cellInfo);
                cellInfo.tdElement.classList.add('cell-selected');
            }
        }
        function clearSelection(hideToolbar = true) {
            selectedCells.forEach(cell => cell.tdElement.classList.remove('cell-selected'));
            selectedCells = [];
            lastSelectedCellInfo = null;
            if (hideToolbar) updateMultiselectToolbar();
        }
        function setupMultiselectToolbar() {
            domCache.multiselectToolbar.innerHTML = '';
            SHIFT_TYPES.forEach(shift => {
                const button = createElement('button', {
                    textContent: shift, title: `Asignar ${SHIFT_TYPE_FULL_NAMES[shift]} (${shift}) a selecci√≥n`
                });
                button.addEventListener('click', () => { applyShiftToSelection(shift); });
                domCache.multiselectToolbar.appendChild(button);
            });
            const otherButton = createElement('button', {
                textContent: 'Otro', title: 'Asignar "Otro" (vac√≠o) a selecci√≥n', className: 'other-selection'
            });
            otherButton.addEventListener('click', () => { applyShiftToSelection(''); });
            domCache.multiselectToolbar.appendChild(otherButton);
        }
        function updateMultiselectToolbar() {
            domCache.multiselectToolbar.classList.toggle('hidden-by-default', selectedCells.length === 0);
        }
        function applyShiftToSelection(newShift) {
            if (selectedCells.length === 0) return;

            if (newShift === '') {
                cellsBeingEditedViaEventModal = selectedCells.map(sc => ({
                    tdElement: sc.tdElement,
                    employee: sc.employee,
                    month: sc.month,
                    day: sc.day,
                    originalValue: scheduleData[sc.employee]?.[sc.month]?.[sc.day] || ""
                }));
                isSingleCellEditViaModal = false;
                let modalTitle;
                if (selectedCells.length === 1) {
                    const sc = selectedCells[0];
                    modalTitle = `Establecer Evento: ${sc.employee} - ${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}`;
                } else {
                    modalTitle = `Establecer Evento para ${selectedCells.length} Celdas`;
                }
                showCustomEventModal(modalTitle, "");
                return;
            }

            let changesMadeCount = 0;
            let undoDescription = `Turno de ${selectedCells.length} celda(s) cambiado a '${newShift || "Vac√≠o"}'.`;
            if (selectedCells.length === 1) {
                 const sc = selectedCells[0];
                 const originalShift = scheduleData[sc.employee]?.[sc.month]?.[sc.day] || "";
                 undoDescription = `Turno de ${sc.employee} (${sc.day}/${SHORT_MONTH_NAMES[sc.month-1]}) cambiado de '${originalShift || "Vac√≠o"}' a '${newShift || "Vac√≠o"}'.`;
            }

            let needsStateSave = selectedCells.some(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                return originalShift !== newShift;
            });

            if (needsStateSave) {
                saveStateForUndo(undoDescription);
            }

            selectedCells.forEach(cellInfo => {
                const originalShift = scheduleData[cellInfo.employee]?.[cellInfo.month]?.[cellInfo.day] || "";
                if (originalShift !== newShift) {
                    updateShift(cellInfo.tdElement, cellInfo.employee, cellInfo.month, cellInfo.day, newShift, originalShift, false);
                    changesMadeCount++;
                }
            });

            if (changesMadeCount > 0) {
            }
			initializeAndRenderNewStatistics();
        }

        function updateShift(td, employee, month, day, newShift, originalShift, logIndividualChange = true) {
            if (originalShift !== newShift && logIndividualChange) {
                 const originalShiftDisplay = SHIFT_TYPE_FULL_NAMES[originalShift] || (originalShift === "" ? "Vac√≠o" : (originalShift || "Vac√≠o"));
                 const newShiftDisplay = SHIFT_TYPE_FULL_NAMES[newShift] || (newShift === "" ? "Vac√≠o" : (newShift || "Vac√≠o"));
                 saveStateForUndo(`Turno de ${employee} (${day}/${SHORT_MONTH_NAMES[month-1]}) cambiado de '${originalShiftDisplay}' a '${newShiftDisplay}'.`);
            }

            if (!scheduleData[employee]) scheduleData[employee] = {};
            if (!scheduleData[employee][month]) scheduleData[employee][month] = {};
            scheduleData[employee][month][day] = newShift;
            td.textContent = newShift;
            applyShiftCellStyles(td, newShift);
			initializeAndRenderNewStatistics();
        }

        
        function getSvgString(type, yearToRender, itemsToRender, pageNumber, totalPages, originalItemIndices) {
            let svgElements = [];
            let svgWidth = 0;
            let svgHeight = 0;
        
            const pagePadding = 30;
            const logoRenderWidth = 120;
            const logoRenderHeight = 45;
            const logoTopMargin = 20;
            const mainTitleTopMargin = 10;
            const sectionTitleFontSize = 16;
            const mainTitleFontSize = 18;
            const tableTopMargin = 15;
            const spaceBetweenTables = 30; 
        
            const employeeColWidth = 90;
            const cellHeight = 28; 
            const headerHeight = 38; 
            const cellFontSize = 8; // Tama√±o de fuente para los turnos
            const employeeNameFontSize = 9; 
            const headerEmployeeFontSize = 10; // Tama√±o para "Empleado" en cabecera
            const headerDayNumberFontSize = 8; // Tama√±o para n√∫meros de d√≠a en cabecera
            const headerWeekdayFontSize = 7;   // Tama√±o para letras de d√≠a en cabecera
            const textYAdjust = cellFontSize * 0.35; 
            const safetyBufferBottom = 40; 
        
            let currentY = pagePadding;
        
            // --- Definir Ancho del SVG ---
            if (type === 'weekly') {
                const svgCellWidthWeekly = 65; 
                svgWidth = pagePadding * 2 + employeeColWidth + (7 * svgCellWidthWeekly);
            } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                const svgCellWidthAnnual = 35; 
                const maxDaysPossible = 31;
                svgWidth = pagePadding * 2 + employeeColWidth + (maxDaysPossible * svgCellWidthAnnual);
            } else { // Vista Mensual (cuando se exporta individualmente)
                const svgCellWidthMonthly = 35;
                const monthForWidth = (itemsToRender && itemsToRender.length > 0 && typeof itemsToRender[0] === 'number') ? itemsToRender[0] : currentSelectedMonth;
                const daysInCurrentMonth = getDaysInMonth(monthForWidth, yearToRender);
                svgWidth = pagePadding * 2 + employeeColWidth + (daysInCurrentMonth * svgCellWidthMonthly);
            }
        
            // --- Logo en CADA p√°gina ---
            currentY += logoTopMargin;
            const logoGroupX = (svgWidth / 2) - (logoRenderWidth / 2);
            svgElements.push(`<g transform="translate(${logoGroupX}, ${currentY}) scale(0.6)">${SVG_FINAL_LOGO_MARKUP}</g>`);
            currentY += logoRenderHeight;
        
            // --- T√≠tulo Principal del Documento (Solo en la primera p√°gina, debajo del logo) ---
            if (pageNumber === 1) {
                currentY += mainTitleTopMargin;
                let mainDocumentTitle = "";
                if (type === 'weekly') {
                    mainDocumentTitle = `Horario Semanal - ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearToRender}`;
                } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                    mainDocumentTitle = `Horario Anual ${yearToRender}`;
                } else {
                    const monthForTitle = (itemsToRender && itemsToRender.length > 0 && typeof itemsToRender[0] === 'number') ? itemsToRender[0] : currentSelectedMonth;
                    mainDocumentTitle = `Horario Mensual - ${MONTH_NAMES[monthForTitle - 1]} ${yearToRender}`;
                }
                svgElements.push(`<text x="${svgWidth / 2}" y="${currentY + mainTitleFontSize / 2}" font-family="Inter, sans-serif" font-size="${mainTitleFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">${mainDocumentTitle}</text>`);
                currentY += mainTitleFontSize;
            }
            
            // --- Iterar sobre los items (semanas o meses) para esta p√°gina ---
            itemsToRender.forEach((itemData, itemIndexInPage) => {
                if (itemIndexInPage > 0) { // A√±adir espacio solo si hay m√°s de una tabla en la p√°gina
                    currentY += spaceBetweenTables;
                }
                currentY += tableTopMargin; 
        
                let sectionTitle = "";
                if (type === 'weekly') {
                    const originalWeekIndex = originalItemIndices[itemIndexInPage];
                    const week = itemData; 
                    const firstDayOfWeek = week[0];
                    const lastDayOfWeek = week[week.length - 1];
                    sectionTitle = `Semana ${originalWeekIndex + 1}: ${firstDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short'})} - ${lastDayOfWeek.toLocaleDateString('es-ES', {day:'2-digit', month:'short', year:'numeric'})}`;
                } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                    const monthToRender = itemData; 
                    sectionTitle = `${MONTH_NAMES[monthToRender - 1]} ${yearToRender}`;
                }
        
                if (sectionTitle) {
                    svgElements.push(`<text x="${svgWidth / 2}" y="${currentY + sectionTitleFontSize / 2}" font-family="Inter, sans-serif" font-size="${sectionTitleFontSize}px" font-weight="600" text-anchor="middle" fill="#374151" dominant-baseline="middle">${sectionTitle}</text>`);
                    currentY += sectionTitleFontSize + (tableTopMargin / 2);
                }
        
                // --- L√≥gica de renderizado de la tabla ---
                let tableHeaderX = pagePadding;
                svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${employeeColWidth}" height="${headerHeight}" fill="#f3f4f6" stroke="#d1d5db"/>`);
                svgElements.push(`<text x="${tableHeaderX + employeeColWidth/2}" y="${currentY + headerHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${headerEmployeeFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937" dominant-baseline="middle">Empleado</text>`);
                tableHeaderX += employeeColWidth;
        
                if (type === 'weekly') {
                    const week = itemData;
                    const svgCellWidthWeekly = (svgWidth - pagePadding * 2 - employeeColWidth) / 7;
                    week.forEach(dateObj => {
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthWeekly}" height="${headerHeight}" fill="#f3f4f6" stroke="#d1d5db"/>`);
                        const dayStr = dateObj.toLocaleDateString('es-ES', { day: '2-digit' });
                        const monthStr = SHORT_MONTH_NAMES[dateObj.getMonth()];
                        const dayNameStr = WEEK_DAY_NAMES[dateObj.getDay()].substring(0,3);
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthWeekly/2}" y="${currentY + headerHeight * 0.38 + textYAdjust * 0.7}" font-family="Inter, sans-serif" font-size="${headerDayNumberFontSize}px" font-weight="bold" text-anchor="middle" fill="#1f2937">${dayStr} ${monthStr}</text>`);
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthWeekly/2}" y="${currentY + headerHeight * 0.72 + textYAdjust * 0.7}" font-family="Inter, sans-serif" font-size="${headerWeekdayFontSize}px" font-weight="bold" text-anchor="middle" fill="#4b5563">${dayNameStr}</text>`);
                        tableHeaderX += svgCellWidthWeekly;
                    });
                } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                    const monthToRender = itemData;
                    const daysInCurrentMonth = getDaysInMonth(monthToRender, yearToRender); 
                    const svgCellWidthAnnual = (svgWidth - pagePadding * 2 - employeeColWidth) / 31; 
                    for (let day = 1; day <= daysInCurrentMonth; day++) {
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0"/>`);
                        const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual/2}" y="${currentY + headerHeight * 0.38 + textYAdjust * 0.7}" font-family="Inter, sans-serif" font-size="${headerDayNumberFontSize}px" font-weight="bold" text-anchor="middle">${day}</text>`);
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthAnnual/2}" y="${currentY + headerHeight * 0.72 + textYAdjust * 0.7}" font-family="Inter, sans-serif" font-size="${headerWeekdayFontSize}px" text-anchor="middle">${weekDayInitial}</text>`);
                        tableHeaderX += svgCellWidthAnnual;
                    }
                     for (let day = daysInCurrentMonth + 1; day <= 31; day++) { 
                        svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthAnnual}" height="${headerHeight}" fill="#fdfdff" stroke="#e0e0e0"/>`);
                        tableHeaderX += svgCellWidthAnnual;
                    }
                } else { // Vista Mensual individual (type === 'monthlyAnnual' && currentViewMode === 'monthly')
                    const monthToRender = itemData; 
                    const daysInSelectedMonth = getDaysInMonth(monthToRender, yearToRender); 
                    const svgCellWidthMonthly = (svgWidth - pagePadding * 2 - employeeColWidth) / daysInSelectedMonth;
                    for (let day = 1; day <= daysInSelectedMonth; day++) {
                         svgElements.push(`<rect x="${tableHeaderX}" y="${currentY}" width="${svgCellWidthMonthly}" height="${headerHeight}" fill="#f9fafb" stroke="#e0e0e0"/>`);
                        const weekDayInitial = SHORT_WEEK_DAY_NAMES[new Date(yearToRender, monthToRender - 1, day).getDay()];
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly/2}" y="${currentY + headerHeight * 0.38 + textYAdjust * 0.5}" font-family="Inter, sans-serif" font-size="${headerDayNumberFontSize}px" font-weight="bold" text-anchor="middle">${day}</text>`);
                        svgElements.push(`<text x="${tableHeaderX + svgCellWidthMonthly/2}" y="${currentY + headerHeight * 0.72 + textYAdjust * 0.5}" font-family="Inter, sans-serif" font-size="${headerWeekdayFontSize}px" text-anchor="middle">${weekDayInitial}</text>`);
                        tableHeaderX += svgCellWidthMonthly;
                    }
                }
                currentY += headerHeight;
        
                employeeNamesOrdered.forEach((empName, rowIndex) => {
                    const rowY = currentY + rowIndex * cellHeight;
                    let currentCellX = pagePadding;
                    svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${employeeColWidth}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#ffffff' : '#f9fafb'}" stroke="#d1d5db"/>`);
                    svgElements.push(`<text x="${currentCellX + employeeColWidth/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${employeeNameFontSize}px" font-weight="bold" fill="#1f2937" dominant-baseline="middle" text-anchor="middle">${empName}</text>`);
                    currentCellX += employeeColWidth;
        
                    if (type === 'weekly') {
                        const week = itemData;
                        const svgCellWidthWeekly = (svgWidth - pagePadding * 2 - employeeColWidth) / 7;
                        week.forEach(dateObj => {
                            const day = dateObj.getDate(); const month = dateObj.getMonth() + 1;
                            let shift = scheduleData[empName]?.[month]?.[day] || "";
                            const shiftTimeConfig = currentUserShiftTimes[shift];
                            let displayShift = shift; 
                            if (shiftTimeConfig && (shift === 'M' || shift === 'T' || shift === 'N' || shift === 'M2' || shift === 'T2' || shift === 'N2')) {
                                displayShift = `${formatTimeForInput(shiftTimeConfig.start[0], shiftTimeConfig.start[1])}-${formatTimeForInput(shiftTimeConfig.end[0], shiftTimeConfig.end[1])}`;
                            } else if (SHIFT_TYPE_FULL_NAMES[shift]) {
                                displayShift = SHIFT_TYPE_FULL_NAMES[shift];
                            }
                            
                            const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
        
                            // ***** INICIO DEL LOG DE DIAGN√ìSTICO (SEMANAL) *****
                            if (shift === 'M' || shift === 'M2' || shift === 'T' || shift === 'T2' || shift === 'N' || shift === 'N2') {
                                console.log(`PDF Semanal - Empleado: ${empName}, D√≠a: ${day}/${month}, Turno Original: ${shift}, ColorConf Usado:`, JSON.parse(JSON.stringify(colorConf)));
                            }
                            // ***** FIN DEL LOG DE DIAGN√ìSTICO (SEMANAL) *****
                            
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthWeekly}" height="${cellHeight}" fill="${colorConf.hexBg || '#ffffff'}" stroke="#d1d5db"/>`);
                            if (displayShift) {
                                svgElements.push(`<text x="${currentCellX + svgCellWidthWeekly/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter, sans-serif" font-size="${cellFontSize -1}px" font-weight="${(shift && shift.trim() !== "") ? "bold" : "normal"}" text-anchor="middle" fill="${colorConf.hexText || '#000000'}">${displayShift}</text>`);
                            }
                            currentCellX += svgCellWidthWeekly;
                        });
        
                    } else if (type === 'monthlyAnnual' && currentViewMode === 'annual') {
                        const monthToRender = itemData; 
                        const daysInCurrentMonth = getDaysInMonth(monthToRender, yearToRender); 
                        const svgCellWidthAnnual = (svgWidth - pagePadding * 2 - employeeColWidth) / 31;
                        const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
                        for (let day = 1; day <= daysInCurrentMonth; day++) {
                            const shift = employeeMonthData[day] || "";
                            let displayShiftInPdfCell = shift; 
                            
                            const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
        
                            // ***** INICIO DEL LOG DE DIAGN√ìSTICO (ANUAL) *****
                            if (shift === 'M' || shift === 'M2' || shift === 'T' || shift === 'T2' || shift === 'N' || shift === 'N2') {
                                console.log(`PDF Anual - Empleado: ${empName}, D√≠a: ${day}/${monthToRender}, Turno Original: ${shift}, ColorConf Usado:`, JSON.parse(JSON.stringify(colorConf)));
                            }
                            // ***** FIN DEL LOG DE DIAGN√ìSTICO (ANUAL) *****
                            
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${colorConf.hexBg || '#fff'}" stroke="#e0e0e0"/>`);
                            if(displayShiftInPdfCell) { 
                                svgElements.push(`<text x="${currentCellX + svgCellWidthAnnual/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter,sans-serif" font-size="${cellFontSize}px" font-weight="${(shift && shift.trim() !== "") ? "bold" : "normal"}" text-anchor="middle" fill="${colorConf.hexText||'#000'}">${displayShiftInPdfCell}</text>`);
                            }
                            currentCellX += svgCellWidthAnnual;
                        }
                        for (let day = daysInCurrentMonth + 1; day <= 31; day++) { 
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthAnnual}" height="${cellHeight}" fill="${rowIndex % 2 === 0 ? '#fff' : '#f9fafb'}" stroke="#e0e0e0"/>`);
                            currentCellX += svgCellWidthAnnual;
                        }
                    } else { // Vista Mensual individual (type === 'monthlyAnnual' && currentViewMode === 'monthly')
                         const monthToRender = itemData; 
                         const daysInSelectedMonth = getDaysInMonth(monthToRender, yearToRender); 
                         const svgCellWidthMonthly = (svgWidth - pagePadding * 2 - employeeColWidth) / daysInSelectedMonth;
                         const employeeMonthData = scheduleData[empName]?.[monthToRender] || {};
                         for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = employeeMonthData[day] || "";
                            let displayShiftInPdfCell = shift;
        
                            const colorConf = SHIFT_TYPES.includes(shift) ? currentShiftColors[shift] : currentShiftColors.empty;
        
                            // ***** INICIO DEL LOG DE DIAGN√ìSTICO (MENSUAL) *****
                            if (shift === 'M' || shift === 'M2' || shift === 'T' || shift === 'T2' || shift === 'N' || shift === 'N2') {
                                console.log(`PDF Mensual - Empleado: ${empName}, D√≠a: ${day}/${monthToRender}, Turno Original: ${shift}, ColorConf Usado:`, JSON.parse(JSON.stringify(colorConf)));
                            }
                            // ***** FIN DEL LOG DE DIAGN√ìSTICO (MENSUAL) *****
        
                            svgElements.push(`<rect x="${currentCellX}" y="${rowY}" width="${svgCellWidthMonthly}" height="${cellHeight}" fill="${colorConf.hexBg || '#fff'}" stroke="#e0e0e0"/>`);
                            if(displayShiftInPdfCell) {
                                svgElements.push(`<text x="${currentCellX + svgCellWidthMonthly/2}" y="${rowY + cellHeight/2 + textYAdjust}" font-family="Inter,sans-serif" font-size="${cellFontSize}px" font-weight="${(shift && shift.trim() !== "") ? "bold" : "normal"}" text-anchor="middle" fill="${colorConf.hexText||'#000'}">${displayShiftInPdfCell}</text>`);
                            }
                            currentCellX += svgCellWidthMonthly;
                        }
                    }
                });
                currentY += (employeeNamesOrdered.length * cellHeight);
            }); 
            
            svgHeight = currentY + pagePadding + safetyBufferBottom;
        
            svgElements.unshift(`<rect width="${svgWidth}" height="${svgHeight}" fill="white"/>`);
            
            return `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="font-family: 'Inter', sans-serif;">${svgElements.join('')}</svg>`;
        }
        
        
        
        
        

        function getWeeksForMonth(year, month) {
            const weeks = [];
            const firstDateOfMonth = new Date(year, month - 1, 1);
            const lastDateOfMonth = new Date(year, month, 0);

            let currentDate = new Date(firstDateOfMonth);
            let dayOfWeek = currentDate.getDay(); 
            let diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; 
            currentDate.setDate(firstDateOfMonth.getDate() + diffToMonday);

            while (currentDate <= lastDateOfMonth || (weeks.length > 0 && weeks[weeks.length-1][6] >= firstDateOfMonth && weeks[weeks.length-1][0] <= lastDateOfMonth) ) {
                const week = [];
                for (let i = 0; i < 7; i++) {
                    week.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                if (week.some(d => d.getFullYear() === year && d.getMonth() === month - 1) ||
                   (weeks.length === 0 && week.some(d => d.getTime() === firstDateOfMonth.getTime())) ) {
                     weeks.push(week);
                 } else if (weeks.length > 0 && week[0] > lastDateOfMonth) { 
                     break;
                 }

                if (weeks.length > 6 && currentDate > lastDateOfMonth) break; 
            }
            return weeks;
        }


        // --- EXPORTACI√ìN A CALENDAR (.ics) ---
        // REEMPLAZA TU FUNCI√ìN exportToCalendar EXISTENTE CON ESTA VERSI√ìN ACTUALIZADA:
        function exportToCalendar(selectedEmployeeForCalendar) {
            let icalFilenameBase = generateDefaultFilename('calendar', selectedEmployeeForCalendar);
            const firstDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth - 1, 1);
            const lastDayOfMonth = new Date(yearOfSchedule, currentSelectedMonth, 0);
            let icalContent = [
                'BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//DanielFernandezOrellana//GestorHorariosLaborales//ES',
                `X-WR-CALNAME:Horario ${selectedEmployeeForCalendar} - ${MONTH_NAMES[currentSelectedMonth - 1]} ${yearOfSchedule}`
            ];
            const empName = selectedEmployeeForCalendar;
            if (!scheduleData[empName]) { showToast(`No hay datos para ${empName}.`, 'error'); return; }
            let currentDateIter = new Date(firstDayOfMonth);
            while(currentDateIter <= lastDayOfMonth) {
                const day = currentDateIter.getDate(), currentIterMonth = currentDateIter.getMonth() + 1, currentIterYear = currentDateIter.getFullYear();
                let shiftType = scheduleData[empName]?.[currentIterMonth]?.[day];
                if (shiftType === undefined || shiftType === null) shiftType = ""; 
                if (shiftType !== undefined) { 
                    const shiftTimeConfig = currentUserShiftTimes[shiftType];
                    const isKnownShift = SHIFT_TYPE_FULL_NAMES[shiftType]; // Esto funcionar√° para "B"
                    if (isKnownShift || (shiftType && !isKnownShift) || shiftType === "") { 
                        const dtStamp = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 15) + 'Z';
                        const uidSuffix = shiftType || 'otro'; 
                        const uid = `${formatDateForICalAllDay(currentDateIter)}-${empName.replace(/\s+/g, '')}-${uidSuffix}@gestorhorarios.com`;
                        icalContent.push('BEGIN:VEVENT', `UID:${uid}`, `DTSTAMP:${dtStamp}`);
                        let summaryText = shiftType === "" ? `Otro - ${empName}` : (isKnownShift ? `Turno ${SHIFT_TYPE_FULL_NAMES[shiftType]} (${shiftType}) - ${empName}` : `${shiftType} - ${empName}`);
                        icalContent.push(`SUMMARY:${summaryText}`, `DESCRIPTION:Horario laboral: ${summaryText}.`, `LOCATION:Gran Hotel Miramar`, `STATUS:CONFIRMED`);
                        
                        // MODIFICACI√ìN AQU√ç: Tratar "B" como evento de d√≠a completo
                        if (!shiftTimeConfig || shiftType === 'L' || shiftType === 'V' || shiftType === 'B' || shiftType === "") { 
                            const eventDate = new Date(currentIterYear, currentIterMonth - 1, day);
                            const startDateAllDay = formatDateForICalAllDay(eventDate);
                            eventDate.setDate(eventDate.getDate() + 1); 
                            const endDateAllDay = formatDateForICalAllDay(eventDate);
                            icalContent.push(`DTSTART;VALUE=DATE:${startDateAllDay}`, `DTEND;VALUE=DATE:${endDateAllDay}`, `TRANSP:OPAQUE`);
                        } else { 
                            let startDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.start[0], shiftTimeConfig.start[1]);
                            let endDateEvent = new Date(currentIterYear, currentIterMonth - 1, day, shiftTimeConfig.end[0], shiftTimeConfig.end[1]);
                            if (shiftTimeConfig.nextDayEnd) endDateEvent.setDate(endDateEvent.getDate() + 1);
                            icalContent.push(`DTSTART;TZID=Europe/Madrid:${formatForICalTimezone(startDateEvent)}`, `DTEND;TZID=Europe/Madrid:${formatForICalTimezone(endDateEvent)}`, `TRANSP:OPAQUE`);
                        }
                        icalContent.push('END:VEVENT');
                    }
                }
                currentDateIter.setDate(currentDateIter.getDate() + 1);
            }
            icalContent.push('END:VCALENDAR');
            if (icalContent.length <= 4) { 
                 showToast(`No hay eventos programados para ${selectedEmployeeForCalendar} en ${MONTH_NAMES[currentSelectedMonth - 1]}.`, 'info'); return;
            }
            const blob = new Blob([icalContent.join('\r\n')], { type: 'text/calendar;charset=utf-8;' });
            const link = createElement("a", { attributes: { href: URL.createObjectURL(blob), download: `${icalFilenameBase}.ics` }, style: { visibility: 'hidden' } });
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showToast(`Archivo Calendar (.ics) generado para ${selectedEmployeeForCalendar}.`, 'success');
        }


        function showExportToCalendarModal() {
            if (currentViewMode !== 'monthly' || !isDataLoadedForStats()) {
                showToast('Exportaci√≥n a Calendar: vista mensual y datos cargados requeridos.', 'warning'); return;
            }
            if (employeeNamesOrdered.length === 0) {
                showToast('No hay empleados para seleccionar.', 'info'); return;
            }
            populateEmployeeSelects(domCache.modalCalendarEmployeeSelect);
            showModal(domCache.exportCalendarModal, domCache.modalCalendarEmployeeSelect);
        }

        function updateCalendarExportButtonsState() {
            const dataExistsAndMonthlyView = isDataLoadedForStats() && currentViewMode === 'monthly';
            if(domCache.exportMonthCalendarButton) domCache.exportMonthCalendarButton.disabled = !dataExistsAndMonthlyView;
            if (domCache.downloadWeeklySvgButton) {
                 domCache.downloadWeeklySvgButton.disabled = !dataExistsAndMonthlyView;
            }
        }

        const formatForICalTimezone = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            const H = String(date.getHours()).padStart(2, '0'), M = String(date.getMinutes()).padStart(2, '0'), S = String(date.getSeconds()).padStart(2, '0');
            return `${y}${m}${d}T${H}${M}${S}`;
        };

        const formatDateForICalAllDay = (date) => {
            const y = date.getFullYear(), m = String(date.getMonth() + 1).padStart(2, '0'), d = String(date.getDate()).padStart(2, '0');
            return `${y}${m}${d}`;
        };

        function showAddEmployeeModal() {
            if(domCache.modalEmployeeNameInput) domCache.modalEmployeeNameInput.value = '';
            showModal(domCache.addEmployeeModal, domCache.modalEmployeeNameInput);
        }

		function handleAddEmployeeFromModal() {
			const newName = domCache.modalEmployeeNameInput.value.trim();
			if (!newName) { 
				showToast('Introduce un nombre.', 'error'); 
				domCache.modalEmployeeNameInput.focus(); 
				return; 
			}
			if (newName.includes(',')) {
				showToast('El nombre del empleado no puede contener comas (,).', 'error');
				domCache.modalEmployeeNameInput.focus();
				return;
			}
			if (employeeNamesOrdered.includes(newName)) { 
				showToast(`"${newName}" ya existe.`, 'error'); 
				domCache.modalEmployeeNameInput.focus(); 
				return; 
			}

			saveStateForUndo(`Empleado "${newName}" a√±adido.`); 
			employeeNamesOrdered.push(newName);
			if (!scheduleData[newName]) {
				scheduleData[newName] = {};
				for (let m = 1; m <= 12; m++) scheduleData[newName][m] = {};
			}
			hideModal(domCache.addEmployeeModal);
			handleViewChange(); 
			initializeAndRenderNewStatistics();   // <--- A√ëADIDO
			showToast(`Empleado "${newName}" a√±adido.`, 'success');
			enableControls(true); 
		}

        function promptDeleteEmployee(employeeName) {
            if (employeeNamesOrdered.length === 1) {
                showToast("No se puede eliminar al √∫ltimo empleado. Debe existir al menos un empleado en el horario.", 'warning');
                return;
            }

            employeeToDeleteName = employeeName;
            if(domCache.employeeNameToDeleteSpan) domCache.employeeNameToDeleteSpan.textContent = employeeName;
            if(domCache.modalConfirmDeleteEmployee) domCache.modalConfirmDeleteEmployee.disabled = true;
            let countdown = 5;
            if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = `Bot√≥n activo en ${countdown}s...`;
            if (deleteCountdownInterval) clearInterval(deleteCountdownInterval);
            deleteCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = `Bot√≥n activo en ${countdown}s...`;
                } else {
                    clearInterval(deleteCountdownInterval);
                    if(domCache.deleteCountdownMessageSpan) domCache.deleteCountdownMessageSpan.textContent = '¬°Bot√≥n de eliminar activo!';
                    if(domCache.modalConfirmDeleteEmployee) domCache.modalConfirmDeleteEmployee.disabled = false;
                }
            }, 1000);
            showModal(domCache.deleteEmployeeModal);
        }

		function confirmEmployeeDeletion() {
			if (employeeToDeleteName) {
				if (employeeNamesOrdered.length === 1 && employeeNamesOrdered[0] === employeeToDeleteName) {
					showToast("Error: No se puede eliminar al √∫ltimo empleado.", 'error');
					hideModal(domCache.deleteEmployeeModal, () => {
						if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
					});
					return;
				}

				saveStateForUndo(`Empleado "${employeeToDeleteName}" eliminado.`); 

				const index = employeeNamesOrdered.indexOf(employeeToDeleteName);
				if (index > -1) employeeNamesOrdered.splice(index, 1);
				delete scheduleData[employeeToDeleteName];

				handleViewChange(); 
				initializeAndRenderNewStatistics();

				showToast(`Empleado "${employeeToDeleteName}" eliminado.`, 'success');
				if (!isDataLoadedForStats()) { 
					resetToInitialState(true); 
				}
			}
			hideModal(domCache.deleteEmployeeModal, () => {
				if (deleteCountdownInterval) clearInterval(deleteCountdownInterval); employeeToDeleteName = null;
			});
		}

        function toggleAutosave(enabled) {
            isAutosaveEnabled = enabled;
            localStorage.setItem(LOCAL_STORAGE_KEY_AUTOSAVE, isAutosaveEnabled.toString());
            if (domCache.autosaveToggle) domCache.autosaveToggle.checked = isAutosaveEnabled;

            if (isAutosaveEnabled) {
                if (autosaveIntervalId) clearInterval(autosaveIntervalId);
                autosaveIntervalId = setInterval(() => {
                    if (hasUnsavedChanges && isDataLoadedForSave()) {
                        saveScheduleToLocalStorage(false); 
                        showToast('Progreso local autoguardado.', 'info', 2000);
                    }
                }, AUTOSAVE_INTERVAL_MS);
                showToast('Autoguardado local activado.', 'success');
            } else {
                if (autosaveIntervalId) {
                    clearInterval(autosaveIntervalId);
                    autosaveIntervalId = null;
                }
                showToast('Autoguardado local desactivado.', 'info');
            }
        }
        // ---------------------------------------------------------------------------------
        // --- NUEVA SECCI√ìN DE ESTAD√çSTICAS CON CHART.JS (Adaptaci√≥n del Prototipo) ---
        // ---------------------------------------------------------------------------------

        // --- Constantes y Variables Globales para Nuevas Estad√≠sticas ---
        const SHIFT_ICONS_PROTOTYPE = {
            M: 'fa-sun', T: 'fa-cloud-sun', N: 'fa-moon',
            L: 'fa-bed', V: 'fa-plane-departure', B: 'fa-briefcase-medical',
            Otro: 'fa-question-circle', 
            totalWorkDays: 'fa-briefcase', weekendsOff: 'fa-umbrella-beach'
        };

        let statsChartInstances = {}; 
        let currentStatsEmployeeData = []; 
        let currentSelectedPeriodForMainStats = 'all'; 
        let currentSelectedEmployeeForDetails = null; 
        let currentSelectedPeriodForDetailsStats = 'all'; 
			let hoveredEmployeeStatsIndex = -1;
		let currentSelectedPeriodForGeneralStats = 'all';

        // --- Funciones de Ayuda y Utilitarias para Nuevas Estad√≠sticas ---

        /**
         * Obtiene el color de fondo de la configuraci√≥n global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno (ej. 'M', 'T', 'empty').
         * @returns {string} Color hexadecimal o RGBA para Chart.js.
         */
        function getShiftBackgroundColorForChart(shiftType) {
			if (shiftType === 'totalWorkDays') return 'rgba(20, 184, 166, 0.3)'; // Verde con transparencia
			if (shiftType === 'weekendsOff') return 'rgba(96, 165, 250, 0.3)'; 
            const key = shiftType === 'Otro' ? 'empty' : shiftType; 
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexBg) {
                let hex = currentShiftColors[key].hexBg;
                if (hex.startsWith('#')) hex = hex.substring(1);
                if (hex.length === 3) hex = hex.split('').map(char => char + char).join('');
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                return `rgba(${r}, ${g}, ${b}, 0.7)`; 
            }
            return 'rgba(200, 200, 200, 0.7)'; 
        }

        /**
         * Obtiene el color de borde de la configuraci√≥n global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno.
         * @returns {string} Color hexadecimal para Chart.js.
         */
        function getShiftBorderColorForChart(shiftType) {
            const key = shiftType === 'Otro' ? 'empty' : shiftType;
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexBg) {
                return currentShiftColors[key].hexBg; 
            }
            return 'rgb(150, 150, 150)'; 
        }

        /**
         * Obtiene el color de texto de la configuraci√≥n global `currentShiftColors`.
         * @param {string} shiftType - El tipo de turno.
         * @returns {string} Color hexadecimal.
         */
        function getShiftTextColor(shiftType) {
            const key = shiftType === 'Otro' ? 'empty' : shiftType;
            if (currentShiftColors && currentShiftColors[key] && currentShiftColors[key].hexText) {
                return currentShiftColors[key].hexText;
            }
            return '#374151'; 
        }

        // --- Funciones de C√°lculo de Estad√≠sticas (Adaptaci√≥n) ---

        /**
         * Calcula las estad√≠sticas para todos los empleados basado en `scheduleData`.
         */
        function calculateAllEmployeeStatsForNewUI() {
            // (Log opcional para ver el scheduleData con el que EMPIEZA esta funci√≥n)
            console.log("[VERIFICACI√ìN 1] calculateAllEmployeeStatsForNewUI - ENTRANDO con scheduleData:", JSON.parse(JSON.stringify(scheduleData)));
            console.log("[VERIFICACI√ìN 1] calculateAllEmployeeStatsForNewUI - ENTRANDO con employeeNamesOrdered:", JSON.parse(JSON.stringify(employeeNamesOrdered)));

            currentStatsEmployeeData = []; // Correcto: se limpia para recalcular.
            if (!isDataLoadedForStats()) { 
                console.warn("calculateAllEmployeeStatsForNewUI: No hay datos de horario cargados al inicio del c√°lculo.");
                return;
            }

            employeeNamesOrdered.forEach(empName => {
                let stats = { 
                    name: empName, 
                    M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, 
                    totalWorkDays: 0, weekendsOff: 0
                    // No es necesario M2, T2, N2 aqu√≠ si se agregan a M, T, N
                };

                if (!scheduleData[empName]) { // Comprueba el scheduleData actual
                    currentStatsEmployeeData.push(stats); 
                    return; // Pasa al siguiente empleado si este no tiene datos
                }

                for (let month = 1; month <= 12; month++) { // Itera todos los meses
                    if (!scheduleData[empName][month]) continue; // Si no hay datos para este mes, pasa al siguiente

                    const daysInThisMonth = getDaysInMonth(month, yearOfSchedule); 
                    for (let day = 1; day <= daysInThisMonth; day++) {
                        const shift = scheduleData[empName][month][day]; // Lee del scheduleData actual
                        if (shift !== undefined && shift !== null && shift !== "") {
                            let effectiveShift = shift; 
                            let workShift = false;     

                            if (shift === 'M' || shift === 'M2') {
                                effectiveShift = 'M';
                                workShift = true;
                            } else if (shift === 'T' || shift === 'T2') {
                                effectiveShift = 'T';
                                workShift = true;
                            } else if (shift === 'N' || shift === 'N2') {
                                effectiveShift = 'N';
                                workShift = true;
                            } else if (shift === 'L') {
                                effectiveShift = 'L';
                            } else if (shift === 'V') {
                                effectiveShift = 'V';
                            } else if (shift === 'B') {
                                effectiveShift = 'B';
                            } else { 
                                effectiveShift = 'Otro';
                                workShift = true; 
                            }

                            if (stats.hasOwnProperty(effectiveShift)) {
                                stats[effectiveShift]++;
                            }

                            if (workShift) {
                                stats.totalWorkDays++;
                            }

                            const currentDate = new Date(yearOfSchedule, month - 1, day);
                            if (currentDate.getDay() === 6) { // S√°bado
                                const nextDayDate = new Date(yearOfSchedule, month - 1, day + 1);
                                if (nextDayDate.getMonth() === month - 1) { 
                                    const satShift = scheduleData[empName][month][day]; 
                                    const sunShift = scheduleData[empName][month][day + 1]; 

                                    const isSatFree = (satShift === "L" || satShift === "V" || satShift === "B" || satShift === "");
                                    const isSunFree = (sunShift === "L" || sunShift === "V" || sunShift === "B" || sunShift === "");

                                    if (isSatFree && isSunFree) {
                                        stats.weekendsOff++;
                                    }
                                }
                            }
                        }
                    }
                }
                currentStatsEmployeeData.push(stats);
            });
            // (Log opcional para ver el currentStatsEmployeeData que PRODUCE esta funci√≥n)
            console.log("[VERIFICACI√ìN 2] calculateAllEmployeeStatsForNewUI - SALIENDO con currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
        }

        /**
         * Valida las normas para los d√≠as visibles y actualiza los indicadores y el resumen.
         */
        function validateAndDisplayRuleViolations() {
            activeRuleViolations = {}; // Para personas por turno
            activeConsecutiveDayViolations = {}; // Para d√≠as consecutivos
        
            // Limpiar indicadores visuales de la tabla (ambos tipos)
            const allDayHeaderCells = domCache.scheduleTableHead.querySelectorAll('th');
            allDayHeaderCells.forEach(th => {
                th.classList.remove('day-rule-violation'); // Para personas por turno
            });
            domCache.scheduleTableBody.querySelectorAll('td.shift-cell').forEach(cell => {
                cell.classList.remove('consecutive-workday-violation-cell'); // Para d√≠as consecutivos
                // Tambi√©n podr√≠as querer quitar clases espec√≠ficas de borde si las usaste
                cell.style.borderTop = '';
                cell.style.borderBottom = '';
                cell.style.borderLeft = '';
                cell.style.borderRight = '';
            });
        
        
            const yearToValidate = yearOfSchedule;
        
            // --- Validaci√≥n de Personas por Turno (existente) ---
            if (rulesConfig.personsPerShift.enabled) {
                const monthsToValidateP = (currentViewMode === 'annual') ? Array.from({ length: 12 }, (_, i) => i + 1) : [currentSelectedMonth];
                monthsToValidateP.forEach(month => {
                    const daysInMonth = getDaysInMonth(month, yearToValidate);
                    for (let day = 1; day <= daysInMonth; day++) {
                        let isDayVisible = (currentViewMode === 'monthly' && month === currentSelectedMonth) || currentViewMode === 'annual';
                        if (isDayVisible) {
                            const shiftCounts = getShiftCountsForDay(yearToValidate, month, day);
                            const dayViolations = checkPersonsPerShiftRuleForDay(shiftCounts, rulesConfig.personsPerShift);
                            if (dayViolations.length > 0) {
                                activeRuleViolations[`${yearToValidate}-${month}-${day}`] = dayViolations;
                                updateDayViolationIndicator(yearToValidate, month, day, true);
                            } else {
                                updateDayViolationIndicator(yearToValidate, month, day, false);
                            }
                        }
                    }
                });
            }
        
            // --- NUEVA Validaci√≥n de M√°ximo D√≠as Consecutivos Trabajados ---
            if (rulesConfig.maxConsecutiveWorkdays.enabled && employeeNamesOrdered.length > 0) {
                employeeNamesOrdered.forEach(empName => {
                    const violationsForEmp = checkMaxConsecutiveWorkdays(empName);
                    if (violationsForEmp.length > 0) {
                        activeConsecutiveDayViolations[empName] = violationsForEmp;
                    }
                });
                // Aplicar estilos visuales para esta norma despu√©s de calcular todas las violaciones
                applyConsecutiveDayViolationStyles();
            }
            // --- FIN NUEVA Validaci√≥n ---
        
            displayRuleViolationsSummary(); // Actualizar el resumen en el modal
        }
        


        
        /**
         * Actualiza el indicador visual de violaci√≥n para un d√≠a espec√≠fico en la cabecera de la tabla.
         * @param {number} year El a√±o del d√≠a a actualizar.
         * @param {number} month El mes (1-12) del d√≠a a actualizar.
         * @param {number} day El n√∫mero del d√≠a a actualizar.
         * @param {boolean} hasViolation True si hay una violaci√≥n, false en caso contrario.
         */
        function updateDayViolationIndicator(year, month, day, hasViolation) {
            // Solo actualiza si la vista es mensual y es el mes correcto, O si es vista anual.
            if (currentViewMode === 'monthly' && month !== currentSelectedMonth) {
                return; 
            }
        
            let dayHeaderCellElement; // El elemento <th> que representa el d√≠a
        
            if (currentViewMode === 'monthly') {
                // En vista mensual, los d√≠as son las celdas <th> despu√©s de "Empleado".
                // El d√≠a 1 es el segundo <th> (√≠ndice 1), el d√≠a 'd' es el (d)-√©simo <th> despu√©s del de "Empleado".
                if (domCache.scheduleTableHead && domCache.scheduleTableHead.firstChild && domCache.scheduleTableHead.firstChild.cells) {
                     const headerCells = domCache.scheduleTableHead.firstChild.cells;
                     // El √≠ndice 0 es "Empleado", as√≠ que el d√≠a 'd' es el √≠ndice 'd'.
                     if (day >= 1 && day < headerCells.length) { 
                        dayHeaderCellElement = headerCells[day]; 
                     }
                }
            } else { // Vista Anual
                // Calcular el √≠ndice de columna global para el d√≠a en la vista anual.
                let columnIndex = 0;
                for (let m = 1; m < month; m++) {
                    columnIndex += getDaysInMonth(m, year);
                }
                columnIndex += day; // Sumamos el d√≠a (1-based)
        
                if (domCache.scheduleTableHead && domCache.scheduleTableHead.firstChild && domCache.scheduleTableHead.firstChild.cells) {
                    const headerCells = domCache.scheduleTableHead.firstChild.cells;
                    // El √≠ndice 0 es "Empleado", as√≠ que el √≠ndice de la celda es columnIndex.
                    if (columnIndex < headerCells.length) { 
                        dayHeaderCellElement = headerCells[columnIndex];
                    }
                }
            }
        
            if (dayHeaderCellElement) {
                // El estilo se aplica al <span> que envuelve el n√∫mero del d√≠a.
                const wrapper = dayHeaderCellElement.querySelector('.day-number-wrapper');
                if (wrapper) {
                    // Es mejor aplicar la clase al <th> padre para que el estilo del borde no afecte el layout del n√∫mero.
                    // O, si el estilo .day-rule-violation est√° dise√±ado para el wrapper, aplicarlo ah√≠.
                    // Por ahora, lo aplicaremos al <th> como en la gu√≠a original, asumiendo que el CSS lo maneja.
                    dayHeaderCellElement.classList.toggle('day-rule-violation', hasViolation);
                } else {
                    // Fallback si no se encuentra el wrapper (no deber√≠a pasar si el Paso 3.4 est√° bien)
                    dayHeaderCellElement.classList.toggle('day-rule-violation', hasViolation);
                }
            }
        }
        

        // --- Renderizado de la Tabla Principal de Estad√≠sticas ---
        function createNewStatsTableHeader() {
            const thead = domCache.statsTableHead; 
            if (!thead) {
                console.error("Elemento thead para la nueva tabla de estad√≠sticas no encontrado en domCache.");
                return;
            }
            thead.innerHTML = ''; 
            const tr = document.createElement('tr');

            let headerHTML = '<th>Empleado</th>';
            const shiftOrderForTable = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro', 'totalWorkDays', 'weekendsOff'];

            shiftOrderForTable.forEach(key => {
                const iconClass = SHIFT_ICONS_PROTOTYPE[key] || 'fa-circle-question';
                const iconColor = getShiftTextColor(key); 
                let displayName = key;
                if (key === 'totalWorkDays') displayName = 'D√≠as Trab.';
                else if (key === 'weekendsOff') displayName = 'FDS Lib.';
                else if (SHIFT_TYPE_FULL_NAMES[key]) displayName = SHIFT_TYPE_FULL_NAMES[key].substring(0,3); 

                headerHTML += `<th><i class="fas ${iconClass}" style="color: ${iconColor};"></i>${displayName}</th>`;
            });
            tr.innerHTML = headerHTML;
            thead.appendChild(tr);
        }

        function renderNewStatsTable() {
            const tbody = domCache.statsTableBody;
            const paginationInfo = domCache.paginationInfo;

            if (!tbody) {
                console.error("Elemento tbody para la nueva tabla de estad√≠sticas no encontrado en domCache.");
                return;
            }
            tbody.innerHTML = '';

            if (!currentStatsEmployeeData || currentStatsEmployeeData.length === 0 && currentSelectedPeriodForMainStats === 'all') { // Modificado para chequear tambi√©n si es 'all'
                tbody.innerHTML = '<tr><td colspan="10" class="text-center p-4 text-gray-500">No hay datos de empleados para mostrar.</td></tr>';
                if (paginationInfo) paginationInfo.textContent = 'Mostrando 0 empleados';
                return;
            }

            let dataToRender;
            if (currentSelectedPeriodForMainStats === 'all') {
                // Log para ver qu√© currentStatsEmployeeData se usa para "A√±o Completo"
                console.log("[VERIFICACI√ìN 3] renderNewStatsTable ('A√±o Completo') - Usando currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
                dataToRender = currentStatsEmployeeData;
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForMainStats);
                dataToRender = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let effectiveShift = shift;
                                let workShift = false;

                                if (shift === 'M' || shift === 'M2') { effectiveShift = 'M'; workShift = true; }
                                else if (shift === 'T' || shift === 'T2') { effectiveShift = 'T'; workShift = true; }
                                else if (shift === 'N' || shift === 'N2') { effectiveShift = 'N'; workShift = true; }
                                else if (shift === 'L') { effectiveShift = 'L'; }
                                else if (shift === 'V') { effectiveShift = 'V'; }
                                else if (shift === 'B') { effectiveShift = 'B'; }
                                else { effectiveShift = 'Otro'; workShift = true; }

                                if (monthlyStats.hasOwnProperty(effectiveShift)) {
                                    monthlyStats[effectiveShift]++;
                                }
                                if (workShift) {
                                    monthlyStats.totalWorkDays++;
                                }

                                const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                                if (currentDate.getDay() === 6) { 
                                    const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                                    if (nextDayDate.getMonth() === selectedMonthNum - 1) { 
                                        const satShiftOriginal = scheduleData[empName][selectedMonthNum][day];
                                        const sunShiftOriginal = scheduleData[empName][selectedMonthNum][day + 1];

                                        const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "");
                                        const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "");

                                        if (isSatFree && isSunFree) {
                                            monthlyStats.weekendsOff++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
                 if (dataToRender.length === 0) { // Si despu√©s de filtrar por mes no hay datos
                    tbody.innerHTML = `<tr><td colspan="10" class="text-center p-4 text-gray-500">No hay datos para ${MONTH_NAMES[selectedMonthNum-1]} ${yearOfSchedule}.</td></tr>`;
                    if (paginationInfo) paginationInfo.textContent = 'Mostrando 0 empleados';
                    return;
                }
            }

            dataToRender.forEach(emp => {
                const tr = document.createElement('tr');
                tr.dataset.employeeName = emp.name;

                let cellsHTML = `<td class="employee-name-cell">${emp.name}</td>`;
                const turnosYMetricas = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro', 'totalWorkDays', 'weekendsOff'];

                turnosYMetricas.forEach(st => {
                    const value = emp[st] || 0;
                    const bgColor = getShiftBackgroundColorForChart(st);
                    const textColor = getShiftTextColor(st);
                    const fullShiftName = SHIFT_TYPE_FULL_NAMES[st] || (st === 'totalWorkDays' ? 'D√≠as Trabajados' : (st === 'weekendsOff' ? 'FDS Libres' : st));

                    cellsHTML += `<td style="background-color: ${bgColor}; color: ${textColor}; font-weight: 500;" title="${value} ${fullShiftName.toLowerCase()}">${value}</td>`;
                });
                tr.innerHTML = cellsHTML;
                tbody.appendChild(tr);

                tr.addEventListener('click', function() {
                    const employeeName = this.dataset.employeeName;
                    const fullEmployeeData = currentStatsEmployeeData.find(e => e.name === employeeName); // Usa los datos anuales para encontrar al empleado
                    if (fullEmployeeData) {
                        currentSelectedEmployeeForDetails = employeeName;
                        // Sincroniza el dropdown de detalles con el per√≠odo principal actual
                        const mainFilterValue = domCache.selectedMonthText.dataset.currentMonthValue || 'all';
                        const mainFilterText = domCache.selectedMonthText.textContent;

                        if (domCache.detailsSelectedMonthText) {
                            domCache.detailsSelectedMonthText.textContent = mainFilterText;
                            domCache.detailsSelectedMonthText.dataset.currentMonthValue = mainFilterValue;
                        }
                        currentSelectedPeriodForDetailsStats = mainFilterValue;

                        if (domCache.detailsMonthDropdownOptions) {
                            domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                a.classList.toggle('active', a.dataset.month === mainFilterValue);
                            });
                        }
                        showIndividualEmployeeCharts(fullEmployeeData, mainFilterValue); // Pasa el per√≠odo correcto
                    } else {
                        console.error("Datos del empleado no encontrados para:", employeeName, "en currentStatsEmployeeData:", currentStatsEmployeeData);
                        showToast(`No se pudieron cargar los detalles para ${employeeName}.`, 'error');
                    }
                });
            });

            if (paginationInfo) {
                paginationInfo.textContent = `Mostrando ${dataToRender.length} empleados`;
            }
        }

        // --- Manejo de Filtros de Mes/A√±o para Nuevas Estad√≠sticas ---
        function populateNewStatsMonthFilterDropdown(dropdownOptionsId, buttonId, textElementId, contextType = 'main') { // 'main', 'details', 'general'
            const dropdownContent = document.getElementById(dropdownOptionsId);
            if (!dropdownContent) {
                console.error(`Dropdown content con ID '${dropdownOptionsId}' no encontrado.`);
                return;
            }
            dropdownContent.innerHTML = ''; // Limpiar opciones existentes

            let currentActiveMonth;
            if (contextType === 'details') {
                currentActiveMonth = currentSelectedPeriodForDetailsStats;
            } else if (contextType === 'general') {
                currentActiveMonth = currentSelectedPeriodForGeneralStats;
            } else { // 'main'
                currentActiveMonth = currentSelectedPeriodForMainStats;
            }

            // Opci√≥n "A√±o Completo"
            const allYearOption = document.createElement('a');
            allYearOption.href = "#";
            allYearOption.textContent = "A√±o Completo";
            allYearOption.dataset.month = "all";
            if (currentActiveMonth === 'all') {
                allYearOption.classList.add('active');
            }
            allYearOption.addEventListener('click', (e) => handleNewStatsMonthFilterClick(e, buttonId, textElementId, contextType));
            dropdownContent.appendChild(allYearOption);

            // Opciones para cada mes
            MONTH_NAMES.forEach((month, index) => {
                const option = document.createElement('a');
                option.href = "#";
                option.textContent = month;
                option.dataset.month = (index + 1).toString();
                if (currentActiveMonth === (index + 1).toString()) {
                    option.classList.add('active');
                }
                option.addEventListener('click', (e) => handleNewStatsMonthFilterClick(e, buttonId, textElementId, contextType));
                dropdownContent.appendChild(option);
            });
        }

        function handleNewStatsMonthFilterClick(event, buttonId, textElementId, contextType) {
            event.preventDefault();
            const selectedLink = event.currentTarget;
            const newSelectedMonth = selectedLink.dataset.month;
            const textElement = document.getElementById(textElementId);

            // Actualizar el texto del bot√≥n del dropdown y su valor de dataset
            if (textElement) {
                textElement.textContent = selectedLink.textContent;
                textElement.dataset.currentMonthValue = newSelectedMonth;
            }

            // Actualizar la clase 'active' en las opciones del dropdown
            const dropdownOptionsContainer = document.getElementById(buttonId).nextElementSibling;
            if (dropdownOptionsContainer) {
                dropdownOptionsContainer.querySelectorAll('a').forEach(a => a.classList.remove('active'));
            }
            selectedLink.classList.add('active');
            toggleNewStatsMonthDropdown(false, buttonId); // Cierra el dropdown

            // L√≥gica espec√≠fica seg√∫n el contexto del dropdown
            if (contextType === 'details') {
                currentSelectedPeriodForDetailsStats = newSelectedMonth;
                if (currentSelectedEmployeeForDetails) {
                    const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                    if (employeeData) {
                        showIndividualEmployeeCharts(employeeData, currentSelectedPeriodForDetailsStats);
                    }
                }
            } else if (contextType === 'general') {
                currentSelectedPeriodForGeneralStats = newSelectedMonth; // Actualiza el per√≠odo para las estad√≠sticas generales

                // Llama directamente a las funciones para renderizar los gr√°ficos generales
                // solo si la secci√≥n de estad√≠sticas generales est√° visible.
                if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                    requestAnimationFrame(() => { // Usar requestAnimationFrame para asegurar que el DOM est√° listo
                        renderGeneralStackedBarChart();
                        renderGeneralGroupedBarChart();
                    });
                }
            } else { // 'main' context (dropdown principal de la tabla de estad√≠sticas)
                currentSelectedPeriodForMainStats = newSelectedMonth;
                renderNewStatsTable();

                // Sincronizar las otras vistas si est√°n abiertas
                if (domCache.generalPlantillaStatsSection && !domCache.generalPlantillaStatsSection.classList.contains('hidden')) {
                    currentSelectedPeriodForGeneralStats = newSelectedMonth;
                    if (domCache.generalStatsSelectedMonthText) {
                        domCache.generalStatsSelectedMonthText.textContent = selectedLink.textContent;
                        domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = newSelectedMonth;
                    }
                    if (domCache.generalStatsMonthDropdownOptions) {
                        domCache.generalStatsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                            a.classList.toggle('active', a.dataset.month === newSelectedMonth);
                        });
                    }
                    requestAnimationFrame(() => {
                        renderGeneralStackedBarChart();
                        renderGeneralGroupedBarChart();
                    });
                }

                if (domCache.individualChartsSection && !domCache.individualChartsSection.classList.contains('hidden') && currentSelectedEmployeeForDetails) {
                    const employeeData = currentStatsEmployeeData.find(e => e.name === currentSelectedEmployeeForDetails);
                    if (employeeData) {
                        currentSelectedPeriodForDetailsStats = newSelectedMonth;
                        if (domCache.detailsSelectedMonthText) {
                            domCache.detailsSelectedMonthText.textContent = selectedLink.textContent;
                            domCache.detailsSelectedMonthText.dataset.currentMonthValue = newSelectedMonth;
                        }
                        if (domCache.detailsMonthDropdownOptions) {
                            domCache.detailsMonthDropdownOptions.querySelectorAll('a').forEach(a => {
                                a.classList.toggle('active', a.dataset.month === newSelectedMonth);
                            });
                        }
                        showIndividualEmployeeCharts(employeeData, newSelectedMonth);
                    }
                }
            }
        }


        function toggleNewStatsMonthDropdown(forceShow, buttonId) {
            const buttonElement = document.getElementById(buttonId);
            if (!buttonElement) return;
            const dropdownContent = buttonElement.nextElementSibling;
            if (!dropdownContent) return;
            const icon = buttonElement.querySelector('i');

            const isCurrentlyShown = dropdownContent.classList.contains('show');

            if (forceShow === true || (!isCurrentlyShown && forceShow !== false)) {
                dropdownContent.classList.add('show');
                if (icon) icon.classList.add('rotate-180');
            } else if (forceShow === false || isCurrentlyShown) {
                dropdownContent.classList.remove('show');
                if (icon) icon.classList.remove('rotate-180');
            }
        }

        // --- L√≥gica para Mostrar/Ocultar Secciones de Estad√≠sticas ---
        function showIndividualEmployeeCharts(employeeData, monthContextForCharts) {
            if (!domCache.individualChartsSection || !domCache.mainStatsTableSection ||
                !domCache.generalPlantillaStatsSection || !domCache.donutChartWrapper ||
                !domCache.calendarHeatmapWrapper || !domCache.donutCalendarGrid ||
                !domCache.selectedMonthYearDisplayDetails || !domCache.detailsEmployeeNamePlaceholder) { // Usar el nuevo placeholder
                console.error("Error: Faltan elementos del DOM cacheados para la vista individual de estad√≠sticas.");
                return;
            }

            currentSelectedEmployeeForDetails = employeeData.name; // Actualizar el empleado seleccionado globalmente para esta vista

            // Actualizar cabecera de la secci√≥n (per√≠odo)
            domCache.selectedMonthYearDisplayDetails.textContent = monthContextForCharts === 'all' ?
                `A√±o ${yearOfSchedule}` :
                `${MONTH_NAMES[parseInt(monthContextForCharts) - 1]} ${yearOfSchedule}`;

            // --- INICIO: L√≥gica para crear y poblar el selector de empleados ---
            domCache.detailsEmployeeNamePlaceholder.innerHTML = ''; // Limpiar el placeholder

            const employeeSelect = createElement('select', {
                id: 'details-employee-select', // Asignar un ID para poder a√±adirle un listener
                className: 'p-1 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm text-indigo-600 font-semibold bg-white'
            });

            employeeNamesOrdered.forEach(name => {
                const option = createElement('option', {
                    textContent: name,
                    attributes: { value: name }
                });
                if (name === employeeData.name) {
                    option.selected = true;
                }
                employeeSelect.appendChild(option);
            });

            // A√±adir el listener al nuevo select (solo si no se ha a√±adido antes o si se recrea el select)
            // Para simplificar, lo removemos y a√±adimos cada vez. Considerar optimizar si hay problemas de rendimiento.
            employeeSelect.removeEventListener('change', handleDetailsEmployeeChange); // Prevenir duplicados si se llama m√∫ltiples veces
            employeeSelect.addEventListener('change', handleDetailsEmployeeChange);

            domCache.detailsEmployeeNamePlaceholder.appendChild(employeeSelect);
            // --- FIN: L√≥gica para crear y poblar el selector de empleados ---

            // Mostrar la secci√≥n de detalles individuales y ocultar las otras
            domCache.individualChartsSection.classList.remove('hidden');
            domCache.mainStatsTableSection.classList.add('hidden');
            domCache.generalPlantillaStatsSection.classList.add('hidden');

            // L√≥gica para mostrar/ocultar calendario y ajustar layout del grid
            if (monthContextForCharts === 'all') {
                domCache.calendarHeatmapWrapper.classList.add('hidden');
                domCache.donutChartWrapper.classList.remove('md:col-span-1');
                domCache.donutChartWrapper.classList.add('md:col-span-2');
                domCache.donutCalendarGrid.classList.remove('md:grid-cols-2');
                domCache.donutCalendarGrid.classList.add('md:grid-cols-1');
            } else {
                domCache.calendarHeatmapWrapper.classList.remove('hidden');
                domCache.donutChartWrapper.classList.remove('md:col-span-2');
                domCache.donutChartWrapper.classList.add('md:col-span-1');
                domCache.calendarHeatmapWrapper.classList.remove('md:col-span-2');
                domCache.calendarHeatmapWrapper.classList.add('md:col-span-1');
                domCache.donutCalendarGrid.classList.remove('md:grid-cols-1');
                domCache.donutCalendarGrid.classList.add('md:grid-cols-2');
            }

            requestAnimationFrame(() => {
                renderDonutChartForEmployee(employeeData, monthContextForCharts);
                if (monthContextForCharts !== 'all') {
                    renderMiniCalendarHeatmapForEmployee(employeeData, monthContextForCharts);
                }
                renderKpiSummaryCardsForEmployee(employeeData, monthContextForCharts);
            });
        }

        function showGeneralPlantillaStatsCharts() {
            if (!domCache.generalPlantillaStatsSection || !domCache.mainStatsTableSection || !domCache.individualChartsSection) {
                console.error("Alguna secci√≥n de estad√≠sticas no est√° en domCache para showGeneralPlantillaStatsCharts.");
                return;
            }
            domCache.generalPlantillaStatsSection.classList.remove('hidden');
            domCache.mainStatsTableSection.classList.add('hidden');
            domCache.individualChartsSection.classList.add('hidden');

            currentSelectedPeriodForGeneralStats = currentSelectedPeriodForMainStats;

            if (domCache.generalStatsSelectedMonthText && domCache.selectedMonthText) { 
                domCache.generalStatsSelectedMonthText.textContent = domCache.selectedMonthText.textContent; 
                domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForGeneralStats;
            }
            
            if (domCache.generalStatsMonthDropdownOptions && domCache.generalStatsMonthDropdownBtn && domCache.generalStatsSelectedMonthText) {
                 populateNewStatsMonthFilterDropdown(
                     'general-stats-month-dropdown-options',
                     'general-stats-month-dropdown-btn',
                     'general-stats-selected-month-text',
                     'general'
                 );
            }

            requestAnimationFrame(() => {
                renderGeneralStackedBarChart(); 
                renderGeneralGroupedBarChart(); 
            });
        }


        function renderDonutChartForEmployee(empData, monthContext) {
            const canvasElement = domCache.donutChartCanvas;
            const messageDiv = domCache.donutChartMessage;
            if (!canvasElement || !messageDiv) {
                console.error("Elementos para Donut Chart no encontrados.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'employeeDonutChart';

            // Destruir instancia previa del gr√°fico si existe
            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }
            messageDiv.textContent = ''; // Limpiar mensajes previos

            // Inicializa dataForChart para las categor√≠as consolidadas
            let dataForChart = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };

            if (monthContext !== 'all') {
                // --- L√≥gica para contexto mensual ---
                const selectedMonthNum = parseInt(monthContext);
                // Reiniciamos dataForChart para el c√°lculo mensual espec√≠fico
                dataForChart = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };

                if (scheduleData[empData.name] && scheduleData[empData.name][selectedMonthNum]) {
                    const monthSchedule = scheduleData[empData.name][selectedMonthNum];
                    const daysInMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);

                    for (let day = 1; day <= daysInMonth; day++) {
                        const shift = monthSchedule[day];
                        if (shift && shift !== "") { // Solo procesar si hay un turno asignado
                            if (shift === 'M' || shift === 'M2') {
                                dataForChart.M = (dataForChart.M || 0) + 1;
                            } else if (shift === 'T' || shift === 'T2') {
                                dataForChart.T = (dataForChart.T || 0) + 1;
                            } else if (shift === 'N' || shift === 'N2') {
                                dataForChart.N = (dataForChart.N || 0) + 1;
                            } else if (SHIFT_TYPES.includes(shift)) { // Para L, V, B directos
                                dataForChart[shift] = (dataForChart[shift] || 0) + 1;
                            } else { // Turnos personalizados o no est√°ndar que no son L, V, B
                                dataForChart.Otro = (dataForChart.Otro || 0) + 1;
                            }
                        }
                    }
                }
            } else {
                // --- L√≥gica para contexto anual ('all') ---
                // Se asume que empData (proveniente de calculateAllEmployeeStatsForNewUI)
                // contiene los conteos anuales separados para M, M2, T, T2, N, N2.
                dataForChart.M = (empData.M || 0) + (empData.M2 || 0);
                dataForChart.T = (empData.T || 0) + (empData.T2 || 0);
                dataForChart.N = (empData.N || 0) + (empData.N2 || 0);
                dataForChart.L = empData.L || 0;
                dataForChart.V = empData.V || 0;
                dataForChart.B = empData.B || 0;
                dataForChart.Otro = empData.Otro || 0;
            }

            // Preparar datos para Chart.js
            const shiftTypesForDonutDisplay = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro'];
            const labelsForDonut = [];
            const dataCountsForDonut = [];
            const backgroundColorsForDonut = [];

            shiftTypesForDonutDisplay.forEach(st => {
                const count = dataForChart[st] || 0;
                if (count > 0) { // Solo a√±adir al gr√°fico si hay conteo
                    labelsForDonut.push(SHIFT_TYPE_FULL_NAMES[st] || st); // Usar nombre completo si est√° disponible
                    dataCountsForDonut.push(count);
                    backgroundColorsForDonut.push(getShiftBackgroundColorForChart(st));
                }
            });

            // Manejar caso sin datos
            if (dataCountsForDonut.length === 0) {
                messageDiv.textContent = 'Sin datos de turnos para mostrar en este per√≠odo.';
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height); // Limpiar canvas
                delete statsChartInstances[chartId]; // Eliminar referencia a instancia inexistente
                return;
            }

            // Crear nueva instancia de Chart.js
            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labelsForDonut,
                    datasets: [{
                        label: 'Proporci√≥n de Turnos',
                        data: dataCountsForDonut,
                        backgroundColor: backgroundColorsForDonut,
                        hoverOffset: 6,
                        borderColor: '#fff', // Borde blanco entre segmentos
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    cutout: '60%', // Tama√±o del agujero central
                    plugins: {
                        legend: {
                            position: 'bottom', // Posici√≥n de la leyenda
                            labels: {
                                font: { size: 10, weight: '500' },
                                padding: 8,
                                boxWidth: 12,
                                boxHeight: 12
                            }
                        },
                        tooltip: {
                            titleFont: { size: 13, weight: 'bold' },
                            bodyFont: { size: 12 },
                            callbacks: {
                                title: (tooltipItems) => tooltipItems[0].label,
                                label: (context) => {
                                    let value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `Cantidad: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderMiniCalendarHeatmapForEmployee(empData, monthContext) {
            const container = domCache.miniCalendarHeatmapContainer; 
            const titleElement = domCache.calendarHeatmapTitle; 
            if (!container || !titleElement) { 
                console.error("Elementos para Mini Calendar no encontrados en domCache:", domCache);
                // Comprueba si los IDs 'mini-calendar-heatmap-container' y 'calendar-heatmap-title' 
                // est√°n correctamente definidos en tu HTML y cacheados en domCache.
                return; 
            }
            container.innerHTML = '';

            const displayMonth = (monthContext === 'all' || monthContext === undefined) ? new Date().getMonth() : parseInt(monthContext) - 1;
            const displayYear = yearOfSchedule;

            titleElement.textContent = `Calendario para ${MONTH_NAMES[displayMonth]} ${displayYear}`;
    
            const CALENDAR_HEADERS_MONDAY_START = ["L", "M", "X", "J", "V", "S", "D"]; 
    
            CALENDAR_HEADERS_MONDAY_START.forEach(dayName => {
                const dayHeader = createElement('div', { className: 'calendar-header-day', textContent: dayName });
                container.appendChild(dayHeader);
            });

            const firstDayOfMonth = new Date(displayYear, displayMonth, 1);
            const daysInMonth = getDaysInMonth(displayMonth + 1, displayYear); 
    
            let firstDayOfWeek = firstDayOfMonth.getDay(); 
            firstDayOfWeek = (firstDayOfWeek === 0) ? 6 : firstDayOfWeek - 1; 

            for (let i = 0; i < firstDayOfWeek; i++) {
                container.appendChild(createElement('div', { className: 'calendar-day empty' }));
            }

            for (let dayNum = 1; dayNum <= daysInMonth; dayNum++) {
                const dayCell = createElement('div', { className: 'calendar-day border', textContent: dayNum });
                const shift = scheduleData[empData.name]?.[displayMonth + 1]?.[dayNum] || ""; 
                const shiftKeyForColor = shift === "" ? 'empty' : shift;
                // Aseg√∫rate de que currentShiftColors y SHIFT_TYPE_FULL_NAMES est√©n accesibles y correctos
                const colorConf = currentShiftColors[shiftKeyForColor] || currentShiftColors.empty;

                dayCell.style.backgroundColor = colorConf.hexBg;
                dayCell.style.color = colorConf.hexText;
                dayCell.title = `D√≠a ${dayNum}: ${shift ? (SHIFT_TYPE_FULL_NAMES[shift] || shift) : 'Vac√≠o'}`;
                container.appendChild(dayCell);
            }
        }	

        function renderKpiSummaryCardsForEmployee(empData, monthContext) {
            const container = domCache.kpiSummaryCardContainer; 
            if (!container) { console.error("Contenedor KPI no encontrado."); return; }
            container.innerHTML = '';

            let dataForKPIs; // Declarada aqu√≠ para que tenga el scope correcto

            if (monthContext !== 'all') {
                const selectedMonthNum = parseInt(monthContext);
                // Inicializa dataForKPIs para el c√°lculo mensual espec√≠fico, sin M2, T2, N2 por separado
                dataForKPIs = { name: empData.name, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0 };
                
                if (scheduleData[empData.name] && scheduleData[empData.name][selectedMonthNum]) {
                    const monthSchedule = scheduleData[empData.name][selectedMonthNum];
                    const daysInMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                    for (let day = 1; day <= daysInMonth; day++) {
                        const shift = monthSchedule[day];
                        if (shift && shift !== "") { // Solo procesar si hay un turno asignado
                            let isWorkShiftForTotal = false;

                            if (shift === 'M' || shift === 'M2') {
                                dataForKPIs.M = (dataForKPIs.M || 0) + 1;
                                isWorkShiftForTotal = true;
                            } else if (shift === 'T' || shift === 'T2') {
                                dataForKPIs.T = (dataForKPIs.T || 0) + 1;
                                isWorkShiftForTotal = true;
                            } else if (shift === 'N' || shift === 'N2') {
                                dataForKPIs.N = (dataForKPIs.N || 0) + 1;
                                isWorkShiftForTotal = true;
                            } else if (shift === 'L') {
                                dataForKPIs.L = (dataForKPIs.L || 0) + 1;
                            } else if (shift === 'V') {
                                dataForKPIs.V = (dataForKPIs.V || 0) + 1;
                            } else if (shift === 'B') {
                                dataForKPIs.B = (dataForKPIs.B || 0) + 1;
                            } else { // Turnos personalizados o no est√°ndar que no son L, V, B
                                dataForKPIs.Otro = (dataForKPIs.Otro || 0) + 1;
                                isWorkShiftForTotal = true; // Asumimos que turnos "Otro" son laborables
                            }

                            if (isWorkShiftForTotal) {
                                dataForKPIs.totalWorkDays = (dataForKPIs.totalWorkDays || 0) + 1;
                            }
                        }
                        // L√≥gica de weekendsOff
                        const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                        if (currentDate.getDay() === 6) { // S√°bado
                            const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                            if (nextDayDate.getMonth() === selectedMonthNum - 1) { // Asegurar que el domingo est√© en el mismo mes
                                const satShiftOriginal = scheduleData[empData.name]?.[selectedMonthNum]?.[day];
                                const sunShiftOriginal = scheduleData[empData.name]?.[selectedMonthNum]?.[day + 1];
                                const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "" || !satShiftOriginal);
                                const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "" || !sunShiftOriginal);
                                if (isSatFree && isSunFree) {
                                    dataForKPIs.weekendsOff = (dataForKPIs.weekendsOff || 0) + 1;
                                }
                            }
                        }
                    }
                }
            } else {
                // Para el contexto anual ('all'), usamos los datos ya agregados de empData
                // que vienen de calculateAllEmployeeStatsForNewUI
                // Aseguramos que M, T, N incluyan M2, T2, N2 si empData los tiene separados.
                dataForKPIs = {
                    name: empData.name,
                    M: (empData.M || 0) + (empData.M2 || 0),
                    T: (empData.T || 0) + (empData.T2 || 0),
                    N: (empData.N || 0) + (empData.N2 || 0),
                    L: empData.L || 0,
                    V: empData.V || 0,
                    B: empData.B || 0,
                    Otro: empData.Otro || 0,
                    totalWorkDays: empData.totalWorkDays || 0,
                    weekendsOff: empData.weekendsOff || 0
                };
            }

            const kpiMetrics = [
                { key: 'M', label: 'Ma√±anas' }, { key: 'T', label: 'Tardes' }, { key: 'N', label: 'Noches' },
                { key: 'L', label: 'Libres' }, { key: 'V', label: 'Vacaciones' }, { key: 'B', label: 'Bajas' },
                { key: 'Otro', label: 'Otros' },
                { key: 'totalWorkDays', label: 'D√≠as Trab.' }, { key: 'weekendsOff', label: 'FDS Libres' }
            ];

            kpiMetrics.forEach(metric => {
                const card = createElement('div', { className: 'kpi-card' });
                const value = dataForKPIs[metric.key] || 0; // Usar el dataForKPIs calculado
                const textColor = getShiftTextColor(metric.key); 
                card.innerHTML = `
                    <div class="kpi-value" style="color: ${textColor};">${value}</div>
                    <div class="kpi-label">${metric.label}</div>
                `;
                container.appendChild(card);
            });
        }


        // --- Renderizado de Gr√°ficos Generales de Plantilla ---
        function renderGeneralStackedBarChart() {
            const canvasElement = domCache.generalStackedBarCanvas;
            if (!canvasElement) {
                console.error("Canvas 'generalStackedBarCanvas' no encontrado en domCache.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'generalStackedBar';

            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }

            let dataForGeneralCharts;
            if (currentSelectedPeriodForGeneralStats === 'all') {
                // Log para ver qu√© currentStatsEmployeeData se usa para "A√±o Completo"
                console.log("[VERIFICACI√ìN 3] renderGeneralStackedBarChart ('A√±o Completo') - Usando currentStatsEmployeeData:", JSON.parse(JSON.stringify(currentStatsEmployeeData)));
                dataForGeneralCharts = currentStatsEmployeeData; // Datos anuales ya agregados
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForGeneralStats); 
                dataForGeneralCharts = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let effectiveShift = shift;
                                if (shift === 'M' || shift === 'M2') { effectiveShift = 'M'; }
                                else if (shift === 'T' || shift === 'T2') { effectiveShift = 'T'; }
                                else if (shift === 'N' || shift === 'N2') { effectiveShift = 'N'; }
                                else if (shift === 'L') { effectiveShift = 'L'; }
                                else if (shift === 'V') { effectiveShift = 'V'; }
                                else if (shift === 'B') { effectiveShift = 'B'; }
                                else if (!SHIFT_TYPES.includes(shift)) { 
                                    effectiveShift = 'Otro';
                                }

                                if (monthlyStats.hasOwnProperty(effectiveShift)) {
                                    monthlyStats[effectiveShift]++;
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
            }

            const employeeNames = dataForGeneralCharts.map(emp => emp.name);
            const shiftTypesToStack = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro']; 

            const datasets = shiftTypesToStack.map(shiftType => {
                return {
                    label: SHIFT_TYPE_FULL_NAMES[shiftType] || shiftType,
                    data: dataForGeneralCharts.map(emp => emp[shiftType] || 0),
                    backgroundColor: getShiftBackgroundColorForChart(shiftType),
                    borderColor: getShiftBorderColorForChart(shiftType),
                    borderWidth: 1
                };
            });

            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'bar',
                data: { labels: employeeNames, datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onHover: (event, chartElement) => {
                        hoveredEmployeeStatsIndex = chartElement[0] ? chartElement[0].index : -1;
                        if (statsChartInstances[chartId]) statsChartInstances[chartId].update('none');
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                font: {
                                    size: 10,
                                    weight: (context) => (context.index === hoveredEmployeeStatsIndex ? 'bold' : 'normal')
                                },
                                color: (context) => (context.index === hoveredEmployeeStatsIndex ? '#4f46e5' : '#374151'),
                                autoSkip: true, maxRotation: 45, minRotation: 30
                            }
                        },
                        y: { stacked: true, beginAtZero: true, ticks: { precision: 0, font: { size: 10 } } }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false } }
                }
            });
        }


        function renderGeneralGroupedBarChart() {
            const canvasElement = domCache.generalGroupedBarCanvas;
            if (!canvasElement) {
                console.error("Canvas 'generalGroupedBarCanvas' no encontrado en domCache.");
                return;
            }
            const ctx = canvasElement.getContext('2d');
            const chartId = 'generalGroupedBar';
  
            if (statsChartInstances[chartId]) {
                statsChartInstances[chartId].destroy();
            }
  
            let dataForGeneralCharts;
            if (currentSelectedPeriodForGeneralStats === 'all') {
                dataForGeneralCharts = currentStatsEmployeeData; // Usa datos anuales ya agregados
            } else {
                const selectedMonthNum = parseInt(currentSelectedPeriodForGeneralStats); // Usar la variable correcta
                dataForGeneralCharts = employeeNamesOrdered.map(empName => {
                    let monthlyStats = { name: empName, totalWorkDays: 0, weekendsOff: 0 };
                    if (scheduleData[empName] && scheduleData[empName][selectedMonthNum]) {
                        const monthData = scheduleData[empName][selectedMonthNum];
                        const daysInSelectedMonth = getDaysInMonth(selectedMonthNum, yearOfSchedule);
                        for (let day = 1; day <= daysInSelectedMonth; day++) {
                            const shift = monthData[day];
                            if (shift !== undefined && shift !== null && shift !== "") {
                                let workShift = false;
                                // Agregaci√≥n de M2, T2, N2 para contar d√≠as trabajados
                                if (shift === 'M' || shift === 'M2') { workShift = true; }
                                else if (shift === 'T' || shift === 'T2') { workShift = true; }
                                else if (shift === 'N' || shift === 'N2') { workShift = true; }
                                else if (!['L', 'V', 'B', ''].includes(shift)) { 
                                    workShift = true;
                                }
                                if (workShift) {
                                    monthlyStats.totalWorkDays++;
                                }
  
                                // L√≥gica para weekendsOff
                                const currentDate = new Date(yearOfSchedule, selectedMonthNum - 1, day);
                                if (currentDate.getDay() === 6) { 
                                    const nextDayDate = new Date(yearOfSchedule, selectedMonthNum - 1, day + 1);
                                    if (nextDayDate.getMonth() === selectedMonthNum - 1) { 
                                        const satShiftOriginal = scheduleData[empName][selectedMonthNum][day];
                                        const sunShiftOriginal = scheduleData[empName][selectedMonthNum][day + 1];
                                        const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "");
                                        const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "");
                                        if (isSatFree && isSunFree) {
                                            monthlyStats.weekendsOff++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return monthlyStats;
                });
            }
  
            const employeeNames = dataForGeneralCharts.map(emp => emp.name);
            statsChartInstances[chartId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: employeeNames,
                    datasets: [
                        {
                            label: 'D√≠as Trabajados',
                            data: dataForGeneralCharts.map(emp => emp.totalWorkDays || 0),
                            backgroundColor: getShiftBackgroundColorForChart('totalWorkDays'),
                            borderColor: getShiftBorderColorForChart('totalWorkDays'),
                            borderWidth: 1, barPercentage: 0.7, categoryPercentage: 0.6
                        },
                        {
                            label: 'FDS Libres',
                            data: dataForGeneralCharts.map(emp => emp.weekendsOff || 0),
                            backgroundColor: getShiftBackgroundColorForChart('weekendsOff'),
                            borderColor: getShiftBorderColorForChart('weekendsOff'),
                            borderWidth: 1, barPercentage: 0.7, categoryPercentage: 0.6
                        }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    onHover: (event, chartElement) => {
                        hoveredEmployeeStatsIndex = chartElement[0] ? chartElement[0].index : -1;
                        if (statsChartInstances[chartId]) statsChartInstances[chartId].update('none');
                    },
                    scales: {
                        x: {
                            ticks: {
                                font: {
                                    size: 10,
                                    weight: (context) => (context.index === hoveredEmployeeStatsIndex ? 'bold' : 'normal')
                                },
                                color: (context) => (context.index === hoveredEmployeeStatsIndex ? '#4f46e5' : '#374151'),
                                autoSkip: true, maxRotation: 45, minRotation: 30
                            }
                        },
                        y: { beginAtZero: true, ticks: { precision: 0, font: { size: 10 } } }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false } }
                }
            });
        }

        // --- Inicializaci√≥n y Event Listeners para Nuevas Estad√≠sticas ---
        function setupNewStatisticsEventListeners() {
            if (domCache.mainMonthDropdownBtn) {
                domCache.mainMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'month-dropdown-btn');
                });
            }

            if (domCache.detailsMonthDropdownBtn) {
                domCache.detailsMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'details-month-dropdown-btn');
                });
            }

            if (domCache.generalStatsMonthDropdownBtn) {
                domCache.generalStatsMonthDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNewStatsMonthDropdown(null, 'general-stats-month-dropdown-btn');
                });
            }

            if (domCache.showGeneralStatsBtn) {
                domCache.showGeneralStatsBtn.addEventListener('click', showGeneralPlantillaStatsCharts);
            }

            if (domCache.closeIndividualChartsBtn) {
                domCache.closeIndividualChartsBtn.addEventListener('click', () => {
                    if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
                    if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                    currentSelectedEmployeeForDetails = null; 
                });
            }
            if (domCache.closeGeneralStatsBtn) {
                domCache.closeGeneralStatsBtn.addEventListener('click', () => {
                    if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
                    if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                });
            }

            window.addEventListener('click', function(event) {
                if (domCache.mainMonthDropdownBtn && !domCache.mainMonthDropdownBtn.contains(event.target) &&
                    domCache.mainMonthDropdownOptions && !domCache.mainMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'month-dropdown-btn');
                }
                if (domCache.detailsMonthDropdownBtn && !domCache.detailsMonthDropdownBtn.contains(event.target) &&
                    domCache.detailsMonthDropdownOptions && !domCache.detailsMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'details-month-dropdown-btn');
                }
                if (domCache.generalStatsMonthDropdownBtn && !domCache.generalStatsMonthDropdownBtn.contains(event.target) &&
                    domCache.generalStatsMonthDropdownOptions && !domCache.generalStatsMonthDropdownOptions.contains(event.target)) {
                    toggleNewStatsMonthDropdown(false, 'general-stats-month-dropdown-btn');
                }
            });
        }

        function initializeAndRenderNewStatistics() {
            // Primero, verifica si hay datos cargados para mostrar estad√≠sticas.
            // Si no hay datos, muestra un mensaje placeholder y oculta las secciones de estad√≠sticas.
            if (!isDataLoadedForStats()) {
                const placeholder = document.getElementById('stats-placeholder-reformed'); // Asumiendo que tienes este elemento
                if (placeholder) {
                    placeholder.innerHTML = '<p class="text-center text-gray-500 py-8">No hay datos de horario cargados o no hay empleados para mostrar estad√≠sticas. <br>Importa un archivo CSV o aplica una plantilla vac√≠a.</p>';
                    placeholder.classList.remove('hidden');
                }
                // Ocultar las secciones principales de estad√≠sticas si no hay datos
                if(domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.add('hidden');
                if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
                if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
                // Deshabilitar botones o controles que dependan de datos de estad√≠sticas
                if(domCache.showGeneralStatsBtn) domCache.showGeneralStatsBtn.disabled = true;
                if(domCache.mainMonthDropdownBtn) domCache.mainMonthDropdownBtn.disabled = true;
                if(domCache.detailsMonthDropdownBtn) domCache.detailsMonthDropdownBtn.disabled = true;
                if(domCache.generalStatsMonthDropdownBtn) domCache.generalStatsMonthDropdownBtn.disabled = true;
                return;
            } else {
                // Si hay datos, oculta el placeholder y muestra la secci√≥n principal de la tabla de estad√≠sticas.
                const placeholder = document.getElementById('stats-placeholder-reformed');
                if (placeholder) placeholder.classList.add('hidden');
                if (domCache.mainStatsTableSection) domCache.mainStatsTableSection.classList.remove('hidden');
                // Habilitar botones
                if(domCache.showGeneralStatsBtn) domCache.showGeneralStatsBtn.disabled = false;
                if(domCache.mainMonthDropdownBtn) domCache.mainMonthDropdownBtn.disabled = false;
                if(domCache.detailsMonthDropdownBtn) domCache.detailsMonthDropdownBtn.disabled = false;
                if(domCache.generalStatsMonthDropdownBtn) domCache.generalStatsMonthDropdownBtn.disabled = false;
            }

            // Calcula las estad√≠sticas anuales para todos los empleados.
            // Esta funci√≥n deber√≠a llenar `currentStatsEmployeeData`.
            calculateAllEmployeeStatsForNewUI();

            // --- L√ìGICA PARA ESTABLECER EL MES POR DEFECTO DE LAS ESTAD√çSTICAS ---
            // `currentSelectedMonth` es la variable global que indica el mes activo del horario principal.
            // Esta variable ya deber√≠a estar inicializada correctamente al cargar la app
            // (ej. al mes actual, al primer mes, o al √∫ltimo mes visto guardado en localStorage).
            
            // Establece el per√≠odo para la tabla principal de estad√≠sticas al mes activo del horario.
            if (currentSelectedMonth >= 1 && currentSelectedMonth <= 12) {
                currentSelectedPeriodForMainStats = currentSelectedMonth.toString();
            } else {
                // Fallback si currentSelectedMonth no es v√°lido (aunque no deber√≠a pasar si la app se inicializa bien)
                console.warn("currentSelectedMonth no es v√°lido al inicializar estad√≠sticas, usando '1' (Enero) como fallback.");
                currentSelectedPeriodForMainStats = '1'; // Enero por defecto
            }

            // Actualiza el texto y el estado activo del dropdown principal de estad√≠sticas.
            if (domCache.selectedMonthText) {
                // Asegurarse de que el √≠ndice sea v√°lido para MONTH_NAMES
                const monthIndex = parseInt(currentSelectedPeriodForMainStats) - 1;
                if (monthIndex >= 0 && monthIndex < MONTH_NAMES.length) {
                    domCache.selectedMonthText.textContent = MONTH_NAMES[monthIndex];
                } else {
                    domCache.selectedMonthText.textContent = "A√±o Completo"; // Fallback si el mes no es v√°lido
                    currentSelectedPeriodForMainStats = 'all'; // Corregir el per√≠odo si el mes no fue v√°lido
                }
                domCache.selectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForMainStats;
            }
            // --- FIN DE LA L√ìGICA PARA ESTABLECER MES POR DEFECTO ---

            // Poblar los dropdowns de mes/a√±o para todas las secciones de estad√≠sticas.
            // La funci√≥n populateNewStatsMonthFilterDropdown usar√° las variables 
            // currentSelectedPeriod... para marcar la opci√≥n correcta como activa.

            // Dropdown para la tabla principal de estad√≠sticas
            if (domCache.mainMonthDropdownOptions && domCache.mainMonthDropdownBtn && domCache.selectedMonthText) {
                populateNewStatsMonthFilterDropdown('month-dropdown-options', 'month-dropdown-btn', 'selected-month-text', 'main');
            }

            // Dropdown para los detalles individuales del empleado
            // Se inicializa, pero su valor se sincronizar√° completamente cuando se abra un empleado.
            // Podr√≠as hacer que tambi√©n tome currentSelectedMonth por defecto aqu√≠ si lo deseas.
            currentSelectedPeriodForDetailsStats = currentSelectedPeriodForMainStats; // Sincronizar con el principal inicialmente
            if (domCache.detailsMonthDropdownOptions && domCache.detailsMonthDropdownBtn && domCache.detailsSelectedMonthText) {
                 if (domCache.detailsSelectedMonthText && currentSelectedPeriodForDetailsStats !== 'all') {
                    domCache.detailsSelectedMonthText.textContent = MONTH_NAMES[parseInt(currentSelectedPeriodForDetailsStats) - 1];
                 } else if (domCache.detailsSelectedMonthText) {
                    domCache.detailsSelectedMonthText.textContent = "A√±o Completo";
                 }
                 if(domCache.detailsSelectedMonthText) domCache.detailsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForDetailsStats;
                populateNewStatsMonthFilterDropdown('details-month-dropdown-options', 'details-month-dropdown-btn', 'details-selected-month-text', 'details');
            }
            
            // Dropdown para las estad√≠sticas generales de la plantilla
            currentSelectedPeriodForGeneralStats = currentSelectedPeriodForMainStats; // Sincronizar con el principal inicialmente
            if (domCache.generalStatsMonthDropdownOptions && domCache.generalStatsMonthDropdownBtn && domCache.generalStatsSelectedMonthText) {
                 if (domCache.generalStatsSelectedMonthText && currentSelectedPeriodForGeneralStats !== 'all') {
                    domCache.generalStatsSelectedMonthText.textContent = MONTH_NAMES[parseInt(currentSelectedPeriodForGeneralStats) - 1];
                 } else if (domCache.generalStatsSelectedMonthText) {
                    domCache.generalStatsSelectedMonthText.textContent = "A√±o Completo";
                 }
                 if(domCache.generalStatsSelectedMonthText) domCache.generalStatsSelectedMonthText.dataset.currentMonthValue = currentSelectedPeriodForGeneralStats;
                populateNewStatsMonthFilterDropdown('general-stats-month-dropdown-options', 'general-stats-month-dropdown-btn', 'general-stats-selected-month-text', 'general');
            }

            // Renderiza la cabecera y el cuerpo de la tabla principal de estad√≠sticas.
            // renderNewStatsTable() usar√° currentSelectedPeriodForMainStats.
            createNewStatsTableHeader();
            renderNewStatsTable(); 

            // Aseg√∫rate de que las vistas de detalles y generales est√©n ocultas al inicio.
            if(domCache.individualChartsSection) domCache.individualChartsSection.classList.add('hidden');
            if(domCache.generalPlantillaStatsSection) domCache.generalPlantillaStatsSection.classList.add('hidden');
        }
		
        // --- Funciones Auxiliares ---

        function getSvgCompatibleColors(appColors) {
            // Transforma currentShiftColors (con .hexBg, .hexText) al formato esperado por el SVG.
            const svgColors = {};
            const defaultColor = {
                bg: '#FFFFFF',
                text: '#2D3748'
            }; // Color por defecto para el SVG

            // Itera sobre los tipos de turno relevantes para el PDF (M, T, N, L, V, B, Otro)
            const relevantShiftTypesForPdf = [...columnOrderPdf.filter(key => key !== 'name' && key !== 'totalWorkDays' && key !== 'weekendsOff'), 'empty']; // 'empty' se usa para 'Otro' si no est√° definido

            relevantShiftTypesForPdf.forEach(shiftType => {
                const appColorKey = shiftType === 'Otro' ? 'empty' : shiftType; // 'empty' en currentShiftColors puede mapear a 'Otro'
                if (appColors[appColorKey] && appColors[appColorKey].hexBg && appColors[appColorKey].hexText) {
                    svgColors[shiftType] = {
                        bg: appColors[appColorKey].hexBg,
                        text: appColors[appColorKey].hexText
                    };
                } else {
                    // Fallback si el color no est√° definido en currentShiftColors
                    // Usar colores por defecto del prototipo o unos gen√©ricos
                    const prototypeColors = {
                        M: { bg: '#c6f6d5', text: '#276749' },
                        T: { bg: '#feebc8', text: '#b7791f' },
                        N: { bg: '#c3dafe', text: '#2c5282' },
                        L: { bg: '#e2e8f0', text: '#4a5568' },
                        V: { bg: '#fefcbf', text: '#b7791f' },
                        B: { bg: '#fed7d7', text: '#c53030' },
                        Otro: { bg: '#e9d8fd', text: '#6b46c1' },
                        empty: { bg: '#e9d8fd', text: '#6b46c1' }
                    };
                    svgColors[shiftType] = prototypeColors[shiftType] || defaultColor;
                }
            });

            // Colores espec√≠ficos para 'totalWorkDays' y 'weekendsOff' si la tabla SVG los necesita con estilo especial
            svgColors.totalWorkDays = {
                bg: '#14b8a64d',
                text: '#2D3748'
            };
            svgColors.weekendsOff = {
                bg: '#60a5fa4d',
                text: '#2D3748'
            };

            return svgColors;
        }

        function calculateMonthlyStatsForPdf(monthNum, year) {
            // Calcula las estad√≠sticas para un mes espec√≠fico.
            // Esta funci√≥n es crucial si el usuario quiere exportar el PDF para un solo mes.
            const monthlyResults = [];
            if (!employeeNamesOrdered || !scheduleData) {
                console.error("calculateMonthlyStatsForPdf: employeeNamesOrdered o scheduleData no est√°n definidos.");
                return monthlyResults;
            }

            employeeNamesOrdered.forEach(empName => {
                let stats = {
                    name: empName, M: 0, T: 0, N: 0, L: 0, V: 0, B: 0, Otro: 0, totalWorkDays: 0, weekendsOff: 0
                };
                if (scheduleData[empName] && scheduleData[empName][monthNum]) {
                    const monthSchedule = scheduleData[empName][monthNum];
                    const daysInMonth = getDaysInMonth(monthNum, year); // Aseg√∫rate que getDaysInMonth exista en tu app principal

                    for (let day = 1; day <= daysInMonth; day++) {
                        const shift = monthSchedule[day];
                        if (shift === undefined || shift === null || shift === "") continue;

                        let effectiveShift = shift;
                        let isWorkShift = false;

                        if (shift === 'M' || shift === 'M2') {
                            effectiveShift = 'M';
                            isWorkShift = true;
                        } else if (shift === 'T' || shift === 'T2') {
                            effectiveShift = 'T';
                            isWorkShift = true;
                        } else if (shift === 'N' || shift === 'N2') {
                            effectiveShift = 'N';
                            isWorkShift = true;
                        } else if (['L', 'V', 'B'].includes(shift)) {
                            effectiveShift = shift;
                        } else {
                            effectiveShift = 'Otro';
                            isWorkShift = true;
                        }

                        if (stats.hasOwnProperty(effectiveShift)) {
                            stats[effectiveShift]++;
                        }
                        if (isWorkShift) {
                            stats.totalWorkDays++;
                        }

                        const currentDate = new Date(year, monthNum - 1, day);
                        if (currentDate.getDay() === 6) { // S√°bado
                            const nextDayDate = new Date(year, monthNum - 1, day + 1);
                            if (nextDayDate.getMonth() === monthNum - 1) {
                                const satShiftOriginal = scheduleData[empName][monthNum][day];
                                const sunShiftOriginal = scheduleData[empName][monthNum][day + 1];
                                const isSatFree = (satShiftOriginal === "L" || satShiftOriginal === "V" || satShiftOriginal === "B" || satShiftOriginal === "");
                                const isSunFree = (sunShiftOriginal === "L" || sunShiftOriginal === "V" || sunShiftOriginal === "B" || sunShiftOriginal === "");
                                if (isSatFree && isSunFree) {
                                    stats.weekendsOff++;
                                }
                            }
                        }
                    }
                }
                monthlyResults.push(stats);
            });
            return monthlyResults;
        }


        // --- Funciones para el Modal de Nombre de Archivo (Estad√≠sticas PDF) ---
        function showStatsPdfFilenameModal(title, defaultName, extension, callback) {
            // Asume que domCache.filenameModalStatsPdf y sus hijos est√°n definidos
            if (!domCache.filenameModalStatsPdf || !domCache.filenameModalTitleStatsPdf || !domCache.modalFilenameInputStatsPdf || !domCache.filenameModalExtensionStatsPdf) {
                console.error("Elementos del modal de nombre de archivo para PDF de estad√≠sticas no encontrados en domCache.");
                showToast("Error interno: No se puede mostrar el di√°logo de nombre de archivo.", "error"); // Aseg√∫rate que showToast exista
                return;
            }
            domCache.filenameModalTitleStatsPdf.textContent = title;
            domCache.modalFilenameInputStatsPdf.value = defaultName;
            domCache.filenameModalExtensionStatsPdf.textContent = `Extensi√≥n: ${extension}`;
            currentStatsPdfConfirmCallback = callback;
            currentStatsPdfFileExtension = extension;
            showModal(domCache.filenameModalStatsPdf, domCache.modalFilenameInputStatsPdf); // Usa tu funci√≥n showModal existente
        }

        function hideStatsPdfFilenameModal() {
            // Asume que domCache.filenameModalStatsPdf est√° definido
            if (!domCache.filenameModalStatsPdf) return;
            hideModal(domCache.filenameModalStatsPdf); // Usa tu funci√≥n hideModal existente
            currentStatsPdfConfirmCallback = null;
            currentStatsPdfFileExtension = '';
        }

        function handleStatsPdfFilenameConfirm() {
            // Asume que domCache.modalFilenameInputStatsPdf est√° definido
            if (!domCache.modalFilenameInputStatsPdf) return;
            const filenameBase = domCache.modalFilenameInputStatsPdf.value.trim();
            if (!filenameBase) {
                showToast('Por favor, introduce un nombre para el archivo.', 'error'); // Usa tu showToast
                domCache.modalFilenameInputStatsPdf.focus();
                return;
            }
            if (currentStatsPdfConfirmCallback) {
                currentStatsPdfConfirmCallback(filenameBase + currentStatsPdfFileExtension);
            }
            hideStatsPdfFilenameModal();
        }

        // --- L√≥gica Principal de Exportaci√≥n PDF de Estad√≠sticas ---

        function initiateStatsPdfExport() {
            if (!isDataLoadedForStats()) { // Usa tu funci√≥n isDataLoadedForStats existente
                showToast('No hay datos de estad√≠sticas para exportar.', 'error');
                return;
            }

            const period = currentSelectedPeriodForMainStats;
            const year = yearOfSchedule;
            let reportSubtitleText;
            let statsDataForPdf;

            if (period === 'all') {
                reportSubtitleText = `Periodo: A√±o Completo ${year}`;
                statsDataForPdf = currentStatsEmployeeData; // Datos anuales ya agregados
            } else {
                const monthNum = parseInt(period);
                if (monthNum >= 1 && monthNum <= 12) {
                    reportSubtitleText = `Periodo: ${MONTH_NAMES[monthNum - 1]} ${year}`; // Aseg√∫rate que MONTH_NAMES exista
                    statsDataForPdf = calculateMonthlyStatsForPdf(monthNum, year);
                } else {
                    showToast("Error: Periodo de estad√≠sticas no v√°lido.", "error");
                    return;
                }
            }

            const reportTitleText = "Informe Detallado de Estad√≠sticas";
            let defaultFilenameBase = `informe_estadisticas_${period === 'all' ? 'anual' : MONTH_NAMES[parseInt(period) - 1].toLowerCase()}_${year}`;
            defaultFilenameBase = defaultFilenameBase.replace(/\s+/g, '_'); // Reemplazar espacios por guiones bajos

            showStatsPdfFilenameModal(
                "Nombre del Archivo PDF de Estad√≠sticas",
                defaultFilenameBase,
                ".pdf",
                (finalFilename) => {
                    generateAndDownloadStatsPdf(finalFilename, statsDataForPdf, reportTitleText, reportSubtitleText);
                }
            );
        }

        async function generateAndDownloadStatsPdf(finalFilename, statsDataForPeriod, reportTitleText, reportSubtitleText) {
            showToast('Generando PDF de estad√≠sticas, por favor espera...', 'info');

            const colorsForSvg = getSvgCompatibleColors(currentShiftColors); // Aseg√∫rate que currentShiftColors exista

            const svgString = getImpressiveStatsSvgString(
                statsDataForPeriod,
                statHeadersPdf,
                columnOrderPdf,
                reportTitleText,
                reportSubtitleText,
                SVG_GHM_LOGO_SIMPLE,
                colorsForSvg
            );

            if (!svgString) {
                showToast('Error al generar contenido SVG para el PDF.', 'error');
                return;
            }

            try {
                const { jsPDF } = window.jspdf; // Aseg√∫rate que jsPDF est√© disponible globalmente o importado
                const svgElement = new DOMParser().parseFromString(svgString, "image/svg+xml").documentElement;

                if (svgElement.tagName === "parsererror" || !svgElement || svgElement.querySelector('parsererror')) {
                    let errorMsg = "Error al parsear SVG.";
                    const parserErrorContent = svgElement.querySelector('parsererror div');
                    if (parserErrorContent) {
                        errorMsg += " Detalles: " + parserErrorContent.textContent.substring(0, 200);
                    } else if (svgElement.textContent.includes("parsererror")) {
                        errorMsg += " El SVG contiene errores de parseo no especificados.";
                    }
                    console.error("Error de parseo SVG:", svgElement.innerHTML);
                    throw new Error(errorMsg);
                }

                const svgWidth = parseFloat(svgElement.getAttribute('width'));
                const svgHeight = parseFloat(svgElement.getAttribute('height'));

                if (isNaN(svgWidth) || isNaN(svgHeight) || svgWidth <= 0 || svgHeight <= 0) {
                    console.error("Dimensiones SVG inv√°lidas detectadas:", svgWidth, svgHeight, "SVG:", svgString.substring(0, 500));
                    throw new Error(`Dimensiones SVG inv√°lidas: ${svgWidth}x${svgHeight}. Verifica la generaci√≥n del SVG.`);
                }

                const orientation = svgWidth > svgHeight ? 'l' : 'p';
                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'px',
                    format: [svgWidth, svgHeight],
                    hotfixes: ['px_scaling']
                });

                await pdf.svg(svgElement, {
                    x: 0,
                    y: 0,
                    width: svgWidth,
                    height: svgHeight
                });
                pdf.save(finalFilename);
                showToast(`PDF de estad√≠sticas exportado como ${finalFilename}.`, 'success');

            } catch (error) {
                console.error("Error al generar PDF de estad√≠sticas:", error, error.stack);
                showToast('Error al generar el PDF: ' + error.message, 'error');
            }
        }

        // --- Funciones de Generaci√≥n de SVG (Adaptadas del Prototipo) ---

        function getImpressiveStatsSvgString(data, headers, order, title, subtitle, logoSvgMarkup, colorsForSvg) {
		
		    const headerTextOffsetY = 5; // Ejemplo: 2 p√≠xeles hacia abajo para el texto de la cabecera
            const cellTextOffsetY = 50;   // Ejemplo: 2 p√≠xeles hacia abajo para el texto de las celdas de datos
			
			const pagePadding = 60;
			const contentWidth = 1200; // El valor que hayas ajustado en el Paso 1.1

			const finalSvgWidth = contentWidth + 2 * pagePadding; 

			const logoHeight = 60; 
			const titleFontSize = 32;        // ANTES: 28
			const subtitleFontSize = 18;     // ANTES: 16
			const sectionTitleFontSize = 22;  // ANTES: 20
			const tableHeaderFontSize = 13;   // ANTES: 9 (o el valor que ten√≠as)
			const tableCellFontSize = 10;    // ANTES: 8 (o el valor que ten√≠as)
			const chartLabelFontSize = 12;  // ANTES: 9.5
			const chartTitleFontSize = 20;   // ANTES: 18

			const textLineHeight = 1.6; 
			const sectionSpacing = 50; // Este es un espaciado grande que usaremos m√°s adelante

			const logoRenderWidth = 110; 

			let currentY = pagePadding; // currentY empieza en el margen superior

            let svgElements = [];

            svgElements.push(`<style>
                text { font-family: 'Inter', sans-serif; }
                .report-title { font-size: ${titleFontSize}px; font-weight: 700; fill: #1A202C; text-anchor: middle; }
                .report-subtitle { font-size: ${subtitleFontSize}px; fill: #4A5568; text-anchor: middle; }
                .section-title { font-size: ${sectionTitleFontSize}px; font-weight: 600; fill: #2C5282; }
                .table-header-text { font-size: ${tableHeaderFontSize}px; font-weight: bold; fill: #1A202C; text-anchor: middle; dominant-baseline: middle; }
                .table-cell-text { font-size: ${tableCellFontSize}px; fill: #2D3748; text-anchor: middle; dominant-baseline: middle; font-weight: bold; }
                .table-cell-text.name { text-anchor: start; font-weight: bold; fill: #1A202C; }
                .table-header-rect { fill: #EBF4FF; stroke: #BEE3F8; stroke-width: 1; } 
                .table-cell-rect { stroke: #E2E8F0; stroke-width: 1; }
                .chart-title { font-size: ${chartTitleFontSize}px; font-weight: 600; fill: #2C5282; text-anchor: middle; }
                .chart-label { font-size: ${chartLabelFontSize}px; fill: #4A5568; text-anchor: middle; }
                .chart-axis-line { stroke: #A0AEC0; stroke-width: 1; }
                .chart-grid-line { stroke: #E2E8F0; stroke-width: 0.5; stroke-dasharray: 3,3; }
                .legend-item rect { stroke: #CBD5E0; stroke-width:0.5; } 
                .legend-item text { font-size: 10px; fill: #2D3748; dominant-baseline: middle; }
            </style>`);

            const logoX = (finalSvgWidth / 2) - (logoRenderWidth / 2);
            const titleAreaX = logoX + 120; // Espacio para el logo
            const titleAreaWidth = contentWidth - 120;

            svgElements.push(`<g transform="translate(${logoX}, ${currentY})">${logoSvgMarkup}</g>`);
            currentY += logoHeight + 20; // Ajuste para que el subt√≠tulo no se solape
            svgElements.push(`<text x="${finalSvgWidth / 2}" y="${currentY + logoHeight / 2 + 5 }" class="report-title">${title}</text>`);
			currentY += titleFontSize + 10; // Espacio: altura de la fuente del t√≠tulo (28px) + 10px de margen.
            svgElements.push(`<text x="${finalSvgWidth / 2}" y="${currentY + logoHeight / 2 + subtitleFontSize}" class="report-subtitle">${subtitle}</text>`);
            currentY += subtitleFontSize + sectionSpacing; 

            svgElements.push(`<text x="${finalSvgWidth / 2}" y="${currentY}" class="section-title" text-anchor="middle"></text>`);
            currentY += sectionTitleFontSize * textLineHeight + 20;

            const tableCellHeight = tableCellFontSize * textLineHeight * 2.8;
            const tableHeaderHeight = tableHeaderFontSize * textLineHeight * 2.8;

            const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            document.body.appendChild(tempSvg); // Necesario para getComputedTextLength
            const colWidths = {};
            let minNumericColWidth = 85;
            order.forEach(key => {
                let maxWidth = 0;
                const thTest = Object.assign(document.createElementNS("http://www.w3.org/2000/svg", "text"), {
                    textContent: headers[key] || key,
                    style: `font-size:${tableHeaderFontSize}px; font-weight:bold; font-family:Inter, sans-serif;`
                });
                tempSvg.appendChild(thTest);
                maxWidth = Math.max(maxWidth, thTest.getComputedTextLength());
                tempSvg.removeChild(thTest);
                (data || []).forEach(row => { // Asegurar que data no sea undefined
                    const tdTest = Object.assign(document.createElementNS("http://www.w3.org/2000/svg", "text"), {
                        textContent: String(row[key] !== undefined ? row[key] : '-'),
                        style: `font-size:${tableCellFontSize}px; font-weight:bold; font-family:Inter, sans-serif;`
                    });
                    tempSvg.appendChild(tdTest);
                    maxWidth = Math.max(maxWidth, tdTest.getComputedTextLength());
                    tempSvg.removeChild(tdTest);
                });
                colWidths[key] = Math.max(minNumericColWidth, maxWidth + 45); // M√°s padding
                if (key === 'name') colWidths[key] = Math.max(230, colWidths[key]);
            });
            document.body.removeChild(tempSvg);

            const tableTotalWidth = order.reduce((sum, key) => sum + colWidths[key], 0);
            const tableStartX = Math.max(pagePadding, (contentWidth + 2 * pagePadding - tableTotalWidth) / 2);

            let currentTableX = tableStartX;
            order.forEach(key => {
                svgElements.push(`<rect x="${currentTableX}" y="${currentY}" width="${colWidths[key]}" height="${tableHeaderHeight}" class="table-header-rect" />`);
                svgElements.push(`<text x="${currentTableX + colWidths[key] / 2}" y="${currentY + tableHeaderHeight / 2 + headerTextOffsetY}" class="table-header-text">${headers[key] || key}</text>`);
                currentTableX += colWidths[key];
            });
            currentY += tableHeaderHeight;

            (data || []).forEach((row, rowIndex) => { // Asegurar que data no sea undefined
                currentTableX = tableStartX;
                order.forEach(key => {
                    const cellValue = row[key] !== undefined ? String(row[key]) : '-';
                    let cellFill = (rowIndex % 2 === 0) ? '#FFFFFF' : '#F9FAFB';
                    let textColor = '#2D3748';

                    const shiftKeyForColor = key === 'Otro' ? 'empty' : key;
                    if (colorsForSvg[shiftKeyForColor]) {
                        cellFill = colorsForSvg[shiftKeyForColor].bg;
                        textColor = colorsForSvg[shiftKeyForColor].text;
                    } else if (key === 'name') {
                        textColor = '#1A202C';
                    }

                    svgElements.push(`<rect x="${currentTableX}" y="${currentY}" width="${colWidths[key]}" height="${tableCellHeight}" class="table-cell-rect" fill="${cellFill}" />`);
                    const textClass = key === 'name' ? 'table-cell-text name' : 'table-cell-text';
                    const textX = key === 'name' ? currentTableX + 20 : currentTableX + colWidths[key] / 2;
                    const textY = currentY + tableCellHeight / 2;
                    svgElements.push(`<text x="${textX}" y="${textY}" class="${textClass}" fill="${textColor}">${cellValue}</text>`);
                    currentTableX += colWidths[key];
                });
                currentY += tableCellHeight;
            });
            currentY += sectionSpacing;

            const chartAreaY = currentY;
            const chartAreaWidth = contentWidth;
            const chartHeight = 300;

            svgElements.push(`<text x="${pagePadding + chartAreaWidth / 2}" y="${chartAreaY}" class="chart-title">Distribuci√≥n General de Turnos por Empleado</text>`);
            currentY = chartAreaY + chartTitleFontSize * textLineHeight + 20;
            svgElements.push(drawStackedShiftDistributionBarChartSvg(data, pagePadding, currentY, chartAreaWidth, chartHeight, headers, colorsForSvg));
            currentY += chartHeight + pagePadding;

            const finalSvgHeight = currentY;

            return `<svg width="${finalSvgWidth}" height="${finalSvgHeight}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">${svgElements.join('')}</svg>`;
        }

        function drawStackedShiftDistributionBarChartSvg(allEmployeeData, x, y, width, height, headers, colorsForSvg) {
            let chartElements = [];
            if (!allEmployeeData || allEmployeeData.length === 0) return `<text x="${x + width/2}" y="${y + height/2}" class="chart-label">Sin datos para gr√°fico</text>`;

            const chartDrawAreaHeight = height - 80;
            const legendItemHeight = 20;
            const legendSpacing = 10;
            const xAxisLabelHeight = 40;

            const shiftKeys = ['M', 'T', 'N', 'L', 'V', 'B', 'Otro'];

            let maxTotalShifts = 0;
            allEmployeeData.forEach(emp => {
                const total = shiftKeys.reduce((sum, key) => sum + (emp[key] || 0), 0);
                if (total > maxTotalShifts) maxTotalShifts = total;
            });
            maxTotalShifts = maxTotalShifts > 0 ? Math.ceil(maxTotalShifts * 1.30) : 10;

            const numEmployees = allEmployeeData.length;
            const barGroupSpacing = 35;
            const totalBarAreaWidth = width - (barGroupSpacing * (numEmployees > 1 ? numEmployees - 1 : 0));
            const barWidth = Math.max(10, totalBarAreaWidth / numEmployees * 0.30);

            allEmployeeData.forEach((emp, index) => {
                const groupX = x + index * (barWidth + barGroupSpacing) + ((width - (numEmployees * barWidth + (numEmployees - 1) * barGroupSpacing)) / 2);
                let currentStackY = y + chartDrawAreaHeight;
                let totalEmpShifts = 0;

                shiftKeys.forEach(key => {
                    const count = emp[key] || 0;
                    if (count > 0) {
                        const segmentHeight = (count / maxTotalShifts) * chartDrawAreaHeight;
                        const isTopSegment = (currentStackY - segmentHeight <= y + 1);
                        const rxValue = isTopSegment ? "3" : "0";
                        const shiftKeyForColor = key === 'Otro' ? 'empty' : key;
                        const barColor = colorsForSvg[shiftKeyForColor] ? colorsForSvg[shiftKeyForColor].bg : '#CCCCCC';

                        chartElements.push(`<rect x="${groupX}" y="${currentStackY - segmentHeight}" width="${barWidth}" height="${segmentHeight}" fill="${barColor}" class="chart-bar" rx="${rxValue}" ry="${rxValue}">
                                                <title>${headers[key] || key}: ${count}</title>
                                           </rect>`);
                        currentStackY -= segmentHeight;
                        totalEmpShifts += count;
                    }
                });
				chartElements.push(`<text x="${groupX + barWidth / 2}" y="${y + chartDrawAreaHeight + 22}" class="chart-label" style="text-anchor:middle; font-weight:500;">${emp.name}</text>`);
                if (totalEmpShifts > 0 && currentStackY > y + 12) {
                    chartElements.push(`<text x="${groupX + barWidth / 2}" y="${currentStackY - 8}" class="chart-label" style="font-weight:bold; font-size:9px; text-anchor:middle; fill:#1A202C;">${totalEmpShifts}</text>`);
                }
            });

            chartElements.push(`<line x1="${x}" y1="${y - 10}" x2="${x}" y2="${y + chartDrawAreaHeight}" class="chart-axis-line"/>`);
            chartElements.push(`<line x1="${x}" y1="${y + chartDrawAreaHeight}" x2="${x + width}" y2="${y + chartDrawAreaHeight}" class="chart-axis-line"/>`);
            const numGridLines = Math.max(4, Math.min(5, Math.floor(maxTotalShifts / 5) || 1));
            for (let i = 0; i <= numGridLines; i++) {
                const val = Math.round(maxTotalShifts * (i / numGridLines));
                const lineY = y + chartDrawAreaHeight - (chartDrawAreaHeight * (i / numGridLines));
                chartElements.push(`<text x="${x - 12}" y="${lineY + 3}" class="chart-label" style="text-anchor:end;">${val}</text>`);
                if (i > 0 && i <= numGridLines) chartElements.push(`<line x1="${x}" y1="${lineY}" x2="${x + width}" y2="${lineY}" class="chart-grid-line"/>`);
            }

            let legendX = x;
            let legendY = y + chartDrawAreaHeight + xAxisLabelHeight + 15;
            const legendItemsPerRow = Math.floor(width / 120);
            let itemsInCurrentRow = 0;
            const legendItemWidthEstimate = 120;

            shiftKeys.forEach(key => {
                if (allEmployeeData.some(emp => emp[key] > 0)) {
                    if (itemsInCurrentRow >= legendItemsPerRow && legendItemsPerRow > 0) {
                        legendX = x;
                        legendY += legendItemHeight + legendSpacing;
                        itemsInCurrentRow = 0;
                    }
                    const shiftKeyForColor = key === 'Otro' ? 'empty' : key;
                    const legendColor = colorsForSvg[shiftKeyForColor] ? colorsForSvg[shiftKeyForColor].bg : '#CCCCCC';

                    chartElements.push(`<g class="legend-item">`);
                    chartElements.push(`<rect x="${legendX}" y="${legendY}" width="12" height="12" fill="${legendColor}" rx="3" ry="3"/>`);
                    chartElements.push(`<text x="${legendX + 18}" y="${legendY + 9}">${headers[key] || key}</text>`);
                    chartElements.push(`</g>`);
                    legendX += legendItemWidthEstimate;
                    itemsInCurrentRow++;
                }
            });
            return chartElements.join('');
        }

        function handleDetailsEmployeeChange(event) {
            const newEmployeeName = event.target.value;
            if (!newEmployeeName || newEmployeeName === currentSelectedEmployeeForDetails) {
                return; // No hacer nada si no hay selecci√≥n o es el mismo empleado
            }

            const newEmployeeData = currentStatsEmployeeData.find(e => e.name === newEmployeeName);
            if (newEmployeeData) {
                // `currentSelectedPeriodForDetailsStats` ya deber√≠a tener el per√≠odo correcto
                // porque fue establecido cuando se abri√≥ la vista de detalles por primera vez
                // o cuando se cambi√≥ el per√≠odo en el dropdown de per√≠odo de esta secci√≥n.
                showIndividualEmployeeCharts(newEmployeeData, currentSelectedPeriodForDetailsStats);
            } else {
                console.error(`No se encontraron datos para el empleado: ${newEmployeeName}`);
                showToast(`Error al cargar detalles para ${newEmployeeName}.`, 'error');
            }
        }

        function getDefaultRulesConfig() {
            return {
                personsPerShift: {
                    enabled: false,
                    settings: {
                        morning: { min: null, max: null },
                        afternoon: { min: null, max: null },
                        night: { min: null, max: null }
                    }
                },
                // --- NUEVA NORMA ---
                maxConsecutiveWorkdays: {
                    enabled: false,
                    maxDays: 7 
                }
                // --- FIN NUEVA NORMA ---
            };
        }
        
        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA loadRulesConfigFromLocalStorage ---
        function loadRulesConfigFromLocalStorage() {
            const compressedRulesString = localStorage.getItem(LOCAL_STORAGE_KEY_RULES);
            const parsedRules = decompressData(compressedRulesString, "rulesConfig");
            const defaultConfig = getDefaultRulesConfig(); // Obtener la estructura completa por defecto
        
            if (parsedRules) {
                rulesConfig = {
                    personsPerShift: { // Mantener la estructura existente para personsPerShift
                        ...defaultConfig.personsPerShift, // Empezar con los defaults de esta sub-norma
                        ...(parsedRules.personsPerShift || {}), // Sobrescribir con lo guardado si existe
                        settings: {
                            ...defaultConfig.personsPerShift.settings,
                            ...((parsedRules.personsPerShift || {}).settings || {})
                        }
                    },
                    // --- NUEVA NORMA ---
                    maxConsecutiveWorkdays: {
                        ...defaultConfig.maxConsecutiveWorkdays, // Empezar con los defaults de esta sub-norma
                        ...(parsedRules.maxConsecutiveWorkdays || {}) // Sobrescribir con lo guardado si existe
                    }
                    // --- FIN NUEVA NORMA ---
                };
                // Asegurarse de que maxDays sea un n√∫mero si est√° presente
                if (rulesConfig.maxConsecutiveWorkdays && typeof rulesConfig.maxConsecutiveWorkdays.maxDays === 'string') {
                    const parsedMaxDays = parseInt(rulesConfig.maxConsecutiveWorkdays.maxDays, 10);
                    if (!isNaN(parsedMaxDays)) {
                        rulesConfig.maxConsecutiveWorkdays.maxDays = parsedMaxDays;
                    } else {
                        rulesConfig.maxConsecutiveWorkdays.maxDays = defaultConfig.maxConsecutiveWorkdays.maxDays; // Fallback
                    }
                }
        
        
            } else {
                rulesConfig = defaultConfig; // Si no hay nada guardado, usar todos los defaults
            }
        }
        
        // --- FIN DE LA FUNCI√ìN MODIFICADA loadRulesConfigFromLocalStorage ---

        
        // --- COMIENZO DE LA FUNCI√ìN MODIFICADA saveRulesConfigToLocalStorage ---
        function saveRulesConfigToLocalStorage() {
            try {
                const rulesJsonString = JSON.stringify(rulesConfig);
                const compressedRules = LZString.compressToUTF16(rulesJsonString);
                localStorage.setItem(LOCAL_STORAGE_KEY_RULES, compressedRules);
            } catch (e) {
                console.error("Error al comprimir y guardar configuraci√≥n de normas en localStorage:", e);
                showToast("Error al guardar la configuraci√≥n de normas.", "error");
            }
        }
        // --- FIN DE LA FUNCI√ìN MODIFICADA saveRulesConfigToLocalStorage ---
		
        // --- NUEVA FUNCI√ìN AUXILIAR para Descompresi√≥n con Fallback ---
        function decompressData(compressedString, keyNameForLog = "data") {
            if (!compressedString) {
                return null; // No hay nada que descomprimir
            }
            try {
                // Intenta descomprimir primero
                const decompressedJsonString = LZString.decompressFromUTF16(compressedString);

                if (decompressedJsonString === null || decompressedJsonString === "") {
                    // Si la descompresi√≥n resulta en null o vac√≠o, podr√≠a ser:
                    // 1. El dato original era realmente null/vac√≠o y fue comprimido como tal.
                    // 2. El dato no estaba comprimido (formato antiguo).
                    // 3. La cadena comprimida est√° corrupta de una manera que decompressFromUTF16 devuelve null/vac√≠o.
                    console.warn(`Descompresi√≥n de '${keyNameForLog}' result√≥ en null/vac√≠o. Intentando parsear como JSON no comprimido.`);
                    try {
                        // Intenta parsear la cadena original como si fuera JSON no comprimido
                        return JSON.parse(compressedString);
                    } catch (directParseError) {
                        console.error(`Error al parsear '${keyNameForLog}' directamente (sin comprimir). Dato podr√≠a estar corrupto o no ser JSON:`, directParseError, "Valor original:", compressedString.substring(0,100));
                        return null; // No se pudo parsear ni comprimido ni sin comprimir
                    }
                }
                // Si la descompresi√≥n fue exitosa y devolvi√≥ algo, intenta parsearlo como JSON
                return JSON.parse(decompressedJsonString);
            } catch (error) {
                // Este catch se activar√≠a si LZString.decompressFromUTF16 falla (raro) o si JSON.parse(decompressedJsonString) falla.
                console.error(`Error al descomprimir o parsear '${keyNameForLog}'. Intentando parsear como JSON no comprimido:`, error, "Valor original:", compressedString.substring(0,100));
                 // Fallback: intenta parsear la cadena original como si fuera JSON no comprimido
                try {
                    return JSON.parse(compressedString);
                } catch (fallbackParseError) {
                    console.error(`Error final al parsear '${keyNameForLog}' (incluso como no comprimido). Dato corrupto:`, fallbackParseError, "Valor original:", compressedString.substring(0,100));
                    return null; // Dato corrupto
                }
            }
        }
        // --- FIN DE LA NUEVA FUNCI√ìN AUXILIAR ---

        function renderRulesModal() {
            // Asegurarse de que los elementos del DOM para la norma "Personas por Turno" est√©n cacheados y existan
            if (domCache.personsPerShiftEnabledToggle && domCache.personsPerShiftSettingsInputs && 
                domCache.personsMorningMin && domCache.personsMorningMax &&
                domCache.personsAfternoonMin && domCache.personsAfternoonMax &&
                domCache.personsNightMin && domCache.personsNightMax) {
                
                const configPersons = rulesConfig.personsPerShift;
                domCache.personsPerShiftEnabledToggle.checked = configPersons.enabled;
                domCache.personsPerShiftSettingsInputs.classList.toggle('hidden-by-default', !configPersons.enabled);
        
                domCache.personsMorningMin.value = configPersons.settings.morning.min !== null ? configPersons.settings.morning.min : '';
                domCache.personsMorningMax.value = configPersons.settings.morning.max !== null ? configPersons.settings.morning.max : '';
                domCache.personsAfternoonMin.value = configPersons.settings.afternoon.min !== null ? configPersons.settings.afternoon.min : '';
                domCache.personsAfternoonMax.value = configPersons.settings.afternoon.max !== null ? configPersons.settings.afternoon.max : '';
                domCache.personsNightMin.value = configPersons.settings.night.min !== null ? configPersons.settings.night.min : '';
                domCache.personsNightMax.value = configPersons.settings.night.max !== null ? configPersons.settings.night.max : '';
            } else {
                console.warn("Algunos elementos del DOM para la norma 'Personas por Turno' no est√°n cacheados o no existen.");
            }
        
            // --- NUEVA NORMA: M√°ximo D√≠as Consecutivos ---
            // Asegurarse de que los elementos del DOM para la norma "M√°ximo D√≠as Consecutivos" est√©n cacheados y existan
            if (domCache.maxConsecutiveDaysEnabledToggle && domCache.maxConsecutiveDaysSettingsInputs && domCache.maxConsecutiveDaysInput) {
                const consecutiveConfig = rulesConfig.maxConsecutiveWorkdays;
                domCache.maxConsecutiveDaysEnabledToggle.checked = consecutiveConfig.enabled;
                domCache.maxConsecutiveDaysSettingsInputs.classList.toggle('hidden-by-default', !consecutiveConfig.enabled);
                domCache.maxConsecutiveDaysInput.value = consecutiveConfig.maxDays !== null ? consecutiveConfig.maxDays : '';
            } else {
                console.warn("Algunos elementos del DOM para la norma 'M√°ximo D√≠as Consecutivos' no est√°n cacheados o no existen.");
            }
            // --- FIN NUEVA NORMA ---
        
            // Deshabilitar bot√≥n de guardar inicialmente, se habilita si hay cambios
            if (domCache.saveRulesButton) {
                domCache.saveRulesButton.disabled = true;
            }
        }
        
        
        function handleRuleInputChange() {
            // Habilita el bot√≥n de guardar si hay cambios en los inputs de las normas
            if (domCache.saveRulesButton) {
                domCache.saveRulesButton.disabled = false;
            }
        }
        
        // Funci√≥n existente, solo para referencia de d√≥nde se llama a la funci√≥n modificada

        /**
         * Guarda la configuraci√≥n de las normas desde los inputs del modal a la variable global rulesConfig,
         * la persiste en localStorage, y actualiza la validaci√≥n y visualizaci√≥n de violaciones.
         * Tambi√©n maneja el estado de deshacer/rehacer y el indicador de cambios no guardados.
         */
        function saveRulesConfigFromModal() {
            // Validar que todos los elementos del DOM necesarios est√©n cacheados y existan
            if (!domCache.personsPerShiftEnabledToggle || 
                !domCache.personsMorningMin || !domCache.personsMorningMax ||
                !domCache.personsAfternoonMin || !domCache.personsAfternoonMax ||
                !domCache.personsNightMin || !domCache.personsNightMax ||
                !domCache.maxConsecutiveDaysEnabledToggle || !domCache.maxConsecutiveDaysInput || // A√±adidos para la nueva norma
                !domCache.saveRulesButton) { // Asegurarse que el bot√≥n de guardar tambi√©n est√©
                console.error("Error: Elementos del modal de normas no encontrados en domCache. No se pueden guardar las normas.");
                showToast("Error interno al intentar guardar normas.", "error");
                return;
            }
        
            const oldRulesConfigSnapshot = JSON.stringify(rulesConfig); // Guardar estado anterior para Deshacer/Rehacer
            let validationPassed = true; // Flag para controlar la validaci√≥n de todos los inputs
        
            // --- Procesamiento de la norma "Personas por Turno" ---
            rulesConfig.personsPerShift.enabled = domCache.personsPerShiftEnabledToggle.checked;
            
            const parseInput = (value) => {
                const trimmed = value.trim();
                if (trimmed === '') return null; // Si est√° vac√≠o, se considera null (sin l√≠mite)
                const num = parseInt(trimmed, 10);
                return isNaN(num) || num < 0 ? 'error' : num; // Devolver 'error' si no es n√∫mero v√°lido >= 0
            };
        
            const settingsPersons = rulesConfig.personsPerShift.settings;
            settingsPersons.morning.min = parseInput(domCache.personsMorningMin.value);
            settingsPersons.morning.max = parseInput(domCache.personsMorningMax.value);
            settingsPersons.afternoon.min = parseInput(domCache.personsAfternoonMin.value);
            settingsPersons.afternoon.max = parseInput(domCache.personsAfternoonMax.value);
            settingsPersons.night.min = parseInput(domCache.personsNightMin.value);
            settingsPersons.night.max = parseInput(domCache.personsNightMax.value);
        
            // Validaci√≥n para "Personas por Turno"
            const shiftTypesForValidationPersons = ['morning', 'afternoon', 'night'];
            shiftTypesForValidationPersons.forEach(shiftKey => {
                const shiftSetting = settingsPersons[shiftKey];
                if (shiftSetting.min === 'error' || shiftSetting.max === 'error') {
                    showToast(`Error para ${shiftKey.charAt(0).toUpperCase() + shiftKey.slice(1)}: Introduce un n√∫mero v√°lido.`, 'error');
                    validationPassed = false;
                } else if (shiftSetting.min !== null && shiftSetting.max !== null && shiftSetting.min > shiftSetting.max) {
                    showToast(`Error para ${shiftKey.charAt(0).toUpperCase() + shiftKey.slice(1)}: El M√≠n. no puede ser mayor que el M√°x.`, 'error');
                    validationPassed = false;
                }
            });
        
            // --- Procesamiento de la NUEVA NORMA: M√°ximo D√≠as Consecutivos ---
            rulesConfig.maxConsecutiveWorkdays.enabled = domCache.maxConsecutiveDaysEnabledToggle.checked;
            const maxDaysValue = domCache.maxConsecutiveDaysInput.value.trim();
        
            if (rulesConfig.maxConsecutiveWorkdays.enabled && maxDaysValue === '') {
                showToast('Error para M√°x. D√≠as Consecutivos: El valor no puede estar vac√≠o si la norma est√° activada.', 'error');
                validationPassed = false;
            } else if (maxDaysValue !== '') { // Solo validar si no est√° vac√≠o
                const numMaxDays = parseInt(maxDaysValue, 10);
                if (isNaN(numMaxDays) || numMaxDays < 1) {
                    showToast('Error para M√°x. D√≠as Consecutivos: Introduce un n√∫mero v√°lido mayor o igual a 1.', 'error');
                    validationPassed = false;
                } else {
                    rulesConfig.maxConsecutiveWorkdays.maxDays = numMaxDays;
                }
            } else if (maxDaysValue === '' && !rulesConfig.maxConsecutiveWorkdays.enabled) {
                // Si est√° desactivada y el campo vac√≠o, est√° bien, se guarda como null (o el valor por defecto)
                rulesConfig.maxConsecutiveWorkdays.maxDays = getDefaultRulesConfig().maxConsecutiveWorkdays.maxDays; // o null
            }
             // --- FIN NUEVA NORMA ---
        
            if (!validationPassed) {
                return; // No guardar si alguna validaci√≥n falla
            }
        
            saveRulesConfigToLocalStorage(); // Guardar la configuraci√≥n completa en localStorage
        
            const newRulesConfigSnapshot = JSON.stringify(rulesConfig);
            if (newRulesConfigSnapshot !== oldRulesConfigSnapshot) {
                saveStateForUndo("Configuraci√≥n de normas modificada."); 
                hasUnsavedChanges = true; 
                updateUnsavedChangesIndicator(); 
            }
        
            validateAndDisplayRuleViolations(); // Revalidar y mostrar violaciones con la nueva configuraci√≥n
        
            showToast("Configuraci√≥n de normas guardada.", "success");
            if (domCache.saveRulesButton) {
                domCache.saveRulesButton.disabled = true; // Deshabilitar bot√≥n de guardar ya que los cambios est√°n aplicados
            }
        }
        
        
        /**
         * Cuenta el n√∫mero de empleados asignados a cada tipo de turno principal para un d√≠a espec√≠fico.
         * Agrupa los turnos M/M2, T/T2, N/N2.
         * @param {number} year - El a√±o.
         * @param {number} month - El mes (1-12).
         * @param {number} day - El d√≠a.
         * @returns {object} Un objeto con los conteos: { morning: countM, afternoon: countT, night: countN }.
         */
        function getShiftCountsForDay(year, month, day) {
            const counts = { morning: 0, afternoon: 0, night: 0 };
            if (!scheduleData || employeeNamesOrdered.length === 0) {
                return counts;
            }
        
            employeeNamesOrdered.forEach(employeeName => {
                if (scheduleData[employeeName] && scheduleData[employeeName][month] && scheduleData[employeeName][month][day]) {
                    const shift = scheduleData[employeeName][month][day];
                    if (shift === 'M' || shift === 'M2') {
                        counts.morning++;
                    } else if (shift === 'T' || shift === 'T2') {
                        counts.afternoon++;
                    } else if (shift === 'N' || shift === 'N2') {
                        counts.night++;
                    }
                    // Otros turnos como L, V, B, o personalizados no se cuentan aqu√≠ para esta norma espec√≠fica.
                }
            });
            return counts;
        }
		
        /**
         * Verifica si la norma de "Personas por Turno" se cumple para un d√≠a, dados los conteos de turnos.
         * @param {object} shiftCounts - Objeto con conteos: { morning, afternoon, night }.
         * @param {object} currentRulesConfig - La configuraci√≥n actual de las normas (rulesConfig.personsPerShift).
         * @returns {Array<string>} Un array de strings describiendo las violaciones. Array vac√≠o si no hay violaciones o la norma est√° desactivada.
         */
        function checkPersonsPerShiftRuleForDay(shiftCounts, currentRulesConfig) {
            const violations = [];
            if (!currentRulesConfig || !currentRulesConfig.enabled || !currentRulesConfig.settings) {
                return violations; // Norma desactivada o configuraci√≥n inv√°lida
            }
        
            const { morning, afternoon, night } = currentRulesConfig.settings;
        
            // Verificar Ma√±ana
            if (morning.min !== null && shiftCounts.morning < morning.min) {
                violations.push(`Ma√±ana: M√≠n. ${morning.min} (Actual: ${shiftCounts.morning})`);
            }
            if (morning.max !== null && shiftCounts.morning > morning.max) {
                violations.push(`Ma√±ana: M√°x. ${morning.max} (Actual: ${shiftCounts.morning})`);
            }
        
            // Verificar Tarde
            if (afternoon.min !== null && shiftCounts.afternoon < afternoon.min) {
                violations.push(`Tarde: M√≠n. ${afternoon.min} (Actual: ${shiftCounts.afternoon})`);
            }
            if (afternoon.max !== null && shiftCounts.afternoon > afternoon.max) {
                violations.push(`Tarde: M√°x. ${afternoon.max} (Actual: ${shiftCounts.afternoon})`);
            }
        
            // Verificar Noche
            if (night.min !== null && shiftCounts.night < night.min) {
                violations.push(`Noche: M√≠n. ${night.min} (Actual: ${shiftCounts.night})`);
            }
            if (night.max !== null && shiftCounts.night > night.max) {
                violations.push(`Noche: M√°x. ${night.max} (Actual: ${shiftCounts.night})`);
            }
        
            return violations;
        }

        /**
         * Muestra un resumen de las violaciones de normas activas en el modal de Normas.
         */
        function displayRuleViolationsSummary() {
            if (!domCache.ruleViolationsSummarySection || !domCache.ruleViolationsSummary) return;
        
            let summaryHtml = '';
            let hasAnyViolation = false;
        
            // Secci√≥n para Personas por Turno
            if (rulesConfig.personsPerShift.enabled) {
                domCache.ruleViolationsSummarySection.classList.remove('hidden-by-default'); // Mostrar secci√≥n si alguna norma est√° activa
                const personViolationKeys = Object.keys(activeRuleViolations);
                if (personViolationKeys.length > 0) {
                    hasAnyViolation = true;
                    summaryHtml += '<h5 class="font-semibold text-gray-700 mt-2 mb-1">Violaciones de Personas por Turno:</h5><ul class="list-disc pl-5 space-y-1">';
                    personViolationKeys.forEach(key => {
                        const [year, month, day] = key.split('-');
                        summaryHtml += `<li><strong>${day}/${SHORT_MONTH_NAMES[parseInt(month)-1]}/${year}:</strong><ul>`;
                        activeRuleViolations[key].forEach(violationMsg => {
                            summaryHtml += `<li class="text-red-600 ml-4">- ${violationMsg}</li>`;
                        });
                        summaryHtml += `</ul></li>`;
                    });
                    summaryHtml += '</ul>';
                } else {
                     summaryHtml += '<p class="text-green-600"><i class="fas fa-check-circle mr-2"></i>Norma de Personas por Turno: Sin violaciones detectadas.</p>';
                }
            }
        
            // --- NUEVA SECCI√ìN para M√°ximo D√≠as Consecutivos ---
            if (rulesConfig.maxConsecutiveWorkdays.enabled) {
                domCache.ruleViolationsSummarySection.classList.remove('hidden-by-default'); // Mostrar secci√≥n si alguna norma est√° activa
                const consecutiveViolationKeys = Object.keys(activeConsecutiveDayViolations);
                if (consecutiveViolationKeys.length > 0) {
                    hasAnyViolation = true;
                    summaryHtml += '<h5 class="font-semibold text-gray-700 mt-3 mb-1">Violaciones de M√°x. D√≠as Consecutivos Trabajados:</h5><ul class="list-disc pl-5 space-y-1">';
                    consecutiveViolationKeys.forEach(empName => {
                        activeConsecutiveDayViolations[empName].forEach(violation => {
                            const startDateStr = `${violation.startDate.day}/${SHORT_MONTH_NAMES[violation.startDate.month-1]}`;
                            const endDateStr = `${violation.endDate.day}/${SHORT_MONTH_NAMES[violation.endDate.month-1]}`;
                            summaryHtml += `<li class="text-red-600 ml-4">- <strong>${empName}:</strong> ${violation.count} d√≠as (M√°x: ${rulesConfig.maxConsecutiveWorkdays.maxDays}) desde ${startDateStr} hasta ${endDateStr}.</li>`;
                        });
                    });
                    summaryHtml += '</ul>';
                } else {
                    summaryHtml += '<p class="text-green-600 mt-2"><i class="fas fa-check-circle mr-2"></i>Norma de M√°x. D√≠as Consecutivos: Sin violaciones detectadas.</p>';
                }
            }
            // --- FIN NUEVA SECCI√ìN ---
        
            if (!rulesConfig.personsPerShift.enabled && !rulesConfig.maxConsecutiveWorkdays.enabled) {
                // Si AMBAS normas est√°n desactivadas, ocultar la secci√≥n del resumen.
                domCache.ruleViolationsSummarySection.classList.add('hidden-by-default');
                domCache.ruleViolationsSummary.innerHTML = '<p>Ninguna norma est√° activada.</p>';
            } else if (!hasAnyViolation && (rulesConfig.personsPerShift.enabled || rulesConfig.maxConsecutiveWorkdays.enabled)) {
                // Si al menos una norma est√° activa pero no hay violaciones de ning√∫n tipo
                if (summaryHtml === '') { // Si el HTML est√° vac√≠o porque solo hab√≠a mensajes de "sin violaciones"
                     summaryHtml = '<p class="text-green-600"><i class="fas fa-check-circle mr-2"></i>Todas las normas activas se cumplen para los d√≠as visibles.</p>';
                }
                domCache.ruleViolationsSummary.innerHTML = summaryHtml;
            } else {
                domCache.ruleViolationsSummary.innerHTML = summaryHtml;
            }
        }
        
        function isWorkDay(shiftValue) {
            if (!shiftValue || shiftValue.trim() === "") return false; // Vac√≠o no es trabajo
            if (['L', 'V', 'B'].includes(shiftValue.toUpperCase())) return false; // Libre, Vacaciones, Baja no son trabajo
            return true; // Cualquier otra cosa (M, T, N, M2, T2, N2, texto personalizado) es trabajo
        }
      
        function checkMaxConsecutiveWorkdays(employeeName) {
            const violations = [];
            if (!rulesConfig.maxConsecutiveWorkdays.enabled || rulesConfig.maxConsecutiveWorkdays.maxDays === null) {
                return violations;
            }
        
            let consecutiveWorkDayCount = 0;
            let sequenceStartDate = null;
            const yearToValidate = yearOfSchedule; // Usar el a√±o global
        
            for (let month = 1; month <= 12; month++) {
                const daysInMonth = getDaysInMonth(month, yearToValidate);
                for (let day = 1; day <= daysInMonth; day++) {
                    const shift = scheduleData[employeeName]?.[month]?.[day];
        
                    if (isWorkDay(shift)) {
                        consecutiveWorkDayCount++;
                        if (sequenceStartDate === null) {
                            sequenceStartDate = { day: day, month: month, year: yearToValidate };
                        }
                    } else { // No es d√≠a de trabajo, o es un d√≠a libre/vacaciones/baja
                        if (consecutiveWorkDayCount > rulesConfig.maxConsecutiveWorkdays.maxDays) {
                            violations.push({
                                employee: employeeName,
                                startDate: sequenceStartDate,
                                endDate: { day: day - 1, month: month, year: yearToValidate }, // El d√≠a anterior fue el √∫ltimo trabajado
                                count: consecutiveWorkDayCount
                            });
                        }
                        consecutiveWorkDayCount = 0;
                        sequenceStartDate = null;
                    }
                }
            }
            // Comprobar al final del a√±o si la √∫ltima secuencia fue una violaci√≥n
            if (consecutiveWorkDayCount > rulesConfig.maxConsecutiveWorkdays.maxDays && sequenceStartDate) {
                 // El √∫ltimo d√≠a trabajado es el √∫ltimo d√≠a del √∫ltimo mes procesado con trabajo
                let lastWorkDay = { day: 0, month: 0, year: yearToValidate };
                for (let m_rev = 12; m_rev >=1; m_rev--) {
                    const d_rev_max = getDaysInMonth(m_rev, yearToValidate);
                    let found = false;
                    for (let d_rev = d_rev_max; d_rev >=1; d_rev--) {
                        if (isWorkDay(scheduleData[employeeName]?.[m_rev]?.[d_rev])) {
                            lastWorkDay = { day: d_rev, month: m_rev, year: yearToValidate };
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
        
                violations.push({
                    employee: employeeName,
                    startDate: sequenceStartDate,
                    endDate: lastWorkDay,
                    count: consecutiveWorkDayCount
                });
            }
            return violations;
        }
        	  
        function applyConsecutiveDayViolationStyles() {
            // Primero, limpiar cualquier estilo de violaci√≥n de d√≠as consecutivos previo
            domCache.scheduleTableBody.querySelectorAll('.consecutive-workday-violation-cell').forEach(cell => {
                cell.classList.remove('consecutive-workday-violation-cell', 'is-first-in-sequence', 'is-last-in-sequence');
                // Tambi√©n resetea los bordes individuales si los aplicaste directamente
                cell.style.borderTop = '';
                cell.style.borderBottom = '';
                cell.style.borderLeft = '';
                cell.style.borderRight = '';
            });
        
            if (!rulesConfig.maxConsecutiveWorkdays.enabled) return;
        
            for (const empName in activeConsecutiveDayViolations) {
                activeConsecutiveDayViolations[empName].forEach(violation => {
                    // Iterar desde startDate hasta endDate
                    let currentDate = new Date(violation.startDate.year, violation.startDate.month - 1, violation.startDate.day);
                    const endDateObj = new Date(violation.endDate.year, violation.endDate.month - 1, violation.endDate.day);
        
                    let isFirstCellInSequence = true;
        
                    while (currentDate <= endDateObj) {
                        const currentDay = currentDate.getDate();
                        const currentMonth = currentDate.getMonth() + 1;
                        const currentYear = currentDate.getFullYear();
        
                        // Solo aplicar si la celda est√° visible en la vista actual
                        let cellElement = null;
                        if (currentViewMode === 'monthly' && currentMonth === currentSelectedMonth && currentYear === yearOfSchedule) {
                            cellElement = domCache.scheduleTableBody.querySelector(`td[data-employee="${empName}"][data-month="${currentMonth}"][data-day="${currentDay}"]`);
                        } else if (currentViewMode === 'annual' && currentYear === yearOfSchedule) {
                             cellElement = domCache.scheduleTableBody.querySelector(`td[data-employee="${empName}"][data-month="${currentMonth}"][data-day="${currentDay}"]`);
                        }
        
                        if (cellElement) {
                            cellElement.classList.add('consecutive-workday-violation-cell');
                            if (isFirstCellInSequence) {
                                cellElement.classList.add('is-first-in-sequence');
                                isFirstCellInSequence = false;
                            }
                            if (currentDate.getTime() === endDateObj.getTime()) { // Compara tiempo para ser preciso
                                cellElement.classList.add('is-last-in-sequence');
                            }
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                });
            }
        }

        function showConfirmClearLocalStorageModal() {
            if (!domCache.confirmClearLocalStorageModal || !domCache.modalConfirmClearLocalStorage || !domCache.clearLocalStorageCountdownMessage) {
                console.error("Error: Elementos del modal de confirmaci√≥n de borrado no encontrados en domCache.");
                showToast("Error al intentar mostrar la confirmaci√≥n de borrado.", "error");
                return;
            }
        
            domCache.modalConfirmClearLocalStorage.disabled = true;
            let countdown = 5; // Segundos para la cuenta atr√°s
            domCache.clearLocalStorageCountdownMessage.textContent = `Bot√≥n activo en ${countdown}s...`;
        
            if (clearLocalStorageCountdownInterval) {
                clearInterval(clearLocalStorageCountdownInterval);
            }
        
            clearLocalStorageCountdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    domCache.clearLocalStorageCountdownMessage.textContent = `Bot√≥n activo en ${countdown}s...`;
                } else {
                    clearInterval(clearLocalStorageCountdownInterval);
                    clearLocalStorageCountdownInterval = null;
                    domCache.clearLocalStorageCountdownMessage.textContent = '¬°Bot√≥n de borrado activo!';
                    domCache.modalConfirmClearLocalStorage.disabled = false;
                }
            }, 1000);
            showModal(domCache.confirmClearLocalStorageModal); // Asumiendo que tienes una funci√≥n showModal(modalElement)
        }
        
        /**
         * Maneja la confirmaci√≥n del borrado de todos los datos locales.
         * Elimina todas las claves especificadas de localStorage y resetea el estado de la aplicaci√≥n.
         */
        function handleConfirmClearLocalStorage() {
            try {
                ALL_LOCAL_STORAGE_KEYS.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(`Clave de localStorage eliminada: ${key}`);
                });
        
                showToast('Todos los datos locales han sido borrados.', 'success');
                
                // Importante: Resetear el estado de la aplicaci√≥n a su estado inicial
                // para que la UI refleje que no hay datos.
                resetToInitialState(false); // false para borrar tambi√©n las notas si es parte del reseteo.
                                            // Esta funci√≥n deber√≠a resetear variables en memoria y la UI.
        
            } catch (error) {
                console.error("Error al borrar datos de localStorage:", error);
                showToast('Error al intentar borrar los datos locales.', 'error');
            } finally {
                hideModal(domCache.confirmClearLocalStorageModal); // Asumiendo que tienes hideModal(modalElement)
                if (clearLocalStorageCountdownInterval) {
                    clearInterval(clearLocalStorageCountdownInterval);
                    clearLocalStorageCountdownInterval = null;
                }
            }
        }
        

    </script>
</body>
</html>
